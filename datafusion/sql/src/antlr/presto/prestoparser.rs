// Generated from Presto.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use super::prestolistener::*;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::error_listener::ErrorListener;
use antlr_rust::error_strategy::{DefaultErrorStrategy, ErrorStrategy};
use antlr_rust::errors::*;
use antlr_rust::int_stream::EOF;
use antlr_rust::lazy_static;
use antlr_rust::parser::{BaseParser, Parser, ParserNodeType, ParserRecog};
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::parser_rule_context::{
    cast, cast_mut, BaseParserRuleContext, ParserRuleContext,
};
use antlr_rust::recognizer::{Actions, Recognizer};
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::token::{OwningToken, Token, TOKEN_EOF};
use antlr_rust::token_factory::{CommonTokenFactory, TokenAware, TokenFactory};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::tree::*;
use antlr_rust::vocabulary::{Vocabulary, VocabularyImpl};
use antlr_rust::PredictionContextCache;
use antlr_rust::TokenSource;
use antlr_rust::{TidAble, TidExt};

use std::any::{Any, TypeId};
use std::borrow::{Borrow, BorrowMut};
use std::cell::RefCell;
use std::convert::TryFrom;
use std::marker::PhantomData;
use std::ops::{Deref, DerefMut};
use std::rc::Rc;
use std::sync::Arc;

pub const T__0: isize = 1;
pub const T__1: isize = 2;
pub const T__2: isize = 3;
pub const T__3: isize = 4;
pub const T__4: isize = 5;
pub const T__5: isize = 6;
pub const T__6: isize = 7;
pub const T__7: isize = 8;
pub const T__8: isize = 9;
pub const T__9: isize = 10;
pub const T__10: isize = 11;
pub const T__11: isize = 12;
pub const T__12: isize = 13;
pub const T__13: isize = 14;
pub const T__14: isize = 15;
pub const T__15: isize = 16;
pub const ABSENT: isize = 17;
pub const ADD: isize = 18;
pub const ADMIN: isize = 19;
pub const AFTER: isize = 20;
pub const ALL: isize = 21;
pub const ALTER: isize = 22;
pub const ANALYZE: isize = 23;
pub const AND: isize = 24;
pub const ANY: isize = 25;
pub const ARRAY: isize = 26;
pub const AS: isize = 27;
pub const ASC: isize = 28;
pub const AT: isize = 29;
pub const AUTHORIZATION: isize = 30;
pub const BERNOULLI: isize = 31;
pub const BETWEEN: isize = 32;
pub const BOTH: isize = 33;
pub const BY: isize = 34;
pub const CALL: isize = 35;
pub const CASCADE: isize = 36;
pub const CASE: isize = 37;
pub const CAST: isize = 38;
pub const CATALOGS: isize = 39;
pub const COLUMN: isize = 40;
pub const COLUMNS: isize = 41;
pub const COMMA: isize = 42;
pub const COMMENT: isize = 43;
pub const COMMIT: isize = 44;
pub const COMMITTED: isize = 45;
pub const CONDITIONAL: isize = 46;
pub const CONSTRAINT: isize = 47;
pub const COUNT: isize = 48;
pub const COPARTITION: isize = 49;
pub const CREATE: isize = 50;
pub const CROSS: isize = 51;
pub const CUBE: isize = 52;
pub const CURRENT: isize = 53;
pub const CURRENT_CATALOG: isize = 54;
pub const CURRENT_DATE: isize = 55;
pub const CURRENT_PATH: isize = 56;
pub const CURRENT_ROLE: isize = 57;
pub const CURRENT_SCHEMA: isize = 58;
pub const CURRENT_TIME: isize = 59;
pub const CURRENT_TIMESTAMP: isize = 60;
pub const CURRENT_USER: isize = 61;
pub const DATA: isize = 62;
pub const DATE: isize = 63;
pub const DAY: isize = 64;
pub const DEALLOCATE: isize = 65;
pub const DEFAULT: isize = 66;
pub const DEFINE: isize = 67;
pub const DEFINER: isize = 68;
pub const DELETE: isize = 69;
pub const DENY: isize = 70;
pub const DESC: isize = 71;
pub const DESCRIBE: isize = 72;
pub const DESCRIPTOR: isize = 73;
pub const DISTINCT: isize = 74;
pub const DISTRIBUTED: isize = 75;
pub const DOUBLE: isize = 76;
pub const DROP: isize = 77;
pub const ELSE: isize = 78;
pub const EMPTY: isize = 79;
pub const ENCODING: isize = 80;
pub const END: isize = 81;
pub const ERROR: isize = 82;
pub const ESCAPE: isize = 83;
pub const EXCEPT: isize = 84;
pub const EXCLUDING: isize = 85;
pub const EXECUTE: isize = 86;
pub const EXISTS: isize = 87;
pub const EXPLAIN: isize = 88;
pub const EXTRACT: isize = 89;
pub const FALSE: isize = 90;
pub const FETCH: isize = 91;
pub const FILTER: isize = 92;
pub const FINAL: isize = 93;
pub const FIRST: isize = 94;
pub const FOLLOWING: isize = 95;
pub const FOR: isize = 96;
pub const FORMAT: isize = 97;
pub const FROM: isize = 98;
pub const FULL: isize = 99;
pub const FUNCTIONS: isize = 100;
pub const GRACE: isize = 101;
pub const GRANT: isize = 102;
pub const GRANTED: isize = 103;
pub const GRANTS: isize = 104;
pub const GRAPHVIZ: isize = 105;
pub const GROUP: isize = 106;
pub const GROUPING: isize = 107;
pub const GROUPS: isize = 108;
pub const HAVING: isize = 109;
pub const HOUR: isize = 110;
pub const IF: isize = 111;
pub const IGNORE: isize = 112;
pub const IN: isize = 113;
pub const INCLUDING: isize = 114;
pub const INITIAL: isize = 115;
pub const INNER: isize = 116;
pub const INPUT: isize = 117;
pub const INSERT: isize = 118;
pub const INTERSECT: isize = 119;
pub const INTERVAL: isize = 120;
pub const INTO: isize = 121;
pub const INVOKER: isize = 122;
pub const IO: isize = 123;
pub const IS: isize = 124;
pub const ISOLATION: isize = 125;
pub const JOIN: isize = 126;
pub const JSON: isize = 127;
pub const JSON_ARRAY: isize = 128;
pub const JSON_EXISTS: isize = 129;
pub const JSON_OBJECT: isize = 130;
pub const JSON_QUERY: isize = 131;
pub const JSON_VALUE: isize = 132;
pub const KEEP: isize = 133;
pub const KEY: isize = 134;
pub const KEYS: isize = 135;
pub const LAST: isize = 136;
pub const LATERAL: isize = 137;
pub const LEADING: isize = 138;
pub const LEFT: isize = 139;
pub const LEVEL: isize = 140;
pub const LIKE: isize = 141;
pub const LIMIT: isize = 142;
pub const LISTAGG: isize = 143;
pub const LOCAL: isize = 144;
pub const LOCALTIME: isize = 145;
pub const LOCALTIMESTAMP: isize = 146;
pub const LOGICAL: isize = 147;
pub const MAP: isize = 148;
pub const MATCH: isize = 149;
pub const MATCHED: isize = 150;
pub const MATCHES: isize = 151;
pub const MATCH_RECOGNIZE: isize = 152;
pub const MATERIALIZED: isize = 153;
pub const MEASURES: isize = 154;
pub const MERGE: isize = 155;
pub const MINUTE: isize = 156;
pub const MONTH: isize = 157;
pub const NATURAL: isize = 158;
pub const NEXT: isize = 159;
pub const NFC: isize = 160;
pub const NFD: isize = 161;
pub const NFKC: isize = 162;
pub const NFKD: isize = 163;
pub const NO: isize = 164;
pub const NONE: isize = 165;
pub const NORMALIZE: isize = 166;
pub const NOT: isize = 167;
pub const NULL: isize = 168;
pub const NULLIF: isize = 169;
pub const NULLS: isize = 170;
pub const OBJECT: isize = 171;
pub const OF: isize = 172;
pub const OFFSET: isize = 173;
pub const OMIT: isize = 174;
pub const ON: isize = 175;
pub const ONE: isize = 176;
pub const ONLY: isize = 177;
pub const OPTION: isize = 178;
pub const OR: isize = 179;
pub const ORDER: isize = 180;
pub const ORDINALITY: isize = 181;
pub const OUTER: isize = 182;
pub const OUTPUT: isize = 183;
pub const OVER: isize = 184;
pub const OVERFLOW: isize = 185;
pub const PARTITION: isize = 186;
pub const PARTITIONS: isize = 187;
pub const PASSING: isize = 188;
pub const PAST: isize = 189;
pub const PATH: isize = 190;
pub const PATTERN: isize = 191;
pub const PER: isize = 192;
pub const PERIOD: isize = 193;
pub const PERMUTE: isize = 194;
pub const POSITION: isize = 195;
pub const PRECEDING: isize = 196;
pub const PRECISION: isize = 197;
pub const PREPARE: isize = 198;
pub const PRIVILEGES: isize = 199;
pub const PROPERTIES: isize = 200;
pub const PRUNE: isize = 201;
pub const QUOTES: isize = 202;
pub const RANGE: isize = 203;
pub const READ: isize = 204;
pub const RECURSIVE: isize = 205;
pub const REFRESH: isize = 206;
pub const RENAME: isize = 207;
pub const REPEATABLE: isize = 208;
pub const REPLACE: isize = 209;
pub const RESET: isize = 210;
pub const RESPECT: isize = 211;
pub const RESTRICT: isize = 212;
pub const RETURNING: isize = 213;
pub const REVOKE: isize = 214;
pub const RIGHT: isize = 215;
pub const ROLE: isize = 216;
pub const ROLES: isize = 217;
pub const ROLLBACK: isize = 218;
pub const ROLLUP: isize = 219;
pub const ROW: isize = 220;
pub const ROWS: isize = 221;
pub const RUNNING: isize = 222;
pub const SCALAR: isize = 223;
pub const SCHEMA: isize = 224;
pub const SCHEMAS: isize = 225;
pub const SECOND: isize = 226;
pub const SECURITY: isize = 227;
pub const SEEK: isize = 228;
pub const SELECT: isize = 229;
pub const SERIALIZABLE: isize = 230;
pub const SESSION: isize = 231;
pub const SET: isize = 232;
pub const SETS: isize = 233;
pub const SHOW: isize = 234;
pub const SOME: isize = 235;
pub const START: isize = 236;
pub const STATS: isize = 237;
pub const SUBSET: isize = 238;
pub const SUBSTRING: isize = 239;
pub const SYSTEM: isize = 240;
pub const TABLE: isize = 241;
pub const TABLES: isize = 242;
pub const TABLESAMPLE: isize = 243;
pub const TEXT: isize = 244;
pub const TEXT_STRING: isize = 245;
pub const THEN: isize = 246;
pub const TIES: isize = 247;
pub const TIME: isize = 248;
pub const TIMESTAMP: isize = 249;
pub const TO: isize = 250;
pub const TRAILING: isize = 251;
pub const TRANSACTION: isize = 252;
pub const TRIM: isize = 253;
pub const TRUE: isize = 254;
pub const TRUNCATE: isize = 255;
pub const TRY_CAST: isize = 256;
pub const TYPE: isize = 257;
pub const UESCAPE: isize = 258;
pub const UNBOUNDED: isize = 259;
pub const UNCOMMITTED: isize = 260;
pub const UNCONDITIONAL: isize = 261;
pub const UNION: isize = 262;
pub const UNIQUE: isize = 263;
pub const UNKNOWN: isize = 264;
pub const UNMATCHED: isize = 265;
pub const UNNEST: isize = 266;
pub const UPDATE: isize = 267;
pub const USE: isize = 268;
pub const USER: isize = 269;
pub const USING: isize = 270;
pub const UTF16: isize = 271;
pub const UTF32: isize = 272;
pub const UTF8: isize = 273;
pub const VALIDATE: isize = 274;
pub const VALUE: isize = 275;
pub const VALUES: isize = 276;
pub const VERBOSE: isize = 277;
pub const VERSION: isize = 278;
pub const VIEW: isize = 279;
pub const WHEN: isize = 280;
pub const WHERE: isize = 281;
pub const WINDOW: isize = 282;
pub const WITH: isize = 283;
pub const WITHIN: isize = 284;
pub const WITHOUT: isize = 285;
pub const WORK: isize = 286;
pub const WRAPPER: isize = 287;
pub const WRITE: isize = 288;
pub const YEAR: isize = 289;
pub const ZONE: isize = 290;
pub const EQ: isize = 291;
pub const NEQ: isize = 292;
pub const LT: isize = 293;
pub const LTE: isize = 294;
pub const GT: isize = 295;
pub const GTE: isize = 296;
pub const PLUS: isize = 297;
pub const MINUS: isize = 298;
pub const ASTERISK: isize = 299;
pub const SLASH: isize = 300;
pub const PERCENT: isize = 301;
pub const CONCAT: isize = 302;
pub const QUESTION_MARK: isize = 303;
pub const STRING: isize = 304;
pub const UNICODE_STRING: isize = 305;
pub const BINARY_LITERAL: isize = 306;
pub const INTEGER_VALUE: isize = 307;
pub const DECIMAL_VALUE: isize = 308;
pub const DOUBLE_VALUE: isize = 309;
pub const IDENTIFIER: isize = 310;
pub const DIGIT_IDENTIFIER: isize = 311;
pub const QUOTED_IDENTIFIER: isize = 312;
pub const BACKQUOTED_IDENTIFIER: isize = 313;
pub const SIMPLE_COMMENT: isize = 314;
pub const BRACKETED_COMMENT: isize = 315;
pub const WS: isize = 316;
pub const UNRECOGNIZED: isize = 317;
pub const DELIMITER: isize = 318;
pub const RULE_singleStatement: usize = 0;
pub const RULE_standaloneExpression: usize = 1;
pub const RULE_standalonePathSpecification: usize = 2;
pub const RULE_standaloneType: usize = 3;
pub const RULE_standaloneRowPattern: usize = 4;
pub const RULE_statement: usize = 5;
pub const RULE_query: usize = 6;
pub const RULE_with: usize = 7;
pub const RULE_tableElement: usize = 8;
pub const RULE_columnDefinition: usize = 9;
pub const RULE_likeClause: usize = 10;
pub const RULE_properties: usize = 11;
pub const RULE_propertyAssignments: usize = 12;
pub const RULE_property: usize = 13;
pub const RULE_propertyValue: usize = 14;
pub const RULE_queryNoWith: usize = 15;
pub const RULE_limitRowCount: usize = 16;
pub const RULE_rowCount: usize = 17;
pub const RULE_queryTerm: usize = 18;
pub const RULE_queryPrimary: usize = 19;
pub const RULE_sortItem: usize = 20;
pub const RULE_querySpecification: usize = 21;
pub const RULE_querySelectItems: usize = 22;
pub const RULE_groupBy: usize = 23;
pub const RULE_groupingElement: usize = 24;
pub const RULE_groupingSet: usize = 25;
pub const RULE_windowDefinition: usize = 26;
pub const RULE_windowSpecification: usize = 27;
pub const RULE_namedQuery: usize = 28;
pub const RULE_setQuantifier: usize = 29;
pub const RULE_selectItem: usize = 30;
pub const RULE_relation: usize = 31;
pub const RULE_joinType: usize = 32;
pub const RULE_joinCriteria: usize = 33;
pub const RULE_sampledRelation: usize = 34;
pub const RULE_sampleType: usize = 35;
pub const RULE_trimsSpecification: usize = 36;
pub const RULE_listAggOverflowBehavior: usize = 37;
pub const RULE_listaggCountIndication: usize = 38;
pub const RULE_patternRecognition: usize = 39;
pub const RULE_measureDefinition: usize = 40;
pub const RULE_rowsPerMatch: usize = 41;
pub const RULE_emptyMatchHandling: usize = 42;
pub const RULE_skipTo: usize = 43;
pub const RULE_subsetDefinition: usize = 44;
pub const RULE_variableDefinition: usize = 45;
pub const RULE_aliasedRelation: usize = 46;
pub const RULE_columnAliases: usize = 47;
pub const RULE_relationPrimary: usize = 48;
pub const RULE_tableFunctionCall: usize = 49;
pub const RULE_tableFunctionArgument: usize = 50;
pub const RULE_tableArgument: usize = 51;
pub const RULE_tableArgumentRelation: usize = 52;
pub const RULE_descriptorArgument: usize = 53;
pub const RULE_descriptorField: usize = 54;
pub const RULE_copartitionTables: usize = 55;
pub const RULE_expression: usize = 56;
pub const RULE_booleanExpression: usize = 57;
pub const RULE_predicate: usize = 58;
pub const RULE_valueExpression: usize = 59;
pub const RULE_primaryExpression: usize = 60;
pub const RULE_jsonPathInvocation: usize = 61;
pub const RULE_jsonValueExpression: usize = 62;
pub const RULE_jsonRepresentation: usize = 63;
pub const RULE_jsonArgument: usize = 64;
pub const RULE_jsonExistsErrorBehavior: usize = 65;
pub const RULE_jsonValueBehavior: usize = 66;
pub const RULE_jsonQueryWrapperBehavior: usize = 67;
pub const RULE_jsonQueryBehavior: usize = 68;
pub const RULE_jsonObjectMember: usize = 69;
pub const RULE_processingMode: usize = 70;
pub const RULE_nullTreatment: usize = 71;
pub const RULE_string: usize = 72;
pub const RULE_timeZoneSpecifier: usize = 73;
pub const RULE_comparisonOperator: usize = 74;
pub const RULE_comparisonQuantifier: usize = 75;
pub const RULE_booleanValue: usize = 76;
pub const RULE_interval: usize = 77;
pub const RULE_intervalField: usize = 78;
pub const RULE_normalForm: usize = 79;
pub const RULE_type_: usize = 80;
pub const RULE_rowField: usize = 81;
pub const RULE_typeParameter: usize = 82;
pub const RULE_whenClause: usize = 83;
pub const RULE_filter: usize = 84;
pub const RULE_mergeCase: usize = 85;
pub const RULE_over: usize = 86;
pub const RULE_windowFrame: usize = 87;
pub const RULE_frameExtent: usize = 88;
pub const RULE_frameBound: usize = 89;
pub const RULE_rowPattern: usize = 90;
pub const RULE_patternPrimary: usize = 91;
pub const RULE_patternQuantifier: usize = 92;
pub const RULE_updateAssignment: usize = 93;
pub const RULE_explainOption: usize = 94;
pub const RULE_transactionMode: usize = 95;
pub const RULE_levelOfIsolation: usize = 96;
pub const RULE_callArgument: usize = 97;
pub const RULE_pathElement: usize = 98;
pub const RULE_pathSpecification: usize = 99;
pub const RULE_privilege: usize = 100;
pub const RULE_qualifiedName: usize = 101;
pub const RULE_queryPeriod: usize = 102;
pub const RULE_rangeType: usize = 103;
pub const RULE_grantor: usize = 104;
pub const RULE_principal: usize = 105;
pub const RULE_roles: usize = 106;
pub const RULE_identifier: usize = 107;
pub const RULE_number: usize = 108;
pub const RULE_nonReserved: usize = 109;
pub const ruleNames: [&'static str; 110] = [
    "singleStatement",
    "standaloneExpression",
    "standalonePathSpecification",
    "standaloneType",
    "standaloneRowPattern",
    "statement",
    "query",
    "with",
    "tableElement",
    "columnDefinition",
    "likeClause",
    "properties",
    "propertyAssignments",
    "property",
    "propertyValue",
    "queryNoWith",
    "limitRowCount",
    "rowCount",
    "queryTerm",
    "queryPrimary",
    "sortItem",
    "querySpecification",
    "querySelectItems",
    "groupBy",
    "groupingElement",
    "groupingSet",
    "windowDefinition",
    "windowSpecification",
    "namedQuery",
    "setQuantifier",
    "selectItem",
    "relation",
    "joinType",
    "joinCriteria",
    "sampledRelation",
    "sampleType",
    "trimsSpecification",
    "listAggOverflowBehavior",
    "listaggCountIndication",
    "patternRecognition",
    "measureDefinition",
    "rowsPerMatch",
    "emptyMatchHandling",
    "skipTo",
    "subsetDefinition",
    "variableDefinition",
    "aliasedRelation",
    "columnAliases",
    "relationPrimary",
    "tableFunctionCall",
    "tableFunctionArgument",
    "tableArgument",
    "tableArgumentRelation",
    "descriptorArgument",
    "descriptorField",
    "copartitionTables",
    "expression",
    "booleanExpression",
    "predicate",
    "valueExpression",
    "primaryExpression",
    "jsonPathInvocation",
    "jsonValueExpression",
    "jsonRepresentation",
    "jsonArgument",
    "jsonExistsErrorBehavior",
    "jsonValueBehavior",
    "jsonQueryWrapperBehavior",
    "jsonQueryBehavior",
    "jsonObjectMember",
    "processingMode",
    "nullTreatment",
    "string",
    "timeZoneSpecifier",
    "comparisonOperator",
    "comparisonQuantifier",
    "booleanValue",
    "interval",
    "intervalField",
    "normalForm",
    "type_",
    "rowField",
    "typeParameter",
    "whenClause",
    "filter",
    "mergeCase",
    "over",
    "windowFrame",
    "frameExtent",
    "frameBound",
    "rowPattern",
    "patternPrimary",
    "patternQuantifier",
    "updateAssignment",
    "explainOption",
    "transactionMode",
    "levelOfIsolation",
    "callArgument",
    "pathElement",
    "pathSpecification",
    "privilege",
    "qualifiedName",
    "queryPeriod",
    "rangeType",
    "grantor",
    "principal",
    "roles",
    "identifier",
    "number",
    "nonReserved",
];

pub const _LITERAL_NAMES: [Option<&'static str>; 304] = [
    None,
    Some("'.'"),
    Some("'('"),
    Some("')'"),
    Some("'SKIP'"),
    Some("'=>'"),
    Some("'->'"),
    Some("'['"),
    Some("']'"),
    Some("':'"),
    Some("'|'"),
    Some("'^'"),
    Some("'$'"),
    Some("'{-'"),
    Some("'-}'"),
    Some("'{'"),
    Some("'}'"),
    Some("'ABSENT'"),
    Some("'ADD'"),
    Some("'ADMIN'"),
    Some("'AFTER'"),
    Some("'ALL'"),
    Some("'ALTER'"),
    Some("'ANALYZE'"),
    Some("'AND'"),
    Some("'ANY'"),
    Some("'ARRAY'"),
    Some("'AS'"),
    Some("'ASC'"),
    Some("'AT'"),
    Some("'AUTHORIZATION'"),
    Some("'BERNOULLI'"),
    Some("'BETWEEN'"),
    Some("'BOTH'"),
    Some("'BY'"),
    Some("'CALL'"),
    Some("'CASCADE'"),
    Some("'CASE'"),
    Some("'CAST'"),
    Some("'CATALOGS'"),
    Some("'COLUMN'"),
    Some("'COLUMNS'"),
    Some("','"),
    Some("'COMMENT'"),
    Some("'COMMIT'"),
    Some("'COMMITTED'"),
    Some("'CONDITIONAL'"),
    Some("'CONSTRAINT'"),
    Some("'COUNT'"),
    Some("'COPARTITION'"),
    Some("'CREATE'"),
    Some("'CROSS'"),
    Some("'CUBE'"),
    Some("'CURRENT'"),
    Some("'CURRENT_CATALOG'"),
    Some("'CURRENT_DATE'"),
    Some("'CURRENT_PATH'"),
    Some("'CURRENT_ROLE'"),
    Some("'CURRENT_SCHEMA'"),
    Some("'CURRENT_TIME'"),
    Some("'CURRENT_TIMESTAMP'"),
    Some("'CURRENT_USER'"),
    Some("'DATA'"),
    Some("'DATE'"),
    Some("'DAY'"),
    Some("'DEALLOCATE'"),
    Some("'DEFAULT'"),
    Some("'DEFINE'"),
    Some("'DEFINER'"),
    Some("'DELETE'"),
    Some("'DENY'"),
    Some("'DESC'"),
    Some("'DESCRIBE'"),
    Some("'DESCRIPTOR'"),
    Some("'DISTINCT'"),
    Some("'DISTRIBUTED'"),
    Some("'DOUBLE'"),
    Some("'DROP'"),
    Some("'ELSE'"),
    Some("'EMPTY'"),
    Some("'ENCODING'"),
    Some("'END'"),
    Some("'ERROR'"),
    Some("'ESCAPE'"),
    Some("'EXCEPT'"),
    Some("'EXCLUDING'"),
    Some("'EXECUTE'"),
    Some("'EXISTS'"),
    Some("'EXPLAIN'"),
    Some("'EXTRACT'"),
    Some("'FALSE'"),
    Some("'FETCH'"),
    Some("'FILTER'"),
    Some("'FINAL'"),
    Some("'FIRST'"),
    Some("'FOLLOWING'"),
    Some("'FOR'"),
    Some("'FORMAT'"),
    Some("'FROM'"),
    Some("'FULL'"),
    Some("'FUNCTIONS'"),
    Some("'GRACE'"),
    Some("'GRANT'"),
    Some("'GRANTED'"),
    Some("'GRANTS'"),
    Some("'GRAPHVIZ'"),
    Some("'GROUP'"),
    Some("'GROUPING'"),
    Some("'GROUPS'"),
    Some("'HAVING'"),
    Some("'HOUR'"),
    Some("'IF'"),
    Some("'IGNORE'"),
    Some("'IN'"),
    Some("'INCLUDING'"),
    Some("'INITIAL'"),
    Some("'INNER'"),
    Some("'INPUT'"),
    Some("'INSERT'"),
    Some("'INTERSECT'"),
    Some("'INTERVAL'"),
    Some("'INTO'"),
    Some("'INVOKER'"),
    Some("'IO'"),
    Some("'IS'"),
    Some("'ISOLATION'"),
    Some("'JOIN'"),
    Some("'JSON'"),
    Some("'JSON_ARRAY'"),
    Some("'JSON_EXISTS'"),
    Some("'JSON_OBJECT'"),
    Some("'JSON_QUERY'"),
    Some("'JSON_VALUE'"),
    Some("'KEEP'"),
    Some("'KEY'"),
    Some("'KEYS'"),
    Some("'LAST'"),
    Some("'LATERAL'"),
    Some("'LEADING'"),
    Some("'LEFT'"),
    Some("'LEVEL'"),
    Some("'LIKE'"),
    Some("'LIMIT'"),
    Some("'LISTAGG'"),
    Some("'LOCAL'"),
    Some("'LOCALTIME'"),
    Some("'LOCALTIMESTAMP'"),
    Some("'LOGICAL'"),
    Some("'MAP'"),
    Some("'MATCH'"),
    Some("'MATCHED'"),
    Some("'MATCHES'"),
    Some("'MATCH_RECOGNIZE'"),
    Some("'MATERIALIZED'"),
    Some("'MEASURES'"),
    Some("'MERGE'"),
    Some("'MINUTE'"),
    Some("'MONTH'"),
    Some("'NATURAL'"),
    Some("'NEXT'"),
    Some("'NFC'"),
    Some("'NFD'"),
    Some("'NFKC'"),
    Some("'NFKD'"),
    Some("'NO'"),
    Some("'NONE'"),
    Some("'NORMALIZE'"),
    Some("'NOT'"),
    Some("'NULL'"),
    Some("'NULLIF'"),
    Some("'NULLS'"),
    Some("'OBJECT'"),
    Some("'OF'"),
    Some("'OFFSET'"),
    Some("'OMIT'"),
    Some("'ON'"),
    Some("'ONE'"),
    Some("'ONLY'"),
    Some("'OPTION'"),
    Some("'OR'"),
    Some("'ORDER'"),
    Some("'ORDINALITY'"),
    Some("'OUTER'"),
    Some("'OUTPUT'"),
    Some("'OVER'"),
    Some("'OVERFLOW'"),
    Some("'PARTITION'"),
    Some("'PARTITIONS'"),
    Some("'PASSING'"),
    Some("'PAST'"),
    Some("'PATH'"),
    Some("'PATTERN'"),
    Some("'PER'"),
    Some("'PERIOD'"),
    Some("'PERMUTE'"),
    Some("'POSITION'"),
    Some("'PRECEDING'"),
    Some("'PRECISION'"),
    Some("'PREPARE'"),
    Some("'PRIVILEGES'"),
    Some("'PROPERTIES'"),
    Some("'PRUNE'"),
    Some("'QUOTES'"),
    Some("'RANGE'"),
    Some("'READ'"),
    Some("'RECURSIVE'"),
    Some("'REFRESH'"),
    Some("'RENAME'"),
    Some("'REPEATABLE'"),
    Some("'REPLACE'"),
    Some("'RESET'"),
    Some("'RESPECT'"),
    Some("'RESTRICT'"),
    Some("'RETURNING'"),
    Some("'REVOKE'"),
    Some("'RIGHT'"),
    Some("'ROLE'"),
    Some("'ROLES'"),
    Some("'ROLLBACK'"),
    Some("'ROLLUP'"),
    Some("'ROW'"),
    Some("'ROWS'"),
    Some("'RUNNING'"),
    Some("'SCALAR'"),
    Some("'SCHEMA'"),
    Some("'SCHEMAS'"),
    Some("'SECOND'"),
    Some("'SECURITY'"),
    Some("'SEEK'"),
    Some("'SELECT'"),
    Some("'SERIALIZABLE'"),
    Some("'SESSION'"),
    Some("'SET'"),
    Some("'SETS'"),
    Some("'SHOW'"),
    Some("'SOME'"),
    Some("'START'"),
    Some("'STATS'"),
    Some("'SUBSET'"),
    Some("'SUBSTRING'"),
    Some("'SYSTEM'"),
    Some("'TABLE'"),
    Some("'TABLES'"),
    Some("'TABLESAMPLE'"),
    Some("'TEXT'"),
    Some("'STRING'"),
    Some("'THEN'"),
    Some("'TIES'"),
    Some("'TIME'"),
    Some("'TIMESTAMP'"),
    Some("'TO'"),
    Some("'TRAILING'"),
    Some("'TRANSACTION'"),
    Some("'TRIM'"),
    Some("'TRUE'"),
    Some("'TRUNCATE'"),
    Some("'TRY_CAST'"),
    Some("'TYPE'"),
    Some("'UESCAPE'"),
    Some("'UNBOUNDED'"),
    Some("'UNCOMMITTED'"),
    Some("'UNCONDITIONAL'"),
    Some("'UNION'"),
    Some("'UNIQUE'"),
    Some("'UNKNOWN'"),
    Some("'UNMATCHED'"),
    Some("'UNNEST'"),
    Some("'UPDATE'"),
    Some("'USE'"),
    Some("'USER'"),
    Some("'USING'"),
    Some("'UTF16'"),
    Some("'UTF32'"),
    Some("'UTF8'"),
    Some("'VALIDATE'"),
    Some("'VALUE'"),
    Some("'VALUES'"),
    Some("'VERBOSE'"),
    Some("'VERSION'"),
    Some("'VIEW'"),
    Some("'WHEN'"),
    Some("'WHERE'"),
    Some("'WINDOW'"),
    Some("'WITH'"),
    Some("'WITHIN'"),
    Some("'WITHOUT'"),
    Some("'WORK'"),
    Some("'WRAPPER'"),
    Some("'WRITE'"),
    Some("'YEAR'"),
    Some("'ZONE'"),
    Some("'='"),
    None,
    Some("'<'"),
    Some("'<='"),
    Some("'>'"),
    Some("'>='"),
    Some("'+'"),
    Some("'-'"),
    Some("'*'"),
    Some("'/'"),
    Some("'%'"),
    Some("'||'"),
    Some("'?'"),
];
pub const _SYMBOLIC_NAMES: [Option<&'static str>; 319] = [
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    Some("ABSENT"),
    Some("ADD"),
    Some("ADMIN"),
    Some("AFTER"),
    Some("ALL"),
    Some("ALTER"),
    Some("ANALYZE"),
    Some("AND"),
    Some("ANY"),
    Some("ARRAY"),
    Some("AS"),
    Some("ASC"),
    Some("AT"),
    Some("AUTHORIZATION"),
    Some("BERNOULLI"),
    Some("BETWEEN"),
    Some("BOTH"),
    Some("BY"),
    Some("CALL"),
    Some("CASCADE"),
    Some("CASE"),
    Some("CAST"),
    Some("CATALOGS"),
    Some("COLUMN"),
    Some("COLUMNS"),
    Some("COMMA"),
    Some("COMMENT"),
    Some("COMMIT"),
    Some("COMMITTED"),
    Some("CONDITIONAL"),
    Some("CONSTRAINT"),
    Some("COUNT"),
    Some("COPARTITION"),
    Some("CREATE"),
    Some("CROSS"),
    Some("CUBE"),
    Some("CURRENT"),
    Some("CURRENT_CATALOG"),
    Some("CURRENT_DATE"),
    Some("CURRENT_PATH"),
    Some("CURRENT_ROLE"),
    Some("CURRENT_SCHEMA"),
    Some("CURRENT_TIME"),
    Some("CURRENT_TIMESTAMP"),
    Some("CURRENT_USER"),
    Some("DATA"),
    Some("DATE"),
    Some("DAY"),
    Some("DEALLOCATE"),
    Some("DEFAULT"),
    Some("DEFINE"),
    Some("DEFINER"),
    Some("DELETE"),
    Some("DENY"),
    Some("DESC"),
    Some("DESCRIBE"),
    Some("DESCRIPTOR"),
    Some("DISTINCT"),
    Some("DISTRIBUTED"),
    Some("DOUBLE"),
    Some("DROP"),
    Some("ELSE"),
    Some("EMPTY"),
    Some("ENCODING"),
    Some("END"),
    Some("ERROR"),
    Some("ESCAPE"),
    Some("EXCEPT"),
    Some("EXCLUDING"),
    Some("EXECUTE"),
    Some("EXISTS"),
    Some("EXPLAIN"),
    Some("EXTRACT"),
    Some("FALSE"),
    Some("FETCH"),
    Some("FILTER"),
    Some("FINAL"),
    Some("FIRST"),
    Some("FOLLOWING"),
    Some("FOR"),
    Some("FORMAT"),
    Some("FROM"),
    Some("FULL"),
    Some("FUNCTIONS"),
    Some("GRACE"),
    Some("GRANT"),
    Some("GRANTED"),
    Some("GRANTS"),
    Some("GRAPHVIZ"),
    Some("GROUP"),
    Some("GROUPING"),
    Some("GROUPS"),
    Some("HAVING"),
    Some("HOUR"),
    Some("IF"),
    Some("IGNORE"),
    Some("IN"),
    Some("INCLUDING"),
    Some("INITIAL"),
    Some("INNER"),
    Some("INPUT"),
    Some("INSERT"),
    Some("INTERSECT"),
    Some("INTERVAL"),
    Some("INTO"),
    Some("INVOKER"),
    Some("IO"),
    Some("IS"),
    Some("ISOLATION"),
    Some("JOIN"),
    Some("JSON"),
    Some("JSON_ARRAY"),
    Some("JSON_EXISTS"),
    Some("JSON_OBJECT"),
    Some("JSON_QUERY"),
    Some("JSON_VALUE"),
    Some("KEEP"),
    Some("KEY"),
    Some("KEYS"),
    Some("LAST"),
    Some("LATERAL"),
    Some("LEADING"),
    Some("LEFT"),
    Some("LEVEL"),
    Some("LIKE"),
    Some("LIMIT"),
    Some("LISTAGG"),
    Some("LOCAL"),
    Some("LOCALTIME"),
    Some("LOCALTIMESTAMP"),
    Some("LOGICAL"),
    Some("MAP"),
    Some("MATCH"),
    Some("MATCHED"),
    Some("MATCHES"),
    Some("MATCH_RECOGNIZE"),
    Some("MATERIALIZED"),
    Some("MEASURES"),
    Some("MERGE"),
    Some("MINUTE"),
    Some("MONTH"),
    Some("NATURAL"),
    Some("NEXT"),
    Some("NFC"),
    Some("NFD"),
    Some("NFKC"),
    Some("NFKD"),
    Some("NO"),
    Some("NONE"),
    Some("NORMALIZE"),
    Some("NOT"),
    Some("NULL"),
    Some("NULLIF"),
    Some("NULLS"),
    Some("OBJECT"),
    Some("OF"),
    Some("OFFSET"),
    Some("OMIT"),
    Some("ON"),
    Some("ONE"),
    Some("ONLY"),
    Some("OPTION"),
    Some("OR"),
    Some("ORDER"),
    Some("ORDINALITY"),
    Some("OUTER"),
    Some("OUTPUT"),
    Some("OVER"),
    Some("OVERFLOW"),
    Some("PARTITION"),
    Some("PARTITIONS"),
    Some("PASSING"),
    Some("PAST"),
    Some("PATH"),
    Some("PATTERN"),
    Some("PER"),
    Some("PERIOD"),
    Some("PERMUTE"),
    Some("POSITION"),
    Some("PRECEDING"),
    Some("PRECISION"),
    Some("PREPARE"),
    Some("PRIVILEGES"),
    Some("PROPERTIES"),
    Some("PRUNE"),
    Some("QUOTES"),
    Some("RANGE"),
    Some("READ"),
    Some("RECURSIVE"),
    Some("REFRESH"),
    Some("RENAME"),
    Some("REPEATABLE"),
    Some("REPLACE"),
    Some("RESET"),
    Some("RESPECT"),
    Some("RESTRICT"),
    Some("RETURNING"),
    Some("REVOKE"),
    Some("RIGHT"),
    Some("ROLE"),
    Some("ROLES"),
    Some("ROLLBACK"),
    Some("ROLLUP"),
    Some("ROW"),
    Some("ROWS"),
    Some("RUNNING"),
    Some("SCALAR"),
    Some("SCHEMA"),
    Some("SCHEMAS"),
    Some("SECOND"),
    Some("SECURITY"),
    Some("SEEK"),
    Some("SELECT"),
    Some("SERIALIZABLE"),
    Some("SESSION"),
    Some("SET"),
    Some("SETS"),
    Some("SHOW"),
    Some("SOME"),
    Some("START"),
    Some("STATS"),
    Some("SUBSET"),
    Some("SUBSTRING"),
    Some("SYSTEM"),
    Some("TABLE"),
    Some("TABLES"),
    Some("TABLESAMPLE"),
    Some("TEXT"),
    Some("TEXT_STRING"),
    Some("THEN"),
    Some("TIES"),
    Some("TIME"),
    Some("TIMESTAMP"),
    Some("TO"),
    Some("TRAILING"),
    Some("TRANSACTION"),
    Some("TRIM"),
    Some("TRUE"),
    Some("TRUNCATE"),
    Some("TRY_CAST"),
    Some("TYPE"),
    Some("UESCAPE"),
    Some("UNBOUNDED"),
    Some("UNCOMMITTED"),
    Some("UNCONDITIONAL"),
    Some("UNION"),
    Some("UNIQUE"),
    Some("UNKNOWN"),
    Some("UNMATCHED"),
    Some("UNNEST"),
    Some("UPDATE"),
    Some("USE"),
    Some("USER"),
    Some("USING"),
    Some("UTF16"),
    Some("UTF32"),
    Some("UTF8"),
    Some("VALIDATE"),
    Some("VALUE"),
    Some("VALUES"),
    Some("VERBOSE"),
    Some("VERSION"),
    Some("VIEW"),
    Some("WHEN"),
    Some("WHERE"),
    Some("WINDOW"),
    Some("WITH"),
    Some("WITHIN"),
    Some("WITHOUT"),
    Some("WORK"),
    Some("WRAPPER"),
    Some("WRITE"),
    Some("YEAR"),
    Some("ZONE"),
    Some("EQ"),
    Some("NEQ"),
    Some("LT"),
    Some("LTE"),
    Some("GT"),
    Some("GTE"),
    Some("PLUS"),
    Some("MINUS"),
    Some("ASTERISK"),
    Some("SLASH"),
    Some("PERCENT"),
    Some("CONCAT"),
    Some("QUESTION_MARK"),
    Some("STRING"),
    Some("UNICODE_STRING"),
    Some("BINARY_LITERAL"),
    Some("INTEGER_VALUE"),
    Some("DECIMAL_VALUE"),
    Some("DOUBLE_VALUE"),
    Some("IDENTIFIER"),
    Some("DIGIT_IDENTIFIER"),
    Some("QUOTED_IDENTIFIER"),
    Some("BACKQUOTED_IDENTIFIER"),
    Some("SIMPLE_COMMENT"),
    Some("BRACKETED_COMMENT"),
    Some("WS"),
    Some("UNRECOGNIZED"),
    Some("DELIMITER"),
];
lazy_static! {
    static ref _shared_context_cache: Arc<PredictionContextCache> =
        Arc::new(PredictionContextCache::new());
    static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(
        _LITERAL_NAMES.iter(),
        _SYMBOLIC_NAMES.iter(),
        None
    ));
}

type BaseParserType<'input, I> = BaseParser<
    'input,
    PrestoParserExt<'input>,
    I,
    PrestoParserContextType,
    dyn PrestoListener<'input> + 'input,
>;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;

pub type LocalTokenFactory<'input> =
    antlr_rust::token_factory::ArenaCommonFactory<'input>;

pub type PrestoTreeWalker<'input, 'a> =
    ParseTreeWalker<'input, 'a, PrestoParserContextType, dyn PrestoListener<'input> + 'a>;

/// Parser for Presto grammar
pub struct PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    base: BaseParserType<'input, I>,
    interpreter: Arc<ParserATNSimulator>,
    _shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn get_serialized_atn() -> &'static str {
        _serializedATN
    }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
        antlr_rust::recognizer::check_version("0", "3");
        let interpreter = Arc::new(ParserATNSimulator::new(
            _ATN.clone(),
            _decision_to_DFA.clone(),
            _shared_context_cache.clone(),
        ));
        Self {
            base: BaseParser::new_base_parser(
                input,
                Arc::clone(&interpreter),
                PrestoParserExt {
                    _pd: Default::default(),
                },
            ),
            interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

    pub fn add_error_listener(
        &mut self,
        listener: Box<
            (dyn ErrorListener<
                'input,
                BaseParser<
                    'input,
                    PrestoParserExt<'input>,
                    I,
                    PrestoParserContextType,
                    (dyn PrestoListener<'input> + 'input),
                >,
            > + 'static),
        >,
    ) {
        self.base.add_error_listener(listener)
    }

    pub fn remove_error_listeners(&mut self) {
        self.base.remove_error_listeners()
    }
}

type DynStrategy<'input, I> =
    Box<dyn ErrorStrategy<'input, BaseParserType<'input, I>> + 'input>;

impl<'input, I> PrestoParser<'input, I, DynStrategy<'input, I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self {
        Self::with_strategy(input, Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I>
    PrestoParser<'input, I, DefaultErrorStrategy<'input, PrestoParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn new(input: I) -> Self {
        Self::with_strategy(input, DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for PrestoParser
pub trait PrestoParserContext<'input>:
    for<'x> Listenable<dyn PrestoListener<'input> + 'x>
    + ParserRuleContext<
        'input,
        TF = LocalTokenFactory<'input>,
        Ctx = PrestoParserContextType,
    >
{
}

antlr_rust::coerce_from! { 'input : PrestoParserContext<'input> }

impl<'input> PrestoParserContext<'input>
    for TerminalNode<'input, PrestoParserContextType>
{
}
impl<'input> PrestoParserContext<'input> for ErrorNode<'input, PrestoParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn PrestoParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn PrestoListener<'input> + 'input }

pub struct PrestoParserContextType;
antlr_rust::tid! {PrestoParserContextType}

impl<'input> ParserNodeType<'input> for PrestoParserContextType {
    type TF = LocalTokenFactory<'input>;
    type Type = dyn PrestoParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    type Target = BaseParserType<'input, I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct PrestoParserExt<'input> {
    _pd: PhantomData<&'input str>,
}

impl<'input> PrestoParserExt<'input> {}
antlr_rust::tid! { PrestoParserExt<'a> }

impl<'input> TokenAware<'input> for PrestoParserExt<'input> {
    type TF = LocalTokenFactory<'input>;
}

impl<
        'input,
        I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    > ParserRecog<'input, BaseParserType<'input, I>> for PrestoParserExt<'input>
{
}

impl<
        'input,
        I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    > Actions<'input, BaseParserType<'input, I>> for PrestoParserExt<'input>
{
    fn get_grammar_file_name(&self) -> &str {
        "Presto.g4"
    }

    fn get_rule_names(&self) -> &[&str] {
        &ruleNames
    }

    fn get_vocabulary(&self) -> &dyn Vocabulary {
        &**VOCABULARY
    }
    fn sempred(
        _localctx: Option<&(dyn PrestoParserContext<'input> + 'input)>,
        rule_index: isize,
        pred_index: isize,
        recog: &mut BaseParserType<'input, I>,
    ) -> bool {
        match rule_index {
            18 => PrestoParser::<'input, I, _>::queryTerm_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            31 => PrestoParser::<'input, I, _>::relation_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            57 => PrestoParser::<'input, I, _>::booleanExpression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            59 => PrestoParser::<'input, I, _>::valueExpression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            60 => PrestoParser::<'input, I, _>::primaryExpression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            80 => PrestoParser::<'input, I, _>::type__sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            90 => PrestoParser::<'input, I, _>::rowPattern_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            _ => true,
        }
    }
}

impl<'input, I>
    PrestoParser<'input, I, DefaultErrorStrategy<'input, PrestoParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    fn queryTerm_sempred(
        _localctx: Option<&QueryTermContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            0 => recog.precpred(None, 2),
            1 => recog.precpred(None, 1),
            _ => true,
        }
    }
    fn relation_sempred(
        _localctx: Option<&RelationContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            2 => recog.precpred(None, 2),
            _ => true,
        }
    }
    fn booleanExpression_sempred(
        _localctx: Option<&BooleanExpressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            3 => recog.precpred(None, 2),
            4 => recog.precpred(None, 1),
            _ => true,
        }
    }
    fn valueExpression_sempred(
        _localctx: Option<&ValueExpressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            5 => recog.precpred(None, 3),
            6 => recog.precpred(None, 2),
            7 => recog.precpred(None, 1),
            8 => recog.precpred(None, 5),
            _ => true,
        }
    }
    fn primaryExpression_sempred(
        _localctx: Option<&PrimaryExpressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            9 => recog.precpred(None, 24),
            10 => recog.precpred(None, 22),
            _ => true,
        }
    }
    fn type__sempred(
        _localctx: Option<&Type_Context<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            11 => recog.precpred(None, 2),
            _ => true,
        }
    }
    fn rowPattern_sempred(
        _localctx: Option<&RowPatternContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            12 => recog.precpred(None, 2),
            13 => recog.precpred(None, 1),
            _ => true,
        }
    }
}
//------------------- singleStatement ----------------
pub type SingleStatementContextAll<'input> = SingleStatementContext<'input>;

pub type SingleStatementContext<'input> =
    BaseParserRuleContext<'input, SingleStatementContextExt<'input>>;

#[derive(Clone)]
pub struct SingleStatementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SingleStatementContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SingleStatementContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_singleStatement(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_singleStatement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for SingleStatementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_singleStatement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_singleStatement }
}
antlr_rust::tid! {SingleStatementContextExt<'a>}

impl<'input> SingleStatementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SingleStatementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            SingleStatementContextExt { ph: PhantomData },
        ))
    }
}

pub trait SingleStatementContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SingleStatementContextExt<'input>>
{
    fn statement(&self) -> Option<Rc<StatementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
}

impl<'input> SingleStatementContextAttrs<'input> for SingleStatementContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn singleStatement(
        &mut self,
    ) -> Result<Rc<SingleStatementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SingleStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 0, RULE_singleStatement);
        let mut _localctx: Rc<SingleStatementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule statement*/
                recog.base.set_state(220);
                recog.statement()?;

                recog.base.set_state(221);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- standaloneExpression ----------------
pub type StandaloneExpressionContextAll<'input> = StandaloneExpressionContext<'input>;

pub type StandaloneExpressionContext<'input> =
    BaseParserRuleContext<'input, StandaloneExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct StandaloneExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for StandaloneExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StandaloneExpressionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_standaloneExpression(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_standaloneExpression(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for StandaloneExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_standaloneExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_standaloneExpression }
}
antlr_rust::tid! {StandaloneExpressionContextExt<'a>}

impl<'input> StandaloneExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StandaloneExpressionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            StandaloneExpressionContextExt { ph: PhantomData },
        ))
    }
}

pub trait StandaloneExpressionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<StandaloneExpressionContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
}

impl<'input> StandaloneExpressionContextAttrs<'input>
    for StandaloneExpressionContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn standaloneExpression(
        &mut self,
    ) -> Result<Rc<StandaloneExpressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = StandaloneExpressionContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 2, RULE_standaloneExpression);
        let mut _localctx: Rc<StandaloneExpressionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule expression*/
                recog.base.set_state(223);
                recog.expression()?;

                recog.base.set_state(224);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- standalonePathSpecification ----------------
pub type StandalonePathSpecificationContextAll<'input> =
    StandalonePathSpecificationContext<'input>;

pub type StandalonePathSpecificationContext<'input> =
    BaseParserRuleContext<'input, StandalonePathSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct StandalonePathSpecificationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for StandalonePathSpecificationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StandalonePathSpecificationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_standalonePathSpecification(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_standalonePathSpecification(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for StandalonePathSpecificationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_standalonePathSpecification
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_standalonePathSpecification }
}
antlr_rust::tid! {StandalonePathSpecificationContextExt<'a>}

impl<'input> StandalonePathSpecificationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StandalonePathSpecificationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            StandalonePathSpecificationContextExt { ph: PhantomData },
        ))
    }
}

pub trait StandalonePathSpecificationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<StandalonePathSpecificationContextExt<'input>>
{
    fn pathSpecification(&self) -> Option<Rc<PathSpecificationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
}

impl<'input> StandalonePathSpecificationContextAttrs<'input>
    for StandalonePathSpecificationContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn standalonePathSpecification(
        &mut self,
    ) -> Result<Rc<StandalonePathSpecificationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = StandalonePathSpecificationContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 4, RULE_standalonePathSpecification);
        let mut _localctx: Rc<StandalonePathSpecificationContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule pathSpecification*/
                recog.base.set_state(226);
                recog.pathSpecification()?;

                recog.base.set_state(227);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- standaloneType ----------------
pub type StandaloneTypeContextAll<'input> = StandaloneTypeContext<'input>;

pub type StandaloneTypeContext<'input> =
    BaseParserRuleContext<'input, StandaloneTypeContextExt<'input>>;

#[derive(Clone)]
pub struct StandaloneTypeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for StandaloneTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StandaloneTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_standaloneType(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_standaloneType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for StandaloneTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_standaloneType
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_standaloneType }
}
antlr_rust::tid! {StandaloneTypeContextExt<'a>}

impl<'input> StandaloneTypeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StandaloneTypeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            StandaloneTypeContextExt { ph: PhantomData },
        ))
    }
}

pub trait StandaloneTypeContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<StandaloneTypeContextExt<'input>>
{
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
}

impl<'input> StandaloneTypeContextAttrs<'input> for StandaloneTypeContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn standaloneType(
        &mut self,
    ) -> Result<Rc<StandaloneTypeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            StandaloneTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 6, RULE_standaloneType);
        let mut _localctx: Rc<StandaloneTypeContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule type_*/
                recog.base.set_state(229);
                recog.type__rec(0)?;

                recog.base.set_state(230);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- standaloneRowPattern ----------------
pub type StandaloneRowPatternContextAll<'input> = StandaloneRowPatternContext<'input>;

pub type StandaloneRowPatternContext<'input> =
    BaseParserRuleContext<'input, StandaloneRowPatternContextExt<'input>>;

#[derive(Clone)]
pub struct StandaloneRowPatternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for StandaloneRowPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StandaloneRowPatternContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_standaloneRowPattern(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_standaloneRowPattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for StandaloneRowPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_standaloneRowPattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_standaloneRowPattern }
}
antlr_rust::tid! {StandaloneRowPatternContextExt<'a>}

impl<'input> StandaloneRowPatternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StandaloneRowPatternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            StandaloneRowPatternContextExt { ph: PhantomData },
        ))
    }
}

pub trait StandaloneRowPatternContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<StandaloneRowPatternContextExt<'input>>
{
    fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
}

impl<'input> StandaloneRowPatternContextAttrs<'input>
    for StandaloneRowPatternContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn standaloneRowPattern(
        &mut self,
    ) -> Result<Rc<StandaloneRowPatternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = StandaloneRowPatternContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 8, RULE_standaloneRowPattern);
        let mut _localctx: Rc<StandaloneRowPatternContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule rowPattern*/
                recog.base.set_state(232);
                recog.rowPattern_rec(0)?;

                recog.base.set_state(233);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- statement ----------------
#[derive(Debug)]
pub enum StatementContextAll<'input> {
    ExplainContext(ExplainContext<'input>),
    PrepareContext(PrepareContext<'input>),
    DropMaterializedViewContext(DropMaterializedViewContext<'input>),
    SetMaterializedViewPropertiesContext(SetMaterializedViewPropertiesContext<'input>),
    UseContext(UseContext<'input>),
    DeallocateContext(DeallocateContext<'input>),
    RenameTableContext(RenameTableContext<'input>),
    CommitContext(CommitContext<'input>),
    CreateRoleContext(CreateRoleContext<'input>),
    DropColumnContext(DropColumnContext<'input>),
    DropViewContext(DropViewContext<'input>),
    ShowTablesContext(ShowTablesContext<'input>),
    SetViewAuthorizationContext(SetViewAuthorizationContext<'input>),
    ShowCatalogsContext(ShowCatalogsContext<'input>),
    ShowRolesContext(ShowRolesContext<'input>),
    MergeContext(MergeContext<'input>),
    RenameColumnContext(RenameColumnContext<'input>),
    CommentColumnContext(CommentColumnContext<'input>),
    RevokeRolesContext(RevokeRolesContext<'input>),
    ShowCreateTableContext(ShowCreateTableContext<'input>),
    ShowColumnsContext(ShowColumnsContext<'input>),
    ShowRoleGrantsContext(ShowRoleGrantsContext<'input>),
    AddColumnContext(AddColumnContext<'input>),
    DenyContext(DenyContext<'input>),
    ResetSessionContext(ResetSessionContext<'input>),
    InsertIntoContext(InsertIntoContext<'input>),
    ShowSessionContext(ShowSessionContext<'input>),
    CreateSchemaContext(CreateSchemaContext<'input>),
    ExplainAnalyzeContext(ExplainAnalyzeContext<'input>),
    ExecuteContext(ExecuteContext<'input>),
    RenameSchemaContext(RenameSchemaContext<'input>),
    DropRoleContext(DropRoleContext<'input>),
    AnalyzeContext(AnalyzeContext<'input>),
    SetRoleContext(SetRoleContext<'input>),
    ShowGrantsContext(ShowGrantsContext<'input>),
    DropSchemaContext(DropSchemaContext<'input>),
    SetTableAuthorizationContext(SetTableAuthorizationContext<'input>),
    ShowCreateViewContext(ShowCreateViewContext<'input>),
    CreateTableContext(CreateTableContext<'input>),
    StartTransactionContext(StartTransactionContext<'input>),
    CreateTableAsSelectContext(CreateTableAsSelectContext<'input>),
    CommentViewContext(CommentViewContext<'input>),
    ShowStatsContext(ShowStatsContext<'input>),
    ShowCreateSchemaContext(ShowCreateSchemaContext<'input>),
    RevokeContext(RevokeContext<'input>),
    UpdateContext(UpdateContext<'input>),
    TableExecuteContext(TableExecuteContext<'input>),
    DeleteContext(DeleteContext<'input>),
    DescribeInputContext(DescribeInputContext<'input>),
    ShowStatsForQueryContext(ShowStatsForQueryContext<'input>),
    SetColumnTypeContext(SetColumnTypeContext<'input>),
    StatementDefaultContext(StatementDefaultContext<'input>),
    SetTimeZoneContext(SetTimeZoneContext<'input>),
    TruncateTableContext(TruncateTableContext<'input>),
    CreateMaterializedViewContext(CreateMaterializedViewContext<'input>),
    SetSessionContext(SetSessionContext<'input>),
    CreateViewContext(CreateViewContext<'input>),
    RenameMaterializedViewContext(RenameMaterializedViewContext<'input>),
    ShowSchemasContext(ShowSchemasContext<'input>),
    DropTableContext(DropTableContext<'input>),
    SetSchemaAuthorizationContext(SetSchemaAuthorizationContext<'input>),
    RollbackContext(RollbackContext<'input>),
    CommentTableContext(CommentTableContext<'input>),
    RenameViewContext(RenameViewContext<'input>),
    SetPathContext(SetPathContext<'input>),
    GrantRolesContext(GrantRolesContext<'input>),
    CallContext(CallContext<'input>),
    RefreshMaterializedViewContext(RefreshMaterializedViewContext<'input>),
    ShowCreateMaterializedViewContext(ShowCreateMaterializedViewContext<'input>),
    ShowFunctionsContext(ShowFunctionsContext<'input>),
    DescribeOutputContext(DescribeOutputContext<'input>),
    GrantContext(GrantContext<'input>),
    SetTablePropertiesContext(SetTablePropertiesContext<'input>),
    Error(StatementContext<'input>),
}
antlr_rust::tid! {StatementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for StatementContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for StatementContextAll<'input> {}

impl<'input> Deref for StatementContextAll<'input> {
    type Target = dyn StatementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use StatementContextAll::*;
        match self {
            ExplainContext(inner) => inner,
            PrepareContext(inner) => inner,
            DropMaterializedViewContext(inner) => inner,
            SetMaterializedViewPropertiesContext(inner) => inner,
            UseContext(inner) => inner,
            DeallocateContext(inner) => inner,
            RenameTableContext(inner) => inner,
            CommitContext(inner) => inner,
            CreateRoleContext(inner) => inner,
            DropColumnContext(inner) => inner,
            DropViewContext(inner) => inner,
            ShowTablesContext(inner) => inner,
            SetViewAuthorizationContext(inner) => inner,
            ShowCatalogsContext(inner) => inner,
            ShowRolesContext(inner) => inner,
            MergeContext(inner) => inner,
            RenameColumnContext(inner) => inner,
            CommentColumnContext(inner) => inner,
            RevokeRolesContext(inner) => inner,
            ShowCreateTableContext(inner) => inner,
            ShowColumnsContext(inner) => inner,
            ShowRoleGrantsContext(inner) => inner,
            AddColumnContext(inner) => inner,
            DenyContext(inner) => inner,
            ResetSessionContext(inner) => inner,
            InsertIntoContext(inner) => inner,
            ShowSessionContext(inner) => inner,
            CreateSchemaContext(inner) => inner,
            ExplainAnalyzeContext(inner) => inner,
            ExecuteContext(inner) => inner,
            RenameSchemaContext(inner) => inner,
            DropRoleContext(inner) => inner,
            AnalyzeContext(inner) => inner,
            SetRoleContext(inner) => inner,
            ShowGrantsContext(inner) => inner,
            DropSchemaContext(inner) => inner,
            SetTableAuthorizationContext(inner) => inner,
            ShowCreateViewContext(inner) => inner,
            CreateTableContext(inner) => inner,
            StartTransactionContext(inner) => inner,
            CreateTableAsSelectContext(inner) => inner,
            CommentViewContext(inner) => inner,
            ShowStatsContext(inner) => inner,
            ShowCreateSchemaContext(inner) => inner,
            RevokeContext(inner) => inner,
            UpdateContext(inner) => inner,
            TableExecuteContext(inner) => inner,
            DeleteContext(inner) => inner,
            DescribeInputContext(inner) => inner,
            ShowStatsForQueryContext(inner) => inner,
            SetColumnTypeContext(inner) => inner,
            StatementDefaultContext(inner) => inner,
            SetTimeZoneContext(inner) => inner,
            TruncateTableContext(inner) => inner,
            CreateMaterializedViewContext(inner) => inner,
            SetSessionContext(inner) => inner,
            CreateViewContext(inner) => inner,
            RenameMaterializedViewContext(inner) => inner,
            ShowSchemasContext(inner) => inner,
            DropTableContext(inner) => inner,
            SetSchemaAuthorizationContext(inner) => inner,
            RollbackContext(inner) => inner,
            CommentTableContext(inner) => inner,
            RenameViewContext(inner) => inner,
            SetPathContext(inner) => inner,
            GrantRolesContext(inner) => inner,
            CallContext(inner) => inner,
            RefreshMaterializedViewContext(inner) => inner,
            ShowCreateMaterializedViewContext(inner) => inner,
            ShowFunctionsContext(inner) => inner,
            DescribeOutputContext(inner) => inner,
            GrantContext(inner) => inner,
            SetTablePropertiesContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StatementContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type StatementContext<'input> =
    BaseParserRuleContext<'input, StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for StatementContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StatementContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::tid! {StatementContextExt<'a>}

impl<'input> StatementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                StatementContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait StatementContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<StatementContextExt<'input>>
{
}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input> {}

pub type ExplainContext<'input> =
    BaseParserRuleContext<'input, ExplainContextExt<'input>>;

pub trait ExplainContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token EXPLAIN
    /// Returns `None` if there is no child corresponding to token EXPLAIN
    fn EXPLAIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXPLAIN, 0)
    }
    fn statement(&self) -> Option<Rc<StatementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn explainOption_all(&self) -> Vec<Rc<ExplainOptionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn explainOption(&self, i: usize) -> Option<Rc<ExplainOptionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> ExplainContextAttrs<'input> for ExplainContext<'input> {}

pub struct ExplainContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExplainContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExplainContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for ExplainContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_explain(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExplainContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ExplainContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ExplainContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ExplainContext<'input> {}

impl<'input> ExplainContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ExplainContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExplainContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PrepareContext<'input> =
    BaseParserRuleContext<'input, PrepareContextExt<'input>>;

pub trait PrepareContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PREPARE
    /// Returns `None` if there is no child corresponding to token PREPARE
    fn PREPARE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PREPARE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn statement(&self) -> Option<Rc<StatementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> PrepareContextAttrs<'input> for PrepareContext<'input> {}

pub struct PrepareContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PrepareContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PrepareContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for PrepareContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_prepare(self);
    }
}

impl<'input> CustomRuleContext<'input> for PrepareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for PrepareContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for PrepareContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for PrepareContext<'input> {}

impl<'input> PrepareContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::PrepareContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PrepareContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DropMaterializedViewContext<'input> =
    BaseParserRuleContext<'input, DropMaterializedViewContextExt<'input>>;

pub trait DropMaterializedViewContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DROP
    /// Returns `None` if there is no child corresponding to token DROP
    fn DROP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DROP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATERIALIZED
    /// Returns `None` if there is no child corresponding to token MATERIALIZED
    fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATERIALIZED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
}

impl<'input> DropMaterializedViewContextAttrs<'input>
    for DropMaterializedViewContext<'input>
{
}

pub struct DropMaterializedViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DropMaterializedViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DropMaterializedViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DropMaterializedViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dropMaterializedView(self);
    }
}

impl<'input> CustomRuleContext<'input> for DropMaterializedViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropMaterializedViewContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for DropMaterializedViewContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DropMaterializedViewContext<'input> {}

impl<'input> DropMaterializedViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DropMaterializedViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DropMaterializedViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetMaterializedViewPropertiesContext<'input> =
    BaseParserRuleContext<'input, SetMaterializedViewPropertiesContextExt<'input>>;

pub trait SetMaterializedViewPropertiesContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATERIALIZED
    /// Returns `None` if there is no child corresponding to token MATERIALIZED
    fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATERIALIZED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PROPERTIES
    /// Returns `None` if there is no child corresponding to token PROPERTIES
    fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PROPERTIES, 0)
    }
    fn propertyAssignments(&self) -> Option<Rc<PropertyAssignmentsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetMaterializedViewPropertiesContextAttrs<'input>
    for SetMaterializedViewPropertiesContext<'input>
{
}

pub struct SetMaterializedViewPropertiesContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetMaterializedViewPropertiesContextExt<'a>}

impl<'input> PrestoParserContext<'input>
    for SetMaterializedViewPropertiesContext<'input>
{
}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetMaterializedViewPropertiesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setMaterializedViewProperties(self);
    }
}

impl<'input> CustomRuleContext<'input>
    for SetMaterializedViewPropertiesContextExt<'input>
{
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>>
    for SetMaterializedViewPropertiesContext<'input>
{
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for SetMaterializedViewPropertiesContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input>
    for SetMaterializedViewPropertiesContext<'input>
{
}

impl<'input> SetMaterializedViewPropertiesContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetMaterializedViewPropertiesContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetMaterializedViewPropertiesContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type UseContext<'input> = BaseParserRuleContext<'input, UseContextExt<'input>>;

pub trait UseContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token USE
    /// Returns `None` if there is no child corresponding to token USE
    fn USE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(USE, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> UseContextAttrs<'input> for UseContext<'input> {}

pub struct UseContextExt<'input> {
    base: StatementContextExt<'input>,
    pub schema: Option<Rc<IdentifierContextAll<'input>>>,
    pub catalog: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UseContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UseContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for UseContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_use(self);
    }
}

impl<'input> CustomRuleContext<'input> for UseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for UseContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for UseContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for UseContext<'input> {}

impl<'input> UseContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::UseContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UseContextExt {
                    schema: None,
                    catalog: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DeallocateContext<'input> =
    BaseParserRuleContext<'input, DeallocateContextExt<'input>>;

pub trait DeallocateContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DEALLOCATE
    /// Returns `None` if there is no child corresponding to token DEALLOCATE
    fn DEALLOCATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEALLOCATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PREPARE
    /// Returns `None` if there is no child corresponding to token PREPARE
    fn PREPARE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PREPARE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> DeallocateContextAttrs<'input> for DeallocateContext<'input> {}

pub struct DeallocateContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DeallocateContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DeallocateContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DeallocateContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_deallocate(self);
    }
}

impl<'input> CustomRuleContext<'input> for DeallocateContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DeallocateContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DeallocateContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DeallocateContext<'input> {}

impl<'input> DeallocateContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DeallocateContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DeallocateContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RenameTableContext<'input> =
    BaseParserRuleContext<'input, RenameTableContextExt<'input>>;

pub trait RenameTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RENAME
    /// Returns `None` if there is no child corresponding to token RENAME
    fn RENAME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RENAME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn qualifiedName_all(&self) -> Vec<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
}

impl<'input> RenameTableContextAttrs<'input> for RenameTableContext<'input> {}

pub struct RenameTableContextExt<'input> {
    base: StatementContextExt<'input>,
    pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub to: Option<Rc<QualifiedNameContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RenameTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RenameTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RenameTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_renameTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for RenameTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameTableContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameTableContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RenameTableContext<'input> {}

impl<'input> RenameTableContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RenameTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RenameTableContextExt {
                    from: None,
                    to: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CommitContext<'input> = BaseParserRuleContext<'input, CommitContextExt<'input>>;

pub trait CommitContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token COMMIT
    /// Returns `None` if there is no child corresponding to token COMMIT
    fn COMMIT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMIT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WORK
    /// Returns `None` if there is no child corresponding to token WORK
    fn WORK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WORK, 0)
    }
}

impl<'input> CommitContextAttrs<'input> for CommitContext<'input> {}

pub struct CommitContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CommitContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CommitContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for CommitContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_commit(self);
    }
}

impl<'input> CustomRuleContext<'input> for CommitContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CommitContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CommitContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CommitContext<'input> {}

impl<'input> CommitContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CommitContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CommitContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CreateRoleContext<'input> =
    BaseParserRuleContext<'input, CreateRoleContextExt<'input>>;

pub trait CreateRoleContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLE
    /// Returns `None` if there is no child corresponding to token ROLE
    fn ROLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLE, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ADMIN
    /// Returns `None` if there is no child corresponding to token ADMIN
    fn ADMIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ADMIN, 0)
    }
    fn grantor(&self) -> Option<Rc<GrantorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
}

impl<'input> CreateRoleContextAttrs<'input> for CreateRoleContext<'input> {}

pub struct CreateRoleContextExt<'input> {
    base: StatementContextExt<'input>,
    pub name: Option<Rc<IdentifierContextAll<'input>>>,
    pub catalog: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CreateRoleContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CreateRoleContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CreateRoleContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_createRole(self);
    }
}

impl<'input> CustomRuleContext<'input> for CreateRoleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateRoleContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateRoleContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CreateRoleContext<'input> {}

impl<'input> CreateRoleContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CreateRoleContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CreateRoleContextExt {
                    name: None,
                    catalog: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DropColumnContext<'input> =
    BaseParserRuleContext<'input, DropColumnContextExt<'input>>;

pub trait DropColumnContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DROP
    /// Returns `None` if there is no child corresponding to token DROP
    fn DROP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DROP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMN
    /// Returns `None` if there is no child corresponding to token COLUMN
    fn COLUMN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMN, 0)
    }
    fn qualifiedName_all(&self) -> Vec<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token IF in current rule
    fn IF_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
    /// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
    fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
    fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
    /// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
    fn EXISTS(
        &self,
        i: usize,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, i)
    }
}

impl<'input> DropColumnContextAttrs<'input> for DropColumnContext<'input> {}

pub struct DropColumnContextExt<'input> {
    base: StatementContextExt<'input>,
    pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub column: Option<Rc<QualifiedNameContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DropColumnContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DropColumnContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DropColumnContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dropColumn(self);
    }
}

impl<'input> CustomRuleContext<'input> for DropColumnContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropColumnContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropColumnContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DropColumnContext<'input> {}

impl<'input> DropColumnContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DropColumnContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DropColumnContextExt {
                    tableName: None,
                    column: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DropViewContext<'input> =
    BaseParserRuleContext<'input, DropViewContextExt<'input>>;

pub trait DropViewContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DROP
    /// Returns `None` if there is no child corresponding to token DROP
    fn DROP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DROP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
}

impl<'input> DropViewContextAttrs<'input> for DropViewContext<'input> {}

pub struct DropViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DropViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DropViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for DropViewContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dropView(self);
    }
}

impl<'input> CustomRuleContext<'input> for DropViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropViewContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropViewContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DropViewContext<'input> {}

impl<'input> DropViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DropViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DropViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowTablesContext<'input> =
    BaseParserRuleContext<'input, ShowTablesContextExt<'input>>;

pub trait ShowTablesContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLES
    /// Returns `None` if there is no child corresponding to token TABLES
    fn TABLES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLES, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
    fn string_all(&self) -> Vec<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ESCAPE
    /// Returns `None` if there is no child corresponding to token ESCAPE
    fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ESCAPE, 0)
    }
}

impl<'input> ShowTablesContextAttrs<'input> for ShowTablesContext<'input> {}

pub struct ShowTablesContextExt<'input> {
    base: StatementContextExt<'input>,
    pub pattern: Option<Rc<StringContextAll<'input>>>,
    pub escape: Option<Rc<StringContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowTablesContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowTablesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowTablesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showTables(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowTablesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowTablesContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowTablesContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowTablesContext<'input> {}

impl<'input> ShowTablesContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowTablesContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowTablesContextExt {
                    pattern: None,
                    escape: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetViewAuthorizationContext<'input> =
    BaseParserRuleContext<'input, SetViewAuthorizationContextExt<'input>>;

pub trait SetViewAuthorizationContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AUTHORIZATION
    /// Returns `None` if there is no child corresponding to token AUTHORIZATION
    fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AUTHORIZATION, 0)
    }
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetViewAuthorizationContextAttrs<'input>
    for SetViewAuthorizationContext<'input>
{
}

pub struct SetViewAuthorizationContextExt<'input> {
    base: StatementContextExt<'input>,
    pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetViewAuthorizationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetViewAuthorizationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetViewAuthorizationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setViewAuthorization(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetViewAuthorizationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetViewAuthorizationContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for SetViewAuthorizationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetViewAuthorizationContext<'input> {}

impl<'input> SetViewAuthorizationContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetViewAuthorizationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetViewAuthorizationContextExt {
                    from: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowCatalogsContext<'input> =
    BaseParserRuleContext<'input, ShowCatalogsContextExt<'input>>;

pub trait ShowCatalogsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CATALOGS
    /// Returns `None` if there is no child corresponding to token CATALOGS
    fn CATALOGS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CATALOGS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    fn string_all(&self) -> Vec<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ESCAPE
    /// Returns `None` if there is no child corresponding to token ESCAPE
    fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ESCAPE, 0)
    }
}

impl<'input> ShowCatalogsContextAttrs<'input> for ShowCatalogsContext<'input> {}

pub struct ShowCatalogsContextExt<'input> {
    base: StatementContextExt<'input>,
    pub pattern: Option<Rc<StringContextAll<'input>>>,
    pub escape: Option<Rc<StringContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowCatalogsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowCatalogsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowCatalogsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showCatalogs(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowCatalogsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowCatalogsContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowCatalogsContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowCatalogsContext<'input> {}

impl<'input> ShowCatalogsContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowCatalogsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowCatalogsContextExt {
                    pattern: None,
                    escape: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowRolesContext<'input> =
    BaseParserRuleContext<'input, ShowRolesContextExt<'input>>;

pub trait ShowRolesContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLES
    /// Returns `None` if there is no child corresponding to token ROLES
    fn ROLES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CURRENT
    /// Returns `None` if there is no child corresponding to token CURRENT
    fn CURRENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
}

impl<'input> ShowRolesContextAttrs<'input> for ShowRolesContext<'input> {}

pub struct ShowRolesContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowRolesContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowRolesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowRolesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showRoles(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowRolesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowRolesContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowRolesContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowRolesContext<'input> {}

impl<'input> ShowRolesContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowRolesContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowRolesContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type MergeContext<'input> = BaseParserRuleContext<'input, MergeContextExt<'input>>;

pub trait MergeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token MERGE
    /// Returns `None` if there is no child corresponding to token MERGE
    fn MERGE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MERGE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTO
    /// Returns `None` if there is no child corresponding to token INTO
    fn INTO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTO, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token USING
    /// Returns `None` if there is no child corresponding to token USING
    fn USING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(USING, 0)
    }
    fn relation(&self) -> Option<Rc<RelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn mergeCase_all(&self) -> Vec<Rc<MergeCaseContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn mergeCase(&self, i: usize) -> Option<Rc<MergeCaseContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
}

impl<'input> MergeContextAttrs<'input> for MergeContext<'input> {}

pub struct MergeContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MergeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for MergeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for MergeContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_merge(self);
    }
}

impl<'input> CustomRuleContext<'input> for MergeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for MergeContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for MergeContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for MergeContext<'input> {}

impl<'input> MergeContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::MergeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                MergeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RenameColumnContext<'input> =
    BaseParserRuleContext<'input, RenameColumnContextExt<'input>>;

pub trait RenameColumnContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RENAME
    /// Returns `None` if there is no child corresponding to token RENAME
    fn RENAME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RENAME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMN
    /// Returns `None` if there is no child corresponding to token COLUMN
    fn COLUMN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token IF in current rule
    fn IF_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
    /// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
    fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
    fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
    /// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
    fn EXISTS(
        &self,
        i: usize,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, i)
    }
}

impl<'input> RenameColumnContextAttrs<'input> for RenameColumnContext<'input> {}

pub struct RenameColumnContextExt<'input> {
    base: StatementContextExt<'input>,
    pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub from: Option<Rc<IdentifierContextAll<'input>>>,
    pub to: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RenameColumnContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RenameColumnContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RenameColumnContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_renameColumn(self);
    }
}

impl<'input> CustomRuleContext<'input> for RenameColumnContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameColumnContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameColumnContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RenameColumnContext<'input> {}

impl<'input> RenameColumnContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RenameColumnContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RenameColumnContextExt {
                    tableName: None,
                    from: None,
                    to: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CommentColumnContext<'input> =
    BaseParserRuleContext<'input, CommentColumnContextExt<'input>>;

pub trait CommentColumnContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMN
    /// Returns `None` if there is no child corresponding to token COLUMN
    fn COLUMN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMN, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IS
    /// Returns `None` if there is no child corresponding to token IS
    fn IS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IS, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
}

impl<'input> CommentColumnContextAttrs<'input> for CommentColumnContext<'input> {}

pub struct CommentColumnContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CommentColumnContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CommentColumnContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CommentColumnContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_commentColumn(self);
    }
}

impl<'input> CustomRuleContext<'input> for CommentColumnContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CommentColumnContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CommentColumnContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CommentColumnContext<'input> {}

impl<'input> CommentColumnContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CommentColumnContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CommentColumnContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RevokeRolesContext<'input> =
    BaseParserRuleContext<'input, RevokeRolesContextExt<'input>>;

pub trait RevokeRolesContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token REVOKE
    /// Returns `None` if there is no child corresponding to token REVOKE
    fn REVOKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REVOKE, 0)
    }
    fn roles(&self) -> Option<Rc<RolesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn principal_all(&self) -> Vec<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn principal(&self, i: usize) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ADMIN
    /// Returns `None` if there is no child corresponding to token ADMIN
    fn ADMIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ADMIN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OPTION
    /// Returns `None` if there is no child corresponding to token OPTION
    fn OPTION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OPTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOR
    /// Returns `None` if there is no child corresponding to token FOR
    fn FOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOR, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GRANTED
    /// Returns `None` if there is no child corresponding to token GRANTED
    fn GRANTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANTED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BY
    /// Returns `None` if there is no child corresponding to token BY
    fn BY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, 0)
    }
    fn grantor(&self) -> Option<Rc<GrantorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> RevokeRolesContextAttrs<'input> for RevokeRolesContext<'input> {}

pub struct RevokeRolesContextExt<'input> {
    base: StatementContextExt<'input>,
    pub catalog: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RevokeRolesContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RevokeRolesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RevokeRolesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_revokeRoles(self);
    }
}

impl<'input> CustomRuleContext<'input> for RevokeRolesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RevokeRolesContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RevokeRolesContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RevokeRolesContext<'input> {}

impl<'input> RevokeRolesContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RevokeRolesContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RevokeRolesContextExt {
                    catalog: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowCreateTableContext<'input> =
    BaseParserRuleContext<'input, ShowCreateTableContextExt<'input>>;

pub trait ShowCreateTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ShowCreateTableContextAttrs<'input> for ShowCreateTableContext<'input> {}

pub struct ShowCreateTableContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowCreateTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowCreateTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowCreateTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showCreateTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowCreateTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowCreateTableContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowCreateTableContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowCreateTableContext<'input> {}

impl<'input> ShowCreateTableContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowCreateTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowCreateTableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowColumnsContext<'input> =
    BaseParserRuleContext<'input, ShowColumnsContextExt<'input>>;

pub trait ShowColumnsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMNS
    /// Returns `None` if there is no child corresponding to token COLUMNS
    fn COLUMNS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMNS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    fn string_all(&self) -> Vec<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ESCAPE
    /// Returns `None` if there is no child corresponding to token ESCAPE
    fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ESCAPE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DESCRIBE
    /// Returns `None` if there is no child corresponding to token DESCRIBE
    fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESCRIBE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DESC
    /// Returns `None` if there is no child corresponding to token DESC
    fn DESC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESC, 0)
    }
}

impl<'input> ShowColumnsContextAttrs<'input> for ShowColumnsContext<'input> {}

pub struct ShowColumnsContextExt<'input> {
    base: StatementContextExt<'input>,
    pub pattern: Option<Rc<StringContextAll<'input>>>,
    pub escape: Option<Rc<StringContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowColumnsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowColumnsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowColumnsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showColumns(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowColumnsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowColumnsContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowColumnsContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowColumnsContext<'input> {}

impl<'input> ShowColumnsContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowColumnsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowColumnsContextExt {
                    pattern: None,
                    escape: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowRoleGrantsContext<'input> =
    BaseParserRuleContext<'input, ShowRoleGrantsContextExt<'input>>;

pub trait ShowRoleGrantsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLE
    /// Returns `None` if there is no child corresponding to token ROLE
    fn ROLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRANTS
    /// Returns `None` if there is no child corresponding to token GRANTS
    fn GRANTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANTS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
}

impl<'input> ShowRoleGrantsContextAttrs<'input> for ShowRoleGrantsContext<'input> {}

pub struct ShowRoleGrantsContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowRoleGrantsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowRoleGrantsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowRoleGrantsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showRoleGrants(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowRoleGrantsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowRoleGrantsContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowRoleGrantsContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowRoleGrantsContext<'input> {}

impl<'input> ShowRoleGrantsContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowRoleGrantsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowRoleGrantsContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type AddColumnContext<'input> =
    BaseParserRuleContext<'input, AddColumnContextExt<'input>>;

pub trait AddColumnContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ADD
    /// Returns `None` if there is no child corresponding to token ADD
    fn ADD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMN
    /// Returns `None` if there is no child corresponding to token COLUMN
    fn COLUMN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMN, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn columnDefinition(&self) -> Option<Rc<ColumnDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token IF in current rule
    fn IF_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
    /// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
    fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
    fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
    /// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
    fn EXISTS(
        &self,
        i: usize,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, i)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
}

impl<'input> AddColumnContextAttrs<'input> for AddColumnContext<'input> {}

pub struct AddColumnContextExt<'input> {
    base: StatementContextExt<'input>,
    pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub column: Option<Rc<ColumnDefinitionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AddColumnContextExt<'a>}

impl<'input> PrestoParserContext<'input> for AddColumnContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for AddColumnContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_addColumn(self);
    }
}

impl<'input> CustomRuleContext<'input> for AddColumnContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for AddColumnContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for AddColumnContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for AddColumnContext<'input> {}

impl<'input> AddColumnContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::AddColumnContext(
            BaseParserRuleContext::copy_from(
                ctx,
                AddColumnContextExt {
                    tableName: None,
                    column: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DenyContext<'input> = BaseParserRuleContext<'input, DenyContextExt<'input>>;

pub trait DenyContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DENY
    /// Returns `None` if there is no child corresponding to token DENY
    fn DENY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DENY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn privilege_all(&self) -> Vec<Rc<PrivilegeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn privilege(&self, i: usize) -> Option<Rc<PrivilegeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRIVILEGES
    /// Returns `None` if there is no child corresponding to token PRIVILEGES
    fn PRIVILEGES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRIVILEGES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> DenyContextAttrs<'input> for DenyContext<'input> {}

pub struct DenyContextExt<'input> {
    base: StatementContextExt<'input>,
    pub grantee: Option<Rc<PrincipalContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DenyContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DenyContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for DenyContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_deny(self);
    }
}

impl<'input> CustomRuleContext<'input> for DenyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DenyContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DenyContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DenyContext<'input> {}

impl<'input> DenyContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DenyContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DenyContextExt {
                    grantee: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ResetSessionContext<'input> =
    BaseParserRuleContext<'input, ResetSessionContextExt<'input>>;

pub trait ResetSessionContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token RESET
    /// Returns `None` if there is no child corresponding to token RESET
    fn RESET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SESSION
    /// Returns `None` if there is no child corresponding to token SESSION
    fn SESSION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SESSION, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ResetSessionContextAttrs<'input> for ResetSessionContext<'input> {}

pub struct ResetSessionContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ResetSessionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ResetSessionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ResetSessionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_resetSession(self);
    }
}

impl<'input> CustomRuleContext<'input> for ResetSessionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ResetSessionContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ResetSessionContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ResetSessionContext<'input> {}

impl<'input> ResetSessionContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ResetSessionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ResetSessionContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type InsertIntoContext<'input> =
    BaseParserRuleContext<'input, InsertIntoContextExt<'input>>;

pub trait InsertIntoContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token INSERT
    /// Returns `None` if there is no child corresponding to token INSERT
    fn INSERT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INSERT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTO
    /// Returns `None` if there is no child corresponding to token INTO
    fn INTO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTO, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> InsertIntoContextAttrs<'input> for InsertIntoContext<'input> {}

pub struct InsertIntoContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {InsertIntoContextExt<'a>}

impl<'input> PrestoParserContext<'input> for InsertIntoContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for InsertIntoContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_insertInto(self);
    }
}

impl<'input> CustomRuleContext<'input> for InsertIntoContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for InsertIntoContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for InsertIntoContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for InsertIntoContext<'input> {}

impl<'input> InsertIntoContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::InsertIntoContext(
            BaseParserRuleContext::copy_from(
                ctx,
                InsertIntoContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowSessionContext<'input> =
    BaseParserRuleContext<'input, ShowSessionContextExt<'input>>;

pub trait ShowSessionContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SESSION
    /// Returns `None` if there is no child corresponding to token SESSION
    fn SESSION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SESSION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    fn string_all(&self) -> Vec<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ESCAPE
    /// Returns `None` if there is no child corresponding to token ESCAPE
    fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ESCAPE, 0)
    }
}

impl<'input> ShowSessionContextAttrs<'input> for ShowSessionContext<'input> {}

pub struct ShowSessionContextExt<'input> {
    base: StatementContextExt<'input>,
    pub pattern: Option<Rc<StringContextAll<'input>>>,
    pub escape: Option<Rc<StringContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowSessionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowSessionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowSessionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showSession(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowSessionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowSessionContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowSessionContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowSessionContext<'input> {}

impl<'input> ShowSessionContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowSessionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowSessionContextExt {
                    pattern: None,
                    escape: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CreateSchemaContext<'input> =
    BaseParserRuleContext<'input, CreateSchemaContextExt<'input>>;

pub trait CreateSchemaContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AUTHORIZATION
    /// Returns `None` if there is no child corresponding to token AUTHORIZATION
    fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AUTHORIZATION, 0)
    }
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CreateSchemaContextAttrs<'input> for CreateSchemaContext<'input> {}

pub struct CreateSchemaContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CreateSchemaContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CreateSchemaContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CreateSchemaContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_createSchema(self);
    }
}

impl<'input> CustomRuleContext<'input> for CreateSchemaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateSchemaContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateSchemaContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CreateSchemaContext<'input> {}

impl<'input> CreateSchemaContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CreateSchemaContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CreateSchemaContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ExplainAnalyzeContext<'input> =
    BaseParserRuleContext<'input, ExplainAnalyzeContextExt<'input>>;

pub trait ExplainAnalyzeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token EXPLAIN
    /// Returns `None` if there is no child corresponding to token EXPLAIN
    fn EXPLAIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXPLAIN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ANALYZE
    /// Returns `None` if there is no child corresponding to token ANALYZE
    fn ANALYZE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ANALYZE, 0)
    }
    fn statement(&self) -> Option<Rc<StatementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token VERBOSE
    /// Returns `None` if there is no child corresponding to token VERBOSE
    fn VERBOSE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VERBOSE, 0)
    }
}

impl<'input> ExplainAnalyzeContextAttrs<'input> for ExplainAnalyzeContext<'input> {}

pub struct ExplainAnalyzeContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExplainAnalyzeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExplainAnalyzeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ExplainAnalyzeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_explainAnalyze(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExplainAnalyzeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ExplainAnalyzeContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ExplainAnalyzeContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ExplainAnalyzeContext<'input> {}

impl<'input> ExplainAnalyzeContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ExplainAnalyzeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExplainAnalyzeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ExecuteContext<'input> =
    BaseParserRuleContext<'input, ExecuteContextExt<'input>>;

pub trait ExecuteContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token EXECUTE
    /// Returns `None` if there is no child corresponding to token EXECUTE
    fn EXECUTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXECUTE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token USING
    /// Returns `None` if there is no child corresponding to token USING
    fn USING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(USING, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> ExecuteContextAttrs<'input> for ExecuteContext<'input> {}

pub struct ExecuteContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExecuteContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExecuteContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for ExecuteContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_execute(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExecuteContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ExecuteContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ExecuteContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ExecuteContext<'input> {}

impl<'input> ExecuteContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ExecuteContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExecuteContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RenameSchemaContext<'input> =
    BaseParserRuleContext<'input, RenameSchemaContextExt<'input>>;

pub trait RenameSchemaContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token RENAME
    /// Returns `None` if there is no child corresponding to token RENAME
    fn RENAME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RENAME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> RenameSchemaContextAttrs<'input> for RenameSchemaContext<'input> {}

pub struct RenameSchemaContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RenameSchemaContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RenameSchemaContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RenameSchemaContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_renameSchema(self);
    }
}

impl<'input> CustomRuleContext<'input> for RenameSchemaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameSchemaContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameSchemaContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RenameSchemaContext<'input> {}

impl<'input> RenameSchemaContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RenameSchemaContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RenameSchemaContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DropRoleContext<'input> =
    BaseParserRuleContext<'input, DropRoleContextExt<'input>>;

pub trait DropRoleContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DROP
    /// Returns `None` if there is no child corresponding to token DROP
    fn DROP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DROP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLE
    /// Returns `None` if there is no child corresponding to token ROLE
    fn ROLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLE, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
}

impl<'input> DropRoleContextAttrs<'input> for DropRoleContext<'input> {}

pub struct DropRoleContextExt<'input> {
    base: StatementContextExt<'input>,
    pub name: Option<Rc<IdentifierContextAll<'input>>>,
    pub catalog: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DropRoleContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DropRoleContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for DropRoleContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dropRole(self);
    }
}

impl<'input> CustomRuleContext<'input> for DropRoleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropRoleContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropRoleContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DropRoleContext<'input> {}

impl<'input> DropRoleContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DropRoleContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DropRoleContextExt {
                    name: None,
                    catalog: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type AnalyzeContext<'input> =
    BaseParserRuleContext<'input, AnalyzeContextExt<'input>>;

pub trait AnalyzeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ANALYZE
    /// Returns `None` if there is no child corresponding to token ANALYZE
    fn ANALYZE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ANALYZE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AnalyzeContextAttrs<'input> for AnalyzeContext<'input> {}

pub struct AnalyzeContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AnalyzeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for AnalyzeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for AnalyzeContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_analyze(self);
    }
}

impl<'input> CustomRuleContext<'input> for AnalyzeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for AnalyzeContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for AnalyzeContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for AnalyzeContext<'input> {}

impl<'input> AnalyzeContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::AnalyzeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                AnalyzeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetRoleContext<'input> =
    BaseParserRuleContext<'input, SetRoleContextExt<'input>>;

pub trait SetRoleContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLE
    /// Returns `None` if there is no child corresponding to token ROLE
    fn ROLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NONE
    /// Returns `None` if there is no child corresponding to token NONE
    fn NONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NONE, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
}

impl<'input> SetRoleContextAttrs<'input> for SetRoleContext<'input> {}

pub struct SetRoleContextExt<'input> {
    base: StatementContextExt<'input>,
    pub role: Option<Rc<IdentifierContextAll<'input>>>,
    pub catalog: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetRoleContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetRoleContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for SetRoleContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setRole(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetRoleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetRoleContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetRoleContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetRoleContext<'input> {}

impl<'input> SetRoleContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetRoleContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetRoleContextExt {
                    role: None,
                    catalog: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowGrantsContext<'input> =
    BaseParserRuleContext<'input, ShowGrantsContextExt<'input>>;

pub trait ShowGrantsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRANTS
    /// Returns `None` if there is no child corresponding to token GRANTS
    fn GRANTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANTS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
}

impl<'input> ShowGrantsContextAttrs<'input> for ShowGrantsContext<'input> {}

pub struct ShowGrantsContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowGrantsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowGrantsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowGrantsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showGrants(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowGrantsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowGrantsContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowGrantsContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowGrantsContext<'input> {}

impl<'input> ShowGrantsContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowGrantsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowGrantsContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DropSchemaContext<'input> =
    BaseParserRuleContext<'input, DropSchemaContextExt<'input>>;

pub trait DropSchemaContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DROP
    /// Returns `None` if there is no child corresponding to token DROP
    fn DROP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DROP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CASCADE
    /// Returns `None` if there is no child corresponding to token CASCADE
    fn CASCADE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CASCADE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESTRICT
    /// Returns `None` if there is no child corresponding to token RESTRICT
    fn RESTRICT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESTRICT, 0)
    }
}

impl<'input> DropSchemaContextAttrs<'input> for DropSchemaContext<'input> {}

pub struct DropSchemaContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DropSchemaContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DropSchemaContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DropSchemaContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dropSchema(self);
    }
}

impl<'input> CustomRuleContext<'input> for DropSchemaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropSchemaContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropSchemaContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DropSchemaContext<'input> {}

impl<'input> DropSchemaContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DropSchemaContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DropSchemaContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetTableAuthorizationContext<'input> =
    BaseParserRuleContext<'input, SetTableAuthorizationContextExt<'input>>;

pub trait SetTableAuthorizationContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AUTHORIZATION
    /// Returns `None` if there is no child corresponding to token AUTHORIZATION
    fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AUTHORIZATION, 0)
    }
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetTableAuthorizationContextAttrs<'input>
    for SetTableAuthorizationContext<'input>
{
}

pub struct SetTableAuthorizationContextExt<'input> {
    base: StatementContextExt<'input>,
    pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetTableAuthorizationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetTableAuthorizationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetTableAuthorizationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setTableAuthorization(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetTableAuthorizationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>>
    for SetTableAuthorizationContext<'input>
{
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for SetTableAuthorizationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetTableAuthorizationContext<'input> {}

impl<'input> SetTableAuthorizationContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetTableAuthorizationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetTableAuthorizationContextExt {
                    tableName: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowCreateViewContext<'input> =
    BaseParserRuleContext<'input, ShowCreateViewContextExt<'input>>;

pub trait ShowCreateViewContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ShowCreateViewContextAttrs<'input> for ShowCreateViewContext<'input> {}

pub struct ShowCreateViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowCreateViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowCreateViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowCreateViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showCreateView(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowCreateViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowCreateViewContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowCreateViewContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowCreateViewContext<'input> {}

impl<'input> ShowCreateViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowCreateViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowCreateViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CreateTableContext<'input> =
    BaseParserRuleContext<'input, CreateTableContextExt<'input>>;

pub trait CreateTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
    fn tableElement_all(&self) -> Vec<Rc<TableElementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tableElement(&self, i: usize) -> Option<Rc<TableElementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> CreateTableContextAttrs<'input> for CreateTableContext<'input> {}

pub struct CreateTableContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CreateTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CreateTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CreateTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_createTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for CreateTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateTableContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateTableContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CreateTableContext<'input> {}

impl<'input> CreateTableContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CreateTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CreateTableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type StartTransactionContext<'input> =
    BaseParserRuleContext<'input, StartTransactionContextExt<'input>>;

pub trait StartTransactionContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token START
    /// Returns `None` if there is no child corresponding to token START
    fn START(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(START, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TRANSACTION
    /// Returns `None` if there is no child corresponding to token TRANSACTION
    fn TRANSACTION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRANSACTION, 0)
    }
    fn transactionMode_all(&self) -> Vec<Rc<TransactionModeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn transactionMode(&self, i: usize) -> Option<Rc<TransactionModeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> StartTransactionContextAttrs<'input> for StartTransactionContext<'input> {}

pub struct StartTransactionContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {StartTransactionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for StartTransactionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StartTransactionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_startTransaction(self);
    }
}

impl<'input> CustomRuleContext<'input> for StartTransactionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for StartTransactionContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for StartTransactionContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for StartTransactionContext<'input> {}

impl<'input> StartTransactionContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::StartTransactionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                StartTransactionContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CreateTableAsSelectContext<'input> =
    BaseParserRuleContext<'input, CreateTableAsSelectContextExt<'input>>;

pub trait CreateTableAsSelectContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token WITH in current rule
    fn WITH_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token WITH, starting from 0.
    /// Returns `None` if number of children corresponding to token WITH is less or equal than `i`.
    fn WITH(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, i)
    }
    fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token DATA
    /// Returns `None` if there is no child corresponding to token DATA
    fn DATA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DATA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NO
    /// Returns `None` if there is no child corresponding to token NO
    fn NO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NO, 0)
    }
}

impl<'input> CreateTableAsSelectContextAttrs<'input>
    for CreateTableAsSelectContext<'input>
{
}

pub struct CreateTableAsSelectContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CreateTableAsSelectContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CreateTableAsSelectContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CreateTableAsSelectContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_createTableAsSelect(self);
    }
}

impl<'input> CustomRuleContext<'input> for CreateTableAsSelectContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateTableAsSelectContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for CreateTableAsSelectContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CreateTableAsSelectContext<'input> {}

impl<'input> CreateTableAsSelectContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CreateTableAsSelectContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CreateTableAsSelectContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CommentViewContext<'input> =
    BaseParserRuleContext<'input, CommentViewContextExt<'input>>;

pub trait CommentViewContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IS
    /// Returns `None` if there is no child corresponding to token IS
    fn IS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IS, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
}

impl<'input> CommentViewContextAttrs<'input> for CommentViewContext<'input> {}

pub struct CommentViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CommentViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CommentViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CommentViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_commentView(self);
    }
}

impl<'input> CustomRuleContext<'input> for CommentViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CommentViewContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CommentViewContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CommentViewContext<'input> {}

impl<'input> CommentViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CommentViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CommentViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowStatsContext<'input> =
    BaseParserRuleContext<'input, ShowStatsContextExt<'input>>;

pub trait ShowStatsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STATS
    /// Returns `None` if there is no child corresponding to token STATS
    fn STATS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STATS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOR
    /// Returns `None` if there is no child corresponding to token FOR
    fn FOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOR, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ShowStatsContextAttrs<'input> for ShowStatsContext<'input> {}

pub struct ShowStatsContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowStatsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowStatsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowStatsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showStats(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowStatsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowStatsContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowStatsContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowStatsContext<'input> {}

impl<'input> ShowStatsContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowStatsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowStatsContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowCreateSchemaContext<'input> =
    BaseParserRuleContext<'input, ShowCreateSchemaContextExt<'input>>;

pub trait ShowCreateSchemaContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ShowCreateSchemaContextAttrs<'input> for ShowCreateSchemaContext<'input> {}

pub struct ShowCreateSchemaContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowCreateSchemaContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowCreateSchemaContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowCreateSchemaContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showCreateSchema(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowCreateSchemaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowCreateSchemaContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowCreateSchemaContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowCreateSchemaContext<'input> {}

impl<'input> ShowCreateSchemaContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowCreateSchemaContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowCreateSchemaContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RevokeContext<'input> = BaseParserRuleContext<'input, RevokeContextExt<'input>>;

pub trait RevokeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token REVOKE
    /// Returns `None` if there is no child corresponding to token REVOKE
    fn REVOKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REVOKE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn privilege_all(&self) -> Vec<Rc<PrivilegeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn privilege(&self, i: usize) -> Option<Rc<PrivilegeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRIVILEGES
    /// Returns `None` if there is no child corresponding to token PRIVILEGES
    fn PRIVILEGES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRIVILEGES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRANT
    /// Returns `None` if there is no child corresponding to token GRANT
    fn GRANT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OPTION
    /// Returns `None` if there is no child corresponding to token OPTION
    fn OPTION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OPTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOR
    /// Returns `None` if there is no child corresponding to token FOR
    fn FOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> RevokeContextAttrs<'input> for RevokeContext<'input> {}

pub struct RevokeContextExt<'input> {
    base: StatementContextExt<'input>,
    pub grantee: Option<Rc<PrincipalContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RevokeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RevokeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RevokeContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_revoke(self);
    }
}

impl<'input> CustomRuleContext<'input> for RevokeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RevokeContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RevokeContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RevokeContext<'input> {}

impl<'input> RevokeContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RevokeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RevokeContextExt {
                    grantee: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type UpdateContext<'input> = BaseParserRuleContext<'input, UpdateContextExt<'input>>;

pub trait UpdateContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token UPDATE
    /// Returns `None` if there is no child corresponding to token UPDATE
    fn UPDATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UPDATE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    fn updateAssignment_all(&self) -> Vec<Rc<UpdateAssignmentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn updateAssignment(&self, i: usize) -> Option<Rc<UpdateAssignmentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token WHERE
    /// Returns `None` if there is no child corresponding to token WHERE
    fn WHERE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHERE, 0)
    }
    fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> UpdateContextAttrs<'input> for UpdateContext<'input> {}

pub struct UpdateContextExt<'input> {
    base: StatementContextExt<'input>,
    pub where_: Option<Rc<BooleanExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UpdateContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UpdateContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for UpdateContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_update(self);
    }
}

impl<'input> CustomRuleContext<'input> for UpdateContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for UpdateContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for UpdateContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for UpdateContext<'input> {}

impl<'input> UpdateContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::UpdateContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UpdateContextExt {
                    where_: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TableExecuteContext<'input> =
    BaseParserRuleContext<'input, TableExecuteContextExt<'input>>;

pub trait TableExecuteContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXECUTE
    /// Returns `None` if there is no child corresponding to token EXECUTE
    fn EXECUTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXECUTE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WHERE
    /// Returns `None` if there is no child corresponding to token WHERE
    fn WHERE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHERE, 0)
    }
    fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn callArgument_all(&self) -> Vec<Rc<CallArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn callArgument(&self, i: usize) -> Option<Rc<CallArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> TableExecuteContextAttrs<'input> for TableExecuteContext<'input> {}

pub struct TableExecuteContextExt<'input> {
    base: StatementContextExt<'input>,
    pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub procedureName: Option<Rc<IdentifierContextAll<'input>>>,
    pub where_: Option<Rc<BooleanExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TableExecuteContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TableExecuteContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableExecuteContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableExecute(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableExecuteContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for TableExecuteContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for TableExecuteContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for TableExecuteContext<'input> {}

impl<'input> TableExecuteContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::TableExecuteContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TableExecuteContextExt {
                    tableName: None,
                    procedureName: None,
                    where_: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DeleteContext<'input> = BaseParserRuleContext<'input, DeleteContextExt<'input>>;

pub trait DeleteContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DELETE
    /// Returns `None` if there is no child corresponding to token DELETE
    fn DELETE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DELETE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WHERE
    /// Returns `None` if there is no child corresponding to token WHERE
    fn WHERE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHERE, 0)
    }
    fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> DeleteContextAttrs<'input> for DeleteContext<'input> {}

pub struct DeleteContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DeleteContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DeleteContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for DeleteContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_delete(self);
    }
}

impl<'input> CustomRuleContext<'input> for DeleteContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DeleteContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DeleteContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DeleteContext<'input> {}

impl<'input> DeleteContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DeleteContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DeleteContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DescribeInputContext<'input> =
    BaseParserRuleContext<'input, DescribeInputContextExt<'input>>;

pub trait DescribeInputContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DESCRIBE
    /// Returns `None` if there is no child corresponding to token DESCRIBE
    fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESCRIBE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INPUT
    /// Returns `None` if there is no child corresponding to token INPUT
    fn INPUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INPUT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> DescribeInputContextAttrs<'input> for DescribeInputContext<'input> {}

pub struct DescribeInputContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DescribeInputContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DescribeInputContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DescribeInputContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_describeInput(self);
    }
}

impl<'input> CustomRuleContext<'input> for DescribeInputContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DescribeInputContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DescribeInputContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DescribeInputContext<'input> {}

impl<'input> DescribeInputContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DescribeInputContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DescribeInputContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowStatsForQueryContext<'input> =
    BaseParserRuleContext<'input, ShowStatsForQueryContextExt<'input>>;

pub trait ShowStatsForQueryContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STATS
    /// Returns `None` if there is no child corresponding to token STATS
    fn STATS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STATS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOR
    /// Returns `None` if there is no child corresponding to token FOR
    fn FOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOR, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ShowStatsForQueryContextAttrs<'input> for ShowStatsForQueryContext<'input> {}

pub struct ShowStatsForQueryContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowStatsForQueryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowStatsForQueryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowStatsForQueryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showStatsForQuery(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowStatsForQueryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowStatsForQueryContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowStatsForQueryContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowStatsForQueryContext<'input> {}

impl<'input> ShowStatsForQueryContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowStatsForQueryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowStatsForQueryContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetColumnTypeContext<'input> =
    BaseParserRuleContext<'input, SetColumnTypeContextExt<'input>>;

pub trait SetColumnTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves all `TerminalNode`s corresponding to token ALTER in current rule
    fn ALTER_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token ALTER, starting from 0.
    /// Returns `None` if number of children corresponding to token ALTER is less or equal than `i`.
    fn ALTER(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, i)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMN
    /// Returns `None` if there is no child corresponding to token COLUMN
    fn COLUMN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DATA
    /// Returns `None` if there is no child corresponding to token DATA
    fn DATA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DATA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TYPE
    /// Returns `None` if there is no child corresponding to token TYPE
    fn TYPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TYPE, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
}

impl<'input> SetColumnTypeContextAttrs<'input> for SetColumnTypeContext<'input> {}

pub struct SetColumnTypeContextExt<'input> {
    base: StatementContextExt<'input>,
    pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub columnName: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetColumnTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetColumnTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetColumnTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setColumnType(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetColumnTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetColumnTypeContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetColumnTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetColumnTypeContext<'input> {}

impl<'input> SetColumnTypeContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetColumnTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetColumnTypeContextExt {
                    tableName: None,
                    columnName: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type StatementDefaultContext<'input> =
    BaseParserRuleContext<'input, StatementDefaultContextExt<'input>>;

pub trait StatementDefaultContextAttrs<'input>: PrestoParserContext<'input> {
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> StatementDefaultContextAttrs<'input> for StatementDefaultContext<'input> {}

pub struct StatementDefaultContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {StatementDefaultContextExt<'a>}

impl<'input> PrestoParserContext<'input> for StatementDefaultContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StatementDefaultContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_statementDefault(self);
    }
}

impl<'input> CustomRuleContext<'input> for StatementDefaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for StatementDefaultContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for StatementDefaultContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for StatementDefaultContext<'input> {}

impl<'input> StatementDefaultContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::StatementDefaultContext(
            BaseParserRuleContext::copy_from(
                ctx,
                StatementDefaultContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetTimeZoneContext<'input> =
    BaseParserRuleContext<'input, SetTimeZoneContextExt<'input>>;

pub trait SetTimeZoneContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TIME
    /// Returns `None` if there is no child corresponding to token TIME
    fn TIME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ZONE
    /// Returns `None` if there is no child corresponding to token ZONE
    fn ZONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ZONE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOCAL
    /// Returns `None` if there is no child corresponding to token LOCAL
    fn LOCAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOCAL, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetTimeZoneContextAttrs<'input> for SetTimeZoneContext<'input> {}

pub struct SetTimeZoneContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetTimeZoneContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetTimeZoneContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetTimeZoneContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setTimeZone(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetTimeZoneContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetTimeZoneContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetTimeZoneContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetTimeZoneContext<'input> {}

impl<'input> SetTimeZoneContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetTimeZoneContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetTimeZoneContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TruncateTableContext<'input> =
    BaseParserRuleContext<'input, TruncateTableContextExt<'input>>;

pub trait TruncateTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TRUNCATE
    /// Returns `None` if there is no child corresponding to token TRUNCATE
    fn TRUNCATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRUNCATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TruncateTableContextAttrs<'input> for TruncateTableContext<'input> {}

pub struct TruncateTableContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TruncateTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TruncateTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TruncateTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_truncateTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for TruncateTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for TruncateTableContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for TruncateTableContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for TruncateTableContext<'input> {}

impl<'input> TruncateTableContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::TruncateTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TruncateTableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CreateMaterializedViewContext<'input> =
    BaseParserRuleContext<'input, CreateMaterializedViewContextExt<'input>>;

pub trait CreateMaterializedViewContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATERIALIZED
    /// Returns `None` if there is no child corresponding to token MATERIALIZED
    fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATERIALIZED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OR
    /// Returns `None` if there is no child corresponding to token OR
    fn OR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token REPLACE
    /// Returns `None` if there is no child corresponding to token REPLACE
    fn REPLACE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REPLACE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRACE
    /// Returns `None` if there is no child corresponding to token GRACE
    fn GRACE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRACE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PERIOD
    /// Returns `None` if there is no child corresponding to token PERIOD
    fn PERIOD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PERIOD, 0)
    }
    fn interval(&self) -> Option<Rc<IntervalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CreateMaterializedViewContextAttrs<'input>
    for CreateMaterializedViewContext<'input>
{
}

pub struct CreateMaterializedViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CreateMaterializedViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CreateMaterializedViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CreateMaterializedViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_createMaterializedView(self);
    }
}

impl<'input> CustomRuleContext<'input> for CreateMaterializedViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>>
    for CreateMaterializedViewContext<'input>
{
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for CreateMaterializedViewContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CreateMaterializedViewContext<'input> {}

impl<'input> CreateMaterializedViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CreateMaterializedViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CreateMaterializedViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetSessionContext<'input> =
    BaseParserRuleContext<'input, SetSessionContextExt<'input>>;

pub trait SetSessionContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SESSION
    /// Returns `None` if there is no child corresponding to token SESSION
    fn SESSION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SESSION, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EQ
    /// Returns `None` if there is no child corresponding to token EQ
    fn EQ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EQ, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetSessionContextAttrs<'input> for SetSessionContext<'input> {}

pub struct SetSessionContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetSessionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetSessionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetSessionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setSession(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetSessionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetSessionContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetSessionContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetSessionContext<'input> {}

impl<'input> SetSessionContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetSessionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetSessionContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CreateViewContext<'input> =
    BaseParserRuleContext<'input, CreateViewContextExt<'input>>;

pub trait CreateViewContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OR
    /// Returns `None` if there is no child corresponding to token OR
    fn OR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token REPLACE
    /// Returns `None` if there is no child corresponding to token REPLACE
    fn REPLACE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REPLACE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SECURITY
    /// Returns `None` if there is no child corresponding to token SECURITY
    fn SECURITY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SECURITY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DEFINER
    /// Returns `None` if there is no child corresponding to token DEFINER
    fn DEFINER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFINER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INVOKER
    /// Returns `None` if there is no child corresponding to token INVOKER
    fn INVOKER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INVOKER, 0)
    }
}

impl<'input> CreateViewContextAttrs<'input> for CreateViewContext<'input> {}

pub struct CreateViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CreateViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CreateViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CreateViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_createView(self);
    }
}

impl<'input> CustomRuleContext<'input> for CreateViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateViewContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateViewContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CreateViewContext<'input> {}

impl<'input> CreateViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CreateViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CreateViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RenameMaterializedViewContext<'input> =
    BaseParserRuleContext<'input, RenameMaterializedViewContextExt<'input>>;

pub trait RenameMaterializedViewContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATERIALIZED
    /// Returns `None` if there is no child corresponding to token MATERIALIZED
    fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATERIALIZED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RENAME
    /// Returns `None` if there is no child corresponding to token RENAME
    fn RENAME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RENAME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn qualifiedName_all(&self) -> Vec<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
}

impl<'input> RenameMaterializedViewContextAttrs<'input>
    for RenameMaterializedViewContext<'input>
{
}

pub struct RenameMaterializedViewContextExt<'input> {
    base: StatementContextExt<'input>,
    pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub to: Option<Rc<QualifiedNameContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RenameMaterializedViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RenameMaterializedViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RenameMaterializedViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_renameMaterializedView(self);
    }
}

impl<'input> CustomRuleContext<'input> for RenameMaterializedViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>>
    for RenameMaterializedViewContext<'input>
{
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for RenameMaterializedViewContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RenameMaterializedViewContext<'input> {}

impl<'input> RenameMaterializedViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RenameMaterializedViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RenameMaterializedViewContextExt {
                    from: None,
                    to: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowSchemasContext<'input> =
    BaseParserRuleContext<'input, ShowSchemasContextExt<'input>>;

pub trait ShowSchemasContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMAS
    /// Returns `None` if there is no child corresponding to token SCHEMAS
    fn SCHEMAS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMAS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
    fn string_all(&self) -> Vec<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ESCAPE
    /// Returns `None` if there is no child corresponding to token ESCAPE
    fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ESCAPE, 0)
    }
}

impl<'input> ShowSchemasContextAttrs<'input> for ShowSchemasContext<'input> {}

pub struct ShowSchemasContextExt<'input> {
    base: StatementContextExt<'input>,
    pub pattern: Option<Rc<StringContextAll<'input>>>,
    pub escape: Option<Rc<StringContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowSchemasContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowSchemasContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowSchemasContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showSchemas(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowSchemasContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowSchemasContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowSchemasContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowSchemasContext<'input> {}

impl<'input> ShowSchemasContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowSchemasContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowSchemasContextExt {
                    pattern: None,
                    escape: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DropTableContext<'input> =
    BaseParserRuleContext<'input, DropTableContextExt<'input>>;

pub trait DropTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DROP
    /// Returns `None` if there is no child corresponding to token DROP
    fn DROP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DROP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
}

impl<'input> DropTableContextAttrs<'input> for DropTableContext<'input> {}

pub struct DropTableContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DropTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DropTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DropTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dropTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for DropTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropTableContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropTableContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DropTableContext<'input> {}

impl<'input> DropTableContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DropTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DropTableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetSchemaAuthorizationContext<'input> =
    BaseParserRuleContext<'input, SetSchemaAuthorizationContextExt<'input>>;

pub trait SetSchemaAuthorizationContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AUTHORIZATION
    /// Returns `None` if there is no child corresponding to token AUTHORIZATION
    fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AUTHORIZATION, 0)
    }
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetSchemaAuthorizationContextAttrs<'input>
    for SetSchemaAuthorizationContext<'input>
{
}

pub struct SetSchemaAuthorizationContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetSchemaAuthorizationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetSchemaAuthorizationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetSchemaAuthorizationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setSchemaAuthorization(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetSchemaAuthorizationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>>
    for SetSchemaAuthorizationContext<'input>
{
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for SetSchemaAuthorizationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetSchemaAuthorizationContext<'input> {}

impl<'input> SetSchemaAuthorizationContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetSchemaAuthorizationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetSchemaAuthorizationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RollbackContext<'input> =
    BaseParserRuleContext<'input, RollbackContextExt<'input>>;

pub trait RollbackContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ROLLBACK
    /// Returns `None` if there is no child corresponding to token ROLLBACK
    fn ROLLBACK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLLBACK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WORK
    /// Returns `None` if there is no child corresponding to token WORK
    fn WORK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WORK, 0)
    }
}

impl<'input> RollbackContextAttrs<'input> for RollbackContext<'input> {}

pub struct RollbackContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RollbackContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RollbackContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RollbackContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rollback(self);
    }
}

impl<'input> CustomRuleContext<'input> for RollbackContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RollbackContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RollbackContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RollbackContext<'input> {}

impl<'input> RollbackContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RollbackContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RollbackContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CommentTableContext<'input> =
    BaseParserRuleContext<'input, CommentTableContextExt<'input>>;

pub trait CommentTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IS
    /// Returns `None` if there is no child corresponding to token IS
    fn IS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IS, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
}

impl<'input> CommentTableContextAttrs<'input> for CommentTableContext<'input> {}

pub struct CommentTableContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CommentTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CommentTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CommentTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_commentTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for CommentTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CommentTableContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CommentTableContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CommentTableContext<'input> {}

impl<'input> CommentTableContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CommentTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CommentTableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RenameViewContext<'input> =
    BaseParserRuleContext<'input, RenameViewContextExt<'input>>;

pub trait RenameViewContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RENAME
    /// Returns `None` if there is no child corresponding to token RENAME
    fn RENAME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RENAME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn qualifiedName_all(&self) -> Vec<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> RenameViewContextAttrs<'input> for RenameViewContext<'input> {}

pub struct RenameViewContextExt<'input> {
    base: StatementContextExt<'input>,
    pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
    pub to: Option<Rc<QualifiedNameContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RenameViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RenameViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RenameViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_renameView(self);
    }
}

impl<'input> CustomRuleContext<'input> for RenameViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameViewContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameViewContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RenameViewContext<'input> {}

impl<'input> RenameViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RenameViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RenameViewContextExt {
                    from: None,
                    to: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetPathContext<'input> =
    BaseParserRuleContext<'input, SetPathContextExt<'input>>;

pub trait SetPathContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PATH
    /// Returns `None` if there is no child corresponding to token PATH
    fn PATH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PATH, 0)
    }
    fn pathSpecification(&self) -> Option<Rc<PathSpecificationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetPathContextAttrs<'input> for SetPathContext<'input> {}

pub struct SetPathContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetPathContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetPathContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for SetPathContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setPath(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetPathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetPathContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetPathContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetPathContext<'input> {}

impl<'input> SetPathContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetPathContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetPathContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type GrantRolesContext<'input> =
    BaseParserRuleContext<'input, GrantRolesContextExt<'input>>;

pub trait GrantRolesContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token GRANT
    /// Returns `None` if there is no child corresponding to token GRANT
    fn GRANT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANT, 0)
    }
    fn roles(&self) -> Option<Rc<RolesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn principal_all(&self) -> Vec<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn principal(&self, i: usize) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ADMIN
    /// Returns `None` if there is no child corresponding to token ADMIN
    fn ADMIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ADMIN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OPTION
    /// Returns `None` if there is no child corresponding to token OPTION
    fn OPTION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OPTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRANTED
    /// Returns `None` if there is no child corresponding to token GRANTED
    fn GRANTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANTED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BY
    /// Returns `None` if there is no child corresponding to token BY
    fn BY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, 0)
    }
    fn grantor(&self) -> Option<Rc<GrantorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> GrantRolesContextAttrs<'input> for GrantRolesContext<'input> {}

pub struct GrantRolesContextExt<'input> {
    base: StatementContextExt<'input>,
    pub catalog: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {GrantRolesContextExt<'a>}

impl<'input> PrestoParserContext<'input> for GrantRolesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GrantRolesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_grantRoles(self);
    }
}

impl<'input> CustomRuleContext<'input> for GrantRolesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for GrantRolesContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for GrantRolesContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for GrantRolesContext<'input> {}

impl<'input> GrantRolesContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::GrantRolesContext(
            BaseParserRuleContext::copy_from(
                ctx,
                GrantRolesContextExt {
                    catalog: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CallContext<'input> = BaseParserRuleContext<'input, CallContextExt<'input>>;

pub trait CallContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CALL
    /// Returns `None` if there is no child corresponding to token CALL
    fn CALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CALL, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn callArgument_all(&self) -> Vec<Rc<CallArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn callArgument(&self, i: usize) -> Option<Rc<CallArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> CallContextAttrs<'input> for CallContext<'input> {}

pub struct CallContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CallContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CallContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for CallContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for CallContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CallContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CallContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for CallContext<'input> {}

impl<'input> CallContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::CallContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CallContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RefreshMaterializedViewContext<'input> =
    BaseParserRuleContext<'input, RefreshMaterializedViewContextExt<'input>>;

pub trait RefreshMaterializedViewContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token REFRESH
    /// Returns `None` if there is no child corresponding to token REFRESH
    fn REFRESH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REFRESH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATERIALIZED
    /// Returns `None` if there is no child corresponding to token MATERIALIZED
    fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATERIALIZED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> RefreshMaterializedViewContextAttrs<'input>
    for RefreshMaterializedViewContext<'input>
{
}

pub struct RefreshMaterializedViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RefreshMaterializedViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RefreshMaterializedViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RefreshMaterializedViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_refreshMaterializedView(self);
    }
}

impl<'input> CustomRuleContext<'input> for RefreshMaterializedViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>>
    for RefreshMaterializedViewContext<'input>
{
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for RefreshMaterializedViewContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for RefreshMaterializedViewContext<'input> {}

impl<'input> RefreshMaterializedViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::RefreshMaterializedViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RefreshMaterializedViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowCreateMaterializedViewContext<'input> =
    BaseParserRuleContext<'input, ShowCreateMaterializedViewContextExt<'input>>;

pub trait ShowCreateMaterializedViewContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATERIALIZED
    /// Returns `None` if there is no child corresponding to token MATERIALIZED
    fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATERIALIZED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ShowCreateMaterializedViewContextAttrs<'input>
    for ShowCreateMaterializedViewContext<'input>
{
}

pub struct ShowCreateMaterializedViewContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowCreateMaterializedViewContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowCreateMaterializedViewContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowCreateMaterializedViewContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showCreateMaterializedView(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowCreateMaterializedViewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>>
    for ShowCreateMaterializedViewContext<'input>
{
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for ShowCreateMaterializedViewContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowCreateMaterializedViewContext<'input> {}

impl<'input> ShowCreateMaterializedViewContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowCreateMaterializedViewContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowCreateMaterializedViewContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ShowFunctionsContext<'input> =
    BaseParserRuleContext<'input, ShowFunctionsContextExt<'input>>;

pub trait ShowFunctionsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FUNCTIONS
    /// Returns `None` if there is no child corresponding to token FUNCTIONS
    fn FUNCTIONS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FUNCTIONS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    fn string_all(&self) -> Vec<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ESCAPE
    /// Returns `None` if there is no child corresponding to token ESCAPE
    fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ESCAPE, 0)
    }
}

impl<'input> ShowFunctionsContextAttrs<'input> for ShowFunctionsContext<'input> {}

pub struct ShowFunctionsContextExt<'input> {
    base: StatementContextExt<'input>,
    pub pattern: Option<Rc<StringContextAll<'input>>>,
    pub escape: Option<Rc<StringContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ShowFunctionsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ShowFunctionsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ShowFunctionsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_showFunctions(self);
    }
}

impl<'input> CustomRuleContext<'input> for ShowFunctionsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowFunctionsContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowFunctionsContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for ShowFunctionsContext<'input> {}

impl<'input> ShowFunctionsContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::ShowFunctionsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ShowFunctionsContextExt {
                    pattern: None,
                    escape: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DescribeOutputContext<'input> =
    BaseParserRuleContext<'input, DescribeOutputContextExt<'input>>;

pub trait DescribeOutputContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DESCRIBE
    /// Returns `None` if there is no child corresponding to token DESCRIBE
    fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESCRIBE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OUTPUT
    /// Returns `None` if there is no child corresponding to token OUTPUT
    fn OUTPUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OUTPUT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> DescribeOutputContextAttrs<'input> for DescribeOutputContext<'input> {}

pub struct DescribeOutputContextExt<'input> {
    base: StatementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DescribeOutputContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DescribeOutputContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DescribeOutputContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_describeOutput(self);
    }
}

impl<'input> CustomRuleContext<'input> for DescribeOutputContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DescribeOutputContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DescribeOutputContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for DescribeOutputContext<'input> {}

impl<'input> DescribeOutputContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::DescribeOutputContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DescribeOutputContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type GrantContext<'input> = BaseParserRuleContext<'input, GrantContextExt<'input>>;

pub trait GrantContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves all `TerminalNode`s corresponding to token GRANT in current rule
    fn GRANT_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token GRANT, starting from 0.
    /// Returns `None` if number of children corresponding to token GRANT is less or equal than `i`.
    fn GRANT(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANT, i)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn privilege_all(&self) -> Vec<Rc<PrivilegeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn privilege(&self, i: usize) -> Option<Rc<PrivilegeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRIVILEGES
    /// Returns `None` if there is no child corresponding to token PRIVILEGES
    fn PRIVILEGES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRIVILEGES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OPTION
    /// Returns `None` if there is no child corresponding to token OPTION
    fn OPTION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OPTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> GrantContextAttrs<'input> for GrantContext<'input> {}

pub struct GrantContextExt<'input> {
    base: StatementContextExt<'input>,
    pub grantee: Option<Rc<PrincipalContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {GrantContextExt<'a>}

impl<'input> PrestoParserContext<'input> for GrantContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for GrantContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_grant(self);
    }
}

impl<'input> CustomRuleContext<'input> for GrantContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for GrantContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for GrantContext<'input> {
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for GrantContext<'input> {}

impl<'input> GrantContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::GrantContext(
            BaseParserRuleContext::copy_from(
                ctx,
                GrantContextExt {
                    grantee: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetTablePropertiesContext<'input> =
    BaseParserRuleContext<'input, SetTablePropertiesContextExt<'input>>;

pub trait SetTablePropertiesContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ALTER
    /// Returns `None` if there is no child corresponding to token ALTER
    fn ALTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PROPERTIES
    /// Returns `None` if there is no child corresponding to token PROPERTIES
    fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PROPERTIES, 0)
    }
    fn propertyAssignments(&self) -> Option<Rc<PropertyAssignmentsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SetTablePropertiesContextAttrs<'input>
    for SetTablePropertiesContext<'input>
{
}

pub struct SetTablePropertiesContextExt<'input> {
    base: StatementContextExt<'input>,
    pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetTablePropertiesContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetTablePropertiesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetTablePropertiesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setTableProperties(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetTablePropertiesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetTablePropertiesContext<'input> {
    fn borrow(&self) -> &StatementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StatementContextExt<'input>>
    for SetTablePropertiesContext<'input>
{
    fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StatementContextAttrs<'input> for SetTablePropertiesContext<'input> {}

impl<'input> SetTablePropertiesContextExt<'input> {
    fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>> {
        Rc::new(StatementContextAll::SetTablePropertiesContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetTablePropertiesContextExt {
                    tableName: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn statement(&mut self) -> Result<Rc<StatementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1031);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(108, &mut recog.base)? {
                1 => {
                    let tmp = StatementDefaultContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule query*/
                        recog.base.set_state(235);
                        recog.query()?;
                    }
                }
                2 => {
                    let tmp = UseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(236);
                        recog.base.match_token(USE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(237);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::UseContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.schema = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                3 => {
                    let tmp = UseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(238);
                        recog.base.match_token(USE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(239);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::UseContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.catalog = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(240);
                        recog.base.match_token(T__0, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(241);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::UseContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.schema = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                4 => {
                    let tmp = CreateSchemaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(243);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(244);
                        recog.base.match_token(SCHEMA, &mut recog.err_handler)?;

                        recog.base.set_state(248);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(0, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(245);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(246);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;

                                recog.base.set_state(247);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(250);
                        recog.qualifiedName()?;

                        recog.base.set_state(253);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == AUTHORIZATION {
                            {
                                recog.base.set_state(251);
                                recog
                                    .base
                                    .match_token(AUTHORIZATION, &mut recog.err_handler)?;

                                /*InvokeRule principal*/
                                recog.base.set_state(252);
                                recog.principal()?;
                            }
                        }

                        recog.base.set_state(257);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(255);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                /*InvokeRule properties*/
                                recog.base.set_state(256);
                                recog.properties()?;
                            }
                        }
                    }
                }
                5 => {
                    let tmp = DropSchemaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(259);
                        recog.base.match_token(DROP, &mut recog.err_handler)?;

                        recog.base.set_state(260);
                        recog.base.match_token(SCHEMA, &mut recog.err_handler)?;

                        recog.base.set_state(263);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(3, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(261);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(262);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(265);
                        recog.qualifiedName()?;

                        recog.base.set_state(267);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == CASCADE || _la == RESTRICT {
                            {
                                recog.base.set_state(266);
                                _la = recog.base.input.la(1);
                                if { !(_la == CASCADE || _la == RESTRICT) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                            }
                        }
                    }
                }
                6 => {
                    let tmp = RenameSchemaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(269);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(270);
                        recog.base.match_token(SCHEMA, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(271);
                        recog.qualifiedName()?;

                        recog.base.set_state(272);
                        recog.base.match_token(RENAME, &mut recog.err_handler)?;

                        recog.base.set_state(273);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(274);
                        recog.identifier()?;
                    }
                }
                7 => {
                    let tmp = SetSchemaAuthorizationContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        recog.base.set_state(276);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(277);
                        recog.base.match_token(SCHEMA, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(278);
                        recog.qualifiedName()?;

                        recog.base.set_state(279);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(280);
                        recog
                            .base
                            .match_token(AUTHORIZATION, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(281);
                        recog.principal()?;
                    }
                }
                8 => {
                    let tmp = CreateTableAsSelectContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 8);
                    _localctx = tmp;
                    {
                        recog.base.set_state(283);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(284);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(288);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(5, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(285);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(286);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;

                                recog.base.set_state(287);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(290);
                        recog.qualifiedName()?;

                        recog.base.set_state(292);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == T__1 {
                            {
                                /*InvokeRule columnAliases*/
                                recog.base.set_state(291);
                                recog.columnAliases()?;
                            }
                        }

                        recog.base.set_state(296);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMENT {
                            {
                                recog.base.set_state(294);
                                recog
                                    .base
                                    .match_token(COMMENT, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(295);
                                recog.string()?;
                            }
                        }

                        recog.base.set_state(300);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(298);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                /*InvokeRule properties*/
                                recog.base.set_state(299);
                                recog.properties()?;
                            }
                        }

                        recog.base.set_state(302);
                        recog.base.match_token(AS, &mut recog.err_handler)?;

                        recog.base.set_state(308);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(9, &mut recog.base)? {
                            1 => {
                                {
                                    /*InvokeRule query*/
                                    recog.base.set_state(303);
                                    recog.query()?;
                                }
                            }
                            2 => {
                                {
                                    recog.base.set_state(304);
                                    recog
                                        .base
                                        .match_token(T__1, &mut recog.err_handler)?;

                                    /*InvokeRule query*/
                                    recog.base.set_state(305);
                                    recog.query()?;

                                    recog.base.set_state(306);
                                    recog
                                        .base
                                        .match_token(T__2, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(315);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(310);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                recog.base.set_state(312);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == NO {
                                    {
                                        recog.base.set_state(311);
                                        recog
                                            .base
                                            .match_token(NO, &mut recog.err_handler)?;
                                    }
                                }

                                recog.base.set_state(314);
                                recog.base.match_token(DATA, &mut recog.err_handler)?;
                            }
                        }
                    }
                }
                9 => {
                    let tmp = CreateTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 9);
                    _localctx = tmp;
                    {
                        recog.base.set_state(317);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(318);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(322);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(12, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(319);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(320);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;

                                recog.base.set_state(321);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(324);
                        recog.qualifiedName()?;

                        recog.base.set_state(336);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == T__1 {
                            {
                                recog.base.set_state(325);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                /*InvokeRule tableElement*/
                                recog.base.set_state(326);
                                recog.tableElement()?;

                                recog.base.set_state(331);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(327);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule tableElement*/
                                            recog.base.set_state(328);
                                            recog.tableElement()?;
                                        }
                                    }
                                    recog.base.set_state(333);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                                recog.base.set_state(334);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(340);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMENT {
                            {
                                recog.base.set_state(338);
                                recog
                                    .base
                                    .match_token(COMMENT, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(339);
                                recog.string()?;
                            }
                        }

                        recog.base.set_state(344);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(342);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                /*InvokeRule properties*/
                                recog.base.set_state(343);
                                recog.properties()?;
                            }
                        }
                    }
                }
                10 => {
                    let tmp = DropTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 10);
                    _localctx = tmp;
                    {
                        recog.base.set_state(346);
                        recog.base.match_token(DROP, &mut recog.err_handler)?;

                        recog.base.set_state(347);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(350);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(17, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(348);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(349);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(352);
                        recog.qualifiedName()?;
                    }
                }
                11 => {
                    let tmp = InsertIntoContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 11);
                    _localctx = tmp;
                    {
                        recog.base.set_state(353);
                        recog.base.match_token(INSERT, &mut recog.err_handler)?;

                        recog.base.set_state(354);
                        recog.base.match_token(INTO, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(355);
                        recog.qualifiedName()?;

                        recog.base.set_state(357);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(18, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /*InvokeRule columnAliases*/
                                    recog.base.set_state(356);
                                    recog.columnAliases()?;
                                }
                            }

                            _ => {}
                        }
                        /*InvokeRule query*/
                        recog.base.set_state(359);
                        recog.query()?;
                    }
                }
                12 => {
                    let tmp = DeleteContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 12);
                    _localctx = tmp;
                    {
                        recog.base.set_state(361);
                        recog.base.match_token(DELETE, &mut recog.err_handler)?;

                        recog.base.set_state(362);
                        recog.base.match_token(FROM, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(363);
                        recog.qualifiedName()?;

                        recog.base.set_state(366);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WHERE {
                            {
                                recog.base.set_state(364);
                                recog.base.match_token(WHERE, &mut recog.err_handler)?;

                                /*InvokeRule booleanExpression*/
                                recog.base.set_state(365);
                                recog.booleanExpression_rec(0)?;
                            }
                        }
                    }
                }
                13 => {
                    let tmp = TruncateTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 13);
                    _localctx = tmp;
                    {
                        recog.base.set_state(368);
                        recog.base.match_token(TRUNCATE, &mut recog.err_handler)?;

                        recog.base.set_state(369);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(370);
                        recog.qualifiedName()?;
                    }
                }
                14 => {
                    let tmp = CommentTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 14);
                    _localctx = tmp;
                    {
                        recog.base.set_state(371);
                        recog.base.match_token(COMMENT, &mut recog.err_handler)?;

                        recog.base.set_state(372);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        recog.base.set_state(373);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(374);
                        recog.qualifiedName()?;

                        recog.base.set_state(375);
                        recog.base.match_token(IS, &mut recog.err_handler)?;

                        recog.base.set_state(378);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            STRING | UNICODE_STRING => {
                                {
                                    /*InvokeRule string*/
                                    recog.base.set_state(376);
                                    recog.string()?;
                                }
                            }

                            NULL => {
                                recog.base.set_state(377);
                                recog.base.match_token(NULL, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                                &mut recog.base,
                            )))?,
                        }
                    }
                }
                15 => {
                    let tmp = CommentViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 15);
                    _localctx = tmp;
                    {
                        recog.base.set_state(380);
                        recog.base.match_token(COMMENT, &mut recog.err_handler)?;

                        recog.base.set_state(381);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        recog.base.set_state(382);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(383);
                        recog.qualifiedName()?;

                        recog.base.set_state(384);
                        recog.base.match_token(IS, &mut recog.err_handler)?;

                        recog.base.set_state(387);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            STRING | UNICODE_STRING => {
                                {
                                    /*InvokeRule string*/
                                    recog.base.set_state(385);
                                    recog.string()?;
                                }
                            }

                            NULL => {
                                recog.base.set_state(386);
                                recog.base.match_token(NULL, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                                &mut recog.base,
                            )))?,
                        }
                    }
                }
                16 => {
                    let tmp = CommentColumnContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 16);
                    _localctx = tmp;
                    {
                        recog.base.set_state(389);
                        recog.base.match_token(COMMENT, &mut recog.err_handler)?;

                        recog.base.set_state(390);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        recog.base.set_state(391);
                        recog.base.match_token(COLUMN, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(392);
                        recog.qualifiedName()?;

                        recog.base.set_state(393);
                        recog.base.match_token(IS, &mut recog.err_handler)?;

                        recog.base.set_state(396);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            STRING | UNICODE_STRING => {
                                {
                                    /*InvokeRule string*/
                                    recog.base.set_state(394);
                                    recog.string()?;
                                }
                            }

                            NULL => {
                                recog.base.set_state(395);
                                recog.base.match_token(NULL, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                                &mut recog.base,
                            )))?,
                        }
                    }
                }
                17 => {
                    let tmp = RenameTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 17);
                    _localctx = tmp;
                    {
                        recog.base.set_state(398);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(399);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(402);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(23, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(400);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(401);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(404);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::RenameTableContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.from = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(405);
                        recog.base.match_token(RENAME, &mut recog.err_handler)?;

                        recog.base.set_state(406);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(407);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::RenameTableContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.to = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                18 => {
                    let tmp = AddColumnContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 18);
                    _localctx = tmp;
                    {
                        recog.base.set_state(409);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(410);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(413);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(24, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(411);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(412);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(415);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::AddColumnContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.tableName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(416);
                        recog.base.match_token(ADD, &mut recog.err_handler)?;

                        recog.base.set_state(417);
                        recog.base.match_token(COLUMN, &mut recog.err_handler)?;

                        recog.base.set_state(421);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(25, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(418);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(419);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;

                                recog.base.set_state(420);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule columnDefinition*/
                        recog.base.set_state(423);
                        let tmp = recog.columnDefinition()?;
                        if let StatementContextAll::AddColumnContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.column = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                19 => {
                    let tmp = RenameColumnContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 19);
                    _localctx = tmp;
                    {
                        recog.base.set_state(425);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(426);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(429);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(26, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(427);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(428);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(431);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::RenameColumnContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.tableName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(432);
                        recog.base.match_token(RENAME, &mut recog.err_handler)?;

                        recog.base.set_state(433);
                        recog.base.match_token(COLUMN, &mut recog.err_handler)?;

                        recog.base.set_state(436);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(27, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(434);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(435);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule identifier*/
                        recog.base.set_state(438);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::RenameColumnContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.from = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(439);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(440);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::RenameColumnContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.to = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                20 => {
                    let tmp = DropColumnContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 20);
                    _localctx = tmp;
                    {
                        recog.base.set_state(442);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(443);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(446);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(28, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(444);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(445);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(448);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::DropColumnContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.tableName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(449);
                        recog.base.match_token(DROP, &mut recog.err_handler)?;

                        recog.base.set_state(450);
                        recog.base.match_token(COLUMN, &mut recog.err_handler)?;

                        recog.base.set_state(453);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(29, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(451);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(452);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(455);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::DropColumnContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.column = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                21 => {
                    let tmp = SetColumnTypeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 21);
                    _localctx = tmp;
                    {
                        recog.base.set_state(457);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(458);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(461);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(30, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(459);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(460);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(463);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::SetColumnTypeContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.tableName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(464);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(465);
                        recog.base.match_token(COLUMN, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(466);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::SetColumnTypeContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.columnName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(467);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(468);
                        recog.base.match_token(DATA, &mut recog.err_handler)?;

                        recog.base.set_state(469);
                        recog.base.match_token(TYPE, &mut recog.err_handler)?;

                        /*InvokeRule type_*/
                        recog.base.set_state(470);
                        recog.type__rec(0)?;
                    }
                }
                22 => {
                    let tmp = SetTableAuthorizationContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 22);
                    _localctx = tmp;
                    {
                        recog.base.set_state(472);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(473);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(474);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::SetTableAuthorizationContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.tableName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(475);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(476);
                        recog
                            .base
                            .match_token(AUTHORIZATION, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(477);
                        recog.principal()?;
                    }
                }
                23 => {
                    let tmp = SetTablePropertiesContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 23);
                    _localctx = tmp;
                    {
                        recog.base.set_state(479);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(480);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(481);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::SetTablePropertiesContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.tableName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(482);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(483);
                        recog.base.match_token(PROPERTIES, &mut recog.err_handler)?;

                        /*InvokeRule propertyAssignments*/
                        recog.base.set_state(484);
                        recog.propertyAssignments()?;
                    }
                }
                24 => {
                    let tmp = TableExecuteContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 24);
                    _localctx = tmp;
                    {
                        recog.base.set_state(486);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(487);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(488);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::TableExecuteContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.tableName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(489);
                        recog.base.match_token(EXECUTE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(490);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::TableExecuteContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.procedureName = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(503);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == T__1 {
                            {
                                recog.base.set_state(491);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                recog.base.set_state(500);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if (((_la) & !0x3f) == 0
                                    && ((1usize << _la)
                                        & ((1usize << T__1)
                                            | (1usize << ABSENT)
                                            | (1usize << ADD)
                                            | (1usize << ADMIN)
                                            | (1usize << AFTER)
                                            | (1usize << ALL)
                                            | (1usize << ANALYZE)
                                            | (1usize << ANY)
                                            | (1usize << ARRAY)
                                            | (1usize << ASC)
                                            | (1usize << AT)
                                            | (1usize << AUTHORIZATION)
                                            | (1usize << BERNOULLI)))
                                        != 0)
                                    || (((_la - 33) & !0x3f) == 0
                                        && ((1usize << (_la - 33))
                                            & ((1usize << (BOTH - 33))
                                                | (1usize << (CALL - 33))
                                                | (1usize << (CASCADE - 33))
                                                | (1usize << (CASE - 33))
                                                | (1usize << (CAST - 33))
                                                | (1usize << (CATALOGS - 33))
                                                | (1usize << (COLUMN - 33))
                                                | (1usize << (COLUMNS - 33))
                                                | (1usize << (COMMENT - 33))
                                                | (1usize << (COMMIT - 33))
                                                | (1usize << (COMMITTED - 33))
                                                | (1usize << (CONDITIONAL - 33))
                                                | (1usize << (COUNT - 33))
                                                | (1usize << (COPARTITION - 33))
                                                | (1usize << (CURRENT - 33))
                                                | (1usize << (CURRENT_CATALOG - 33))
                                                | (1usize << (CURRENT_DATE - 33))
                                                | (1usize << (CURRENT_PATH - 33))
                                                | (1usize << (CURRENT_SCHEMA - 33))
                                                | (1usize << (CURRENT_TIME - 33))
                                                | (1usize << (CURRENT_TIMESTAMP - 33))
                                                | (1usize << (CURRENT_USER - 33))
                                                | (1usize << (DATA - 33))
                                                | (1usize << (DATE - 33))
                                                | (1usize << (DAY - 33))))
                                            != 0)
                                    || (((_la - 66) & !0x3f) == 0
                                        && ((1usize << (_la - 66))
                                            & ((1usize << (DEFAULT - 66))
                                                | (1usize << (DEFINE - 66))
                                                | (1usize << (DEFINER - 66))
                                                | (1usize << (DENY - 66))
                                                | (1usize << (DESC - 66))
                                                | (1usize << (DESCRIPTOR - 66))
                                                | (1usize << (DISTRIBUTED - 66))
                                                | (1usize << (DOUBLE - 66))
                                                | (1usize << (EMPTY - 66))
                                                | (1usize << (ENCODING - 66))
                                                | (1usize << (ERROR - 66))
                                                | (1usize << (EXCLUDING - 66))
                                                | (1usize << (EXISTS - 66))
                                                | (1usize << (EXPLAIN - 66))
                                                | (1usize << (EXTRACT - 66))
                                                | (1usize << (FALSE - 66))
                                                | (1usize << (FETCH - 66))
                                                | (1usize << (FILTER - 66))
                                                | (1usize << (FINAL - 66))
                                                | (1usize << (FIRST - 66))
                                                | (1usize << (FOLLOWING - 66))
                                                | (1usize << (FORMAT - 66))))
                                            != 0)
                                    || (((_la - 100) & !0x3f) == 0
                                        && ((1usize << (_la - 100))
                                            & ((1usize << (FUNCTIONS - 100))
                                                | (1usize << (GRACE - 100))
                                                | (1usize << (GRANT - 100))
                                                | (1usize << (GRANTED - 100))
                                                | (1usize << (GRANTS - 100))
                                                | (1usize << (GRAPHVIZ - 100))
                                                | (1usize << (GROUPING - 100))
                                                | (1usize << (GROUPS - 100))
                                                | (1usize << (HOUR - 100))
                                                | (1usize << (IF - 100))
                                                | (1usize << (IGNORE - 100))
                                                | (1usize << (INCLUDING - 100))
                                                | (1usize << (INITIAL - 100))
                                                | (1usize << (INPUT - 100))
                                                | (1usize << (INTERVAL - 100))
                                                | (1usize << (INVOKER - 100))
                                                | (1usize << (IO - 100))
                                                | (1usize << (ISOLATION - 100))
                                                | (1usize << (JSON - 100))
                                                | (1usize << (JSON_ARRAY - 100))
                                                | (1usize << (JSON_EXISTS - 100))
                                                | (1usize << (JSON_OBJECT - 100))
                                                | (1usize << (JSON_QUERY - 100))))
                                            != 0)
                                    || (((_la - 132) & !0x3f) == 0
                                        && ((1usize << (_la - 132))
                                            & ((1usize << (JSON_VALUE - 132))
                                                | (1usize << (KEEP - 132))
                                                | (1usize << (KEY - 132))
                                                | (1usize << (KEYS - 132))
                                                | (1usize << (LAST - 132))
                                                | (1usize << (LATERAL - 132))
                                                | (1usize << (LEADING - 132))
                                                | (1usize << (LEVEL - 132))
                                                | (1usize << (LIMIT - 132))
                                                | (1usize << (LISTAGG - 132))
                                                | (1usize << (LOCAL - 132))
                                                | (1usize << (LOCALTIME - 132))
                                                | (1usize << (LOCALTIMESTAMP - 132))
                                                | (1usize << (LOGICAL - 132))
                                                | (1usize << (MAP - 132))
                                                | (1usize << (MATCH - 132))
                                                | (1usize << (MATCHED - 132))
                                                | (1usize << (MATCHES - 132))
                                                | (1usize << (MATCH_RECOGNIZE - 132))
                                                | (1usize << (MATERIALIZED - 132))
                                                | (1usize << (MEASURES - 132))
                                                | (1usize << (MERGE - 132))
                                                | (1usize << (MINUTE - 132))
                                                | (1usize << (MONTH - 132))
                                                | (1usize << (NEXT - 132))
                                                | (1usize << (NFC - 132))
                                                | (1usize << (NFD - 132))
                                                | (1usize << (NFKC - 132))
                                                | (1usize << (NFKD - 132))))
                                            != 0)
                                    || (((_la - 164) & !0x3f) == 0
                                        && ((1usize << (_la - 164))
                                            & ((1usize << (NO - 164))
                                                | (1usize << (NONE - 164))
                                                | (1usize << (NORMALIZE - 164))
                                                | (1usize << (NOT - 164))
                                                | (1usize << (NULL - 164))
                                                | (1usize << (NULLIF - 164))
                                                | (1usize << (NULLS - 164))
                                                | (1usize << (OBJECT - 164))
                                                | (1usize << (OF - 164))
                                                | (1usize << (OFFSET - 164))
                                                | (1usize << (OMIT - 164))
                                                | (1usize << (ONE - 164))
                                                | (1usize << (ONLY - 164))
                                                | (1usize << (OPTION - 164))
                                                | (1usize << (ORDINALITY - 164))
                                                | (1usize << (OUTPUT - 164))
                                                | (1usize << (OVER - 164))
                                                | (1usize << (OVERFLOW - 164))
                                                | (1usize << (PARTITION - 164))
                                                | (1usize << (PARTITIONS - 164))
                                                | (1usize << (PASSING - 164))
                                                | (1usize << (PAST - 164))
                                                | (1usize << (PATH - 164))
                                                | (1usize << (PATTERN - 164))
                                                | (1usize << (PER - 164))
                                                | (1usize << (PERIOD - 164))
                                                | (1usize << (PERMUTE - 164))
                                                | (1usize << (POSITION - 164))))
                                            != 0)
                                    || (((_la - 196) & !0x3f) == 0
                                        && ((1usize << (_la - 196))
                                            & ((1usize << (PRECEDING - 196))
                                                | (1usize << (PRECISION - 196))
                                                | (1usize << (PRIVILEGES - 196))
                                                | (1usize << (PROPERTIES - 196))
                                                | (1usize << (PRUNE - 196))
                                                | (1usize << (QUOTES - 196))
                                                | (1usize << (RANGE - 196))
                                                | (1usize << (READ - 196))
                                                | (1usize << (REFRESH - 196))
                                                | (1usize << (RENAME - 196))
                                                | (1usize << (REPEATABLE - 196))
                                                | (1usize << (REPLACE - 196))
                                                | (1usize << (RESET - 196))
                                                | (1usize << (RESPECT - 196))
                                                | (1usize << (RESTRICT - 196))
                                                | (1usize << (RETURNING - 196))
                                                | (1usize << (REVOKE - 196))
                                                | (1usize << (ROLE - 196))
                                                | (1usize << (ROLES - 196))
                                                | (1usize << (ROLLBACK - 196))
                                                | (1usize << (ROW - 196))
                                                | (1usize << (ROWS - 196))
                                                | (1usize << (RUNNING - 196))
                                                | (1usize << (SCALAR - 196))
                                                | (1usize << (SCHEMA - 196))
                                                | (1usize << (SCHEMAS - 196))
                                                | (1usize << (SECOND - 196))
                                                | (1usize << (SECURITY - 196))))
                                            != 0)
                                    || (((_la - 228) & !0x3f) == 0
                                        && ((1usize << (_la - 228))
                                            & ((1usize << (SEEK - 228))
                                                | (1usize << (SERIALIZABLE - 228))
                                                | (1usize << (SESSION - 228))
                                                | (1usize << (SET - 228))
                                                | (1usize << (SETS - 228))
                                                | (1usize << (SHOW - 228))
                                                | (1usize << (SOME - 228))
                                                | (1usize << (START - 228))
                                                | (1usize << (STATS - 228))
                                                | (1usize << (SUBSET - 228))
                                                | (1usize << (SUBSTRING - 228))
                                                | (1usize << (SYSTEM - 228))
                                                | (1usize << (TABLES - 228))
                                                | (1usize << (TABLESAMPLE - 228))
                                                | (1usize << (TEXT - 228))
                                                | (1usize << (TEXT_STRING - 228))
                                                | (1usize << (TIES - 228))
                                                | (1usize << (TIME - 228))
                                                | (1usize << (TIMESTAMP - 228))
                                                | (1usize << (TO - 228))
                                                | (1usize << (TRAILING - 228))
                                                | (1usize << (TRANSACTION - 228))
                                                | (1usize << (TRIM - 228))
                                                | (1usize << (TRUE - 228))
                                                | (1usize << (TRUNCATE - 228))
                                                | (1usize << (TRY_CAST - 228))
                                                | (1usize << (TYPE - 228))
                                                | (1usize << (UNBOUNDED - 228))))
                                            != 0)
                                    || (((_la - 260) & !0x3f) == 0
                                        && ((1usize << (_la - 260))
                                            & ((1usize << (UNCOMMITTED - 260))
                                                | (1usize << (UNCONDITIONAL - 260))
                                                | (1usize << (UNIQUE - 260))
                                                | (1usize << (UNKNOWN - 260))
                                                | (1usize << (UNMATCHED - 260))
                                                | (1usize << (UPDATE - 260))
                                                | (1usize << (USE - 260))
                                                | (1usize << (USER - 260))
                                                | (1usize << (UTF16 - 260))
                                                | (1usize << (UTF32 - 260))
                                                | (1usize << (UTF8 - 260))
                                                | (1usize << (VALIDATE - 260))
                                                | (1usize << (VALUE - 260))
                                                | (1usize << (VERBOSE - 260))
                                                | (1usize << (VERSION - 260))
                                                | (1usize << (VIEW - 260))
                                                | (1usize << (WINDOW - 260))
                                                | (1usize << (WITHIN - 260))
                                                | (1usize << (WITHOUT - 260))
                                                | (1usize << (WORK - 260))
                                                | (1usize << (WRAPPER - 260))
                                                | (1usize << (WRITE - 260))
                                                | (1usize << (YEAR - 260))
                                                | (1usize << (ZONE - 260))))
                                            != 0)
                                    || (((_la - 297) & !0x3f) == 0
                                        && ((1usize << (_la - 297))
                                            & ((1usize << (PLUS - 297))
                                                | (1usize << (MINUS - 297))
                                                | (1usize << (QUESTION_MARK - 297))
                                                | (1usize << (STRING - 297))
                                                | (1usize << (UNICODE_STRING - 297))
                                                | (1usize << (BINARY_LITERAL - 297))
                                                | (1usize << (INTEGER_VALUE - 297))
                                                | (1usize << (DECIMAL_VALUE - 297))
                                                | (1usize << (DOUBLE_VALUE - 297))
                                                | (1usize << (IDENTIFIER - 297))
                                                | (1usize << (DIGIT_IDENTIFIER - 297))
                                                | (1usize << (QUOTED_IDENTIFIER - 297))
                                                | (1usize
                                                    << (BACKQUOTED_IDENTIFIER - 297))))
                                            != 0)
                                {
                                    {
                                        /*InvokeRule callArgument*/
                                        recog.base.set_state(492);
                                        recog.callArgument()?;

                                        recog.base.set_state(497);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        while _la == COMMA {
                                            {
                                                {
                                                    recog.base.set_state(493);
                                                    recog.base.match_token(
                                                        COMMA,
                                                        &mut recog.err_handler,
                                                    )?;

                                                    /*InvokeRule callArgument*/
                                                    recog.base.set_state(494);
                                                    recog.callArgument()?;
                                                }
                                            }
                                            recog.base.set_state(499);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _la = recog.base.input.la(1);
                                        }
                                    }
                                }

                                recog.base.set_state(502);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(507);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WHERE {
                            {
                                recog.base.set_state(505);
                                recog.base.match_token(WHERE, &mut recog.err_handler)?;

                                /*InvokeRule booleanExpression*/
                                recog.base.set_state(506);
                                let tmp = recog.booleanExpression_rec(0)?;
                                if let StatementContextAll::TableExecuteContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.where_ = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }
                    }
                }
                25 => {
                    let tmp = AnalyzeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 25);
                    _localctx = tmp;
                    {
                        recog.base.set_state(509);
                        recog.base.match_token(ANALYZE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(510);
                        recog.qualifiedName()?;

                        recog.base.set_state(513);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(511);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                /*InvokeRule properties*/
                                recog.base.set_state(512);
                                recog.properties()?;
                            }
                        }
                    }
                }
                26 => {
                    let tmp = CreateMaterializedViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 26);
                    _localctx = tmp;
                    {
                        recog.base.set_state(515);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(518);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OR {
                            {
                                recog.base.set_state(516);
                                recog.base.match_token(OR, &mut recog.err_handler)?;

                                recog.base.set_state(517);
                                recog
                                    .base
                                    .match_token(REPLACE, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(520);
                        recog
                            .base
                            .match_token(MATERIALIZED, &mut recog.err_handler)?;

                        recog.base.set_state(521);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        recog.base.set_state(525);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(37, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(522);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(523);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;

                                recog.base.set_state(524);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(527);
                        recog.qualifiedName()?;

                        recog.base.set_state(531);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == GRACE {
                            {
                                recog.base.set_state(528);
                                recog.base.match_token(GRACE, &mut recog.err_handler)?;

                                recog.base.set_state(529);
                                recog.base.match_token(PERIOD, &mut recog.err_handler)?;

                                /*InvokeRule interval*/
                                recog.base.set_state(530);
                                recog.interval()?;
                            }
                        }

                        recog.base.set_state(535);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMENT {
                            {
                                recog.base.set_state(533);
                                recog
                                    .base
                                    .match_token(COMMENT, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(534);
                                recog.string()?;
                            }
                        }

                        recog.base.set_state(539);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(537);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                /*InvokeRule properties*/
                                recog.base.set_state(538);
                                recog.properties()?;
                            }
                        }

                        recog.base.set_state(541);
                        recog.base.match_token(AS, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(542);
                        recog.query()?;
                    }
                }
                27 => {
                    let tmp = CreateViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 27);
                    _localctx = tmp;
                    {
                        recog.base.set_state(544);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(547);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OR {
                            {
                                recog.base.set_state(545);
                                recog.base.match_token(OR, &mut recog.err_handler)?;

                                recog.base.set_state(546);
                                recog
                                    .base
                                    .match_token(REPLACE, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(549);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(550);
                        recog.qualifiedName()?;

                        recog.base.set_state(553);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMENT {
                            {
                                recog.base.set_state(551);
                                recog
                                    .base
                                    .match_token(COMMENT, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(552);
                                recog.string()?;
                            }
                        }

                        recog.base.set_state(557);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == SECURITY {
                            {
                                recog.base.set_state(555);
                                recog
                                    .base
                                    .match_token(SECURITY, &mut recog.err_handler)?;

                                recog.base.set_state(556);
                                _la = recog.base.input.la(1);
                                if { !(_la == DEFINER || _la == INVOKER) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                            }
                        }

                        recog.base.set_state(559);
                        recog.base.match_token(AS, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(560);
                        recog.query()?;
                    }
                }
                28 => {
                    let tmp = RefreshMaterializedViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 28);
                    _localctx = tmp;
                    {
                        recog.base.set_state(562);
                        recog.base.match_token(REFRESH, &mut recog.err_handler)?;

                        recog.base.set_state(563);
                        recog
                            .base
                            .match_token(MATERIALIZED, &mut recog.err_handler)?;

                        recog.base.set_state(564);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(565);
                        recog.qualifiedName()?;
                    }
                }
                29 => {
                    let tmp = DropMaterializedViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 29);
                    _localctx = tmp;
                    {
                        recog.base.set_state(566);
                        recog.base.match_token(DROP, &mut recog.err_handler)?;

                        recog.base.set_state(567);
                        recog
                            .base
                            .match_token(MATERIALIZED, &mut recog.err_handler)?;

                        recog.base.set_state(568);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        recog.base.set_state(571);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(44, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(569);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(570);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(573);
                        recog.qualifiedName()?;
                    }
                }
                30 => {
                    let tmp = RenameMaterializedViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 30);
                    _localctx = tmp;
                    {
                        recog.base.set_state(574);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(575);
                        recog
                            .base
                            .match_token(MATERIALIZED, &mut recog.err_handler)?;

                        recog.base.set_state(576);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        recog.base.set_state(579);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(45, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(577);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(578);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(581);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::RenameMaterializedViewContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.from = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(582);
                        recog.base.match_token(RENAME, &mut recog.err_handler)?;

                        recog.base.set_state(583);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(584);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::RenameMaterializedViewContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.to = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                31 => {
                    let tmp = SetMaterializedViewPropertiesContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 31);
                    _localctx = tmp;
                    {
                        recog.base.set_state(586);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(587);
                        recog
                            .base
                            .match_token(MATERIALIZED, &mut recog.err_handler)?;

                        recog.base.set_state(588);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(589);
                        recog.qualifiedName()?;

                        recog.base.set_state(590);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(591);
                        recog.base.match_token(PROPERTIES, &mut recog.err_handler)?;

                        /*InvokeRule propertyAssignments*/
                        recog.base.set_state(592);
                        recog.propertyAssignments()?;
                    }
                }
                32 => {
                    let tmp = DropViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 32);
                    _localctx = tmp;
                    {
                        recog.base.set_state(594);
                        recog.base.match_token(DROP, &mut recog.err_handler)?;

                        recog.base.set_state(595);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        recog.base.set_state(598);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(46, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(596);
                                recog.base.match_token(IF, &mut recog.err_handler)?;

                                recog.base.set_state(597);
                                recog.base.match_token(EXISTS, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(600);
                        recog.qualifiedName()?;
                    }
                }
                33 => {
                    let tmp = RenameViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 33);
                    _localctx = tmp;
                    {
                        recog.base.set_state(601);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(602);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(603);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::RenameViewContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.from = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(604);
                        recog.base.match_token(RENAME, &mut recog.err_handler)?;

                        recog.base.set_state(605);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(606);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::RenameViewContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.to = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                34 => {
                    let tmp = SetViewAuthorizationContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 34);
                    _localctx = tmp;
                    {
                        recog.base.set_state(608);
                        recog.base.match_token(ALTER, &mut recog.err_handler)?;

                        recog.base.set_state(609);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(610);
                        let tmp = recog.qualifiedName()?;
                        if let StatementContextAll::SetViewAuthorizationContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.from = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(611);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(612);
                        recog
                            .base
                            .match_token(AUTHORIZATION, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(613);
                        recog.principal()?;
                    }
                }
                35 => {
                    let tmp = CallContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 35);
                    _localctx = tmp;
                    {
                        recog.base.set_state(615);
                        recog.base.match_token(CALL, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(616);
                        recog.qualifiedName()?;

                        recog.base.set_state(617);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        recog.base.set_state(626);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << T__1)
                                    | (1usize << ABSENT)
                                    | (1usize << ADD)
                                    | (1usize << ADMIN)
                                    | (1usize << AFTER)
                                    | (1usize << ALL)
                                    | (1usize << ANALYZE)
                                    | (1usize << ANY)
                                    | (1usize << ARRAY)
                                    | (1usize << ASC)
                                    | (1usize << AT)
                                    | (1usize << AUTHORIZATION)
                                    | (1usize << BERNOULLI)))
                                != 0)
                            || (((_la - 33) & !0x3f) == 0
                                && ((1usize << (_la - 33))
                                    & ((1usize << (BOTH - 33))
                                        | (1usize << (CALL - 33))
                                        | (1usize << (CASCADE - 33))
                                        | (1usize << (CASE - 33))
                                        | (1usize << (CAST - 33))
                                        | (1usize << (CATALOGS - 33))
                                        | (1usize << (COLUMN - 33))
                                        | (1usize << (COLUMNS - 33))
                                        | (1usize << (COMMENT - 33))
                                        | (1usize << (COMMIT - 33))
                                        | (1usize << (COMMITTED - 33))
                                        | (1usize << (CONDITIONAL - 33))
                                        | (1usize << (COUNT - 33))
                                        | (1usize << (COPARTITION - 33))
                                        | (1usize << (CURRENT - 33))
                                        | (1usize << (CURRENT_CATALOG - 33))
                                        | (1usize << (CURRENT_DATE - 33))
                                        | (1usize << (CURRENT_PATH - 33))
                                        | (1usize << (CURRENT_SCHEMA - 33))
                                        | (1usize << (CURRENT_TIME - 33))
                                        | (1usize << (CURRENT_TIMESTAMP - 33))
                                        | (1usize << (CURRENT_USER - 33))
                                        | (1usize << (DATA - 33))
                                        | (1usize << (DATE - 33))
                                        | (1usize << (DAY - 33))))
                                    != 0)
                            || (((_la - 66) & !0x3f) == 0
                                && ((1usize << (_la - 66))
                                    & ((1usize << (DEFAULT - 66))
                                        | (1usize << (DEFINE - 66))
                                        | (1usize << (DEFINER - 66))
                                        | (1usize << (DENY - 66))
                                        | (1usize << (DESC - 66))
                                        | (1usize << (DESCRIPTOR - 66))
                                        | (1usize << (DISTRIBUTED - 66))
                                        | (1usize << (DOUBLE - 66))
                                        | (1usize << (EMPTY - 66))
                                        | (1usize << (ENCODING - 66))
                                        | (1usize << (ERROR - 66))
                                        | (1usize << (EXCLUDING - 66))
                                        | (1usize << (EXISTS - 66))
                                        | (1usize << (EXPLAIN - 66))
                                        | (1usize << (EXTRACT - 66))
                                        | (1usize << (FALSE - 66))
                                        | (1usize << (FETCH - 66))
                                        | (1usize << (FILTER - 66))
                                        | (1usize << (FINAL - 66))
                                        | (1usize << (FIRST - 66))
                                        | (1usize << (FOLLOWING - 66))
                                        | (1usize << (FORMAT - 66))))
                                    != 0)
                            || (((_la - 100) & !0x3f) == 0
                                && ((1usize << (_la - 100))
                                    & ((1usize << (FUNCTIONS - 100))
                                        | (1usize << (GRACE - 100))
                                        | (1usize << (GRANT - 100))
                                        | (1usize << (GRANTED - 100))
                                        | (1usize << (GRANTS - 100))
                                        | (1usize << (GRAPHVIZ - 100))
                                        | (1usize << (GROUPING - 100))
                                        | (1usize << (GROUPS - 100))
                                        | (1usize << (HOUR - 100))
                                        | (1usize << (IF - 100))
                                        | (1usize << (IGNORE - 100))
                                        | (1usize << (INCLUDING - 100))
                                        | (1usize << (INITIAL - 100))
                                        | (1usize << (INPUT - 100))
                                        | (1usize << (INTERVAL - 100))
                                        | (1usize << (INVOKER - 100))
                                        | (1usize << (IO - 100))
                                        | (1usize << (ISOLATION - 100))
                                        | (1usize << (JSON - 100))
                                        | (1usize << (JSON_ARRAY - 100))
                                        | (1usize << (JSON_EXISTS - 100))
                                        | (1usize << (JSON_OBJECT - 100))
                                        | (1usize << (JSON_QUERY - 100))))
                                    != 0)
                            || (((_la - 132) & !0x3f) == 0
                                && ((1usize << (_la - 132))
                                    & ((1usize << (JSON_VALUE - 132))
                                        | (1usize << (KEEP - 132))
                                        | (1usize << (KEY - 132))
                                        | (1usize << (KEYS - 132))
                                        | (1usize << (LAST - 132))
                                        | (1usize << (LATERAL - 132))
                                        | (1usize << (LEADING - 132))
                                        | (1usize << (LEVEL - 132))
                                        | (1usize << (LIMIT - 132))
                                        | (1usize << (LISTAGG - 132))
                                        | (1usize << (LOCAL - 132))
                                        | (1usize << (LOCALTIME - 132))
                                        | (1usize << (LOCALTIMESTAMP - 132))
                                        | (1usize << (LOGICAL - 132))
                                        | (1usize << (MAP - 132))
                                        | (1usize << (MATCH - 132))
                                        | (1usize << (MATCHED - 132))
                                        | (1usize << (MATCHES - 132))
                                        | (1usize << (MATCH_RECOGNIZE - 132))
                                        | (1usize << (MATERIALIZED - 132))
                                        | (1usize << (MEASURES - 132))
                                        | (1usize << (MERGE - 132))
                                        | (1usize << (MINUTE - 132))
                                        | (1usize << (MONTH - 132))
                                        | (1usize << (NEXT - 132))
                                        | (1usize << (NFC - 132))
                                        | (1usize << (NFD - 132))
                                        | (1usize << (NFKC - 132))
                                        | (1usize << (NFKD - 132))))
                                    != 0)
                            || (((_la - 164) & !0x3f) == 0
                                && ((1usize << (_la - 164))
                                    & ((1usize << (NO - 164))
                                        | (1usize << (NONE - 164))
                                        | (1usize << (NORMALIZE - 164))
                                        | (1usize << (NOT - 164))
                                        | (1usize << (NULL - 164))
                                        | (1usize << (NULLIF - 164))
                                        | (1usize << (NULLS - 164))
                                        | (1usize << (OBJECT - 164))
                                        | (1usize << (OF - 164))
                                        | (1usize << (OFFSET - 164))
                                        | (1usize << (OMIT - 164))
                                        | (1usize << (ONE - 164))
                                        | (1usize << (ONLY - 164))
                                        | (1usize << (OPTION - 164))
                                        | (1usize << (ORDINALITY - 164))
                                        | (1usize << (OUTPUT - 164))
                                        | (1usize << (OVER - 164))
                                        | (1usize << (OVERFLOW - 164))
                                        | (1usize << (PARTITION - 164))
                                        | (1usize << (PARTITIONS - 164))
                                        | (1usize << (PASSING - 164))
                                        | (1usize << (PAST - 164))
                                        | (1usize << (PATH - 164))
                                        | (1usize << (PATTERN - 164))
                                        | (1usize << (PER - 164))
                                        | (1usize << (PERIOD - 164))
                                        | (1usize << (PERMUTE - 164))
                                        | (1usize << (POSITION - 164))))
                                    != 0)
                            || (((_la - 196) & !0x3f) == 0
                                && ((1usize << (_la - 196))
                                    & ((1usize << (PRECEDING - 196))
                                        | (1usize << (PRECISION - 196))
                                        | (1usize << (PRIVILEGES - 196))
                                        | (1usize << (PROPERTIES - 196))
                                        | (1usize << (PRUNE - 196))
                                        | (1usize << (QUOTES - 196))
                                        | (1usize << (RANGE - 196))
                                        | (1usize << (READ - 196))
                                        | (1usize << (REFRESH - 196))
                                        | (1usize << (RENAME - 196))
                                        | (1usize << (REPEATABLE - 196))
                                        | (1usize << (REPLACE - 196))
                                        | (1usize << (RESET - 196))
                                        | (1usize << (RESPECT - 196))
                                        | (1usize << (RESTRICT - 196))
                                        | (1usize << (RETURNING - 196))
                                        | (1usize << (REVOKE - 196))
                                        | (1usize << (ROLE - 196))
                                        | (1usize << (ROLES - 196))
                                        | (1usize << (ROLLBACK - 196))
                                        | (1usize << (ROW - 196))
                                        | (1usize << (ROWS - 196))
                                        | (1usize << (RUNNING - 196))
                                        | (1usize << (SCALAR - 196))
                                        | (1usize << (SCHEMA - 196))
                                        | (1usize << (SCHEMAS - 196))
                                        | (1usize << (SECOND - 196))
                                        | (1usize << (SECURITY - 196))))
                                    != 0)
                            || (((_la - 228) & !0x3f) == 0
                                && ((1usize << (_la - 228))
                                    & ((1usize << (SEEK - 228))
                                        | (1usize << (SERIALIZABLE - 228))
                                        | (1usize << (SESSION - 228))
                                        | (1usize << (SET - 228))
                                        | (1usize << (SETS - 228))
                                        | (1usize << (SHOW - 228))
                                        | (1usize << (SOME - 228))
                                        | (1usize << (START - 228))
                                        | (1usize << (STATS - 228))
                                        | (1usize << (SUBSET - 228))
                                        | (1usize << (SUBSTRING - 228))
                                        | (1usize << (SYSTEM - 228))
                                        | (1usize << (TABLES - 228))
                                        | (1usize << (TABLESAMPLE - 228))
                                        | (1usize << (TEXT - 228))
                                        | (1usize << (TEXT_STRING - 228))
                                        | (1usize << (TIES - 228))
                                        | (1usize << (TIME - 228))
                                        | (1usize << (TIMESTAMP - 228))
                                        | (1usize << (TO - 228))
                                        | (1usize << (TRAILING - 228))
                                        | (1usize << (TRANSACTION - 228))
                                        | (1usize << (TRIM - 228))
                                        | (1usize << (TRUE - 228))
                                        | (1usize << (TRUNCATE - 228))
                                        | (1usize << (TRY_CAST - 228))
                                        | (1usize << (TYPE - 228))
                                        | (1usize << (UNBOUNDED - 228))))
                                    != 0)
                            || (((_la - 260) & !0x3f) == 0
                                && ((1usize << (_la - 260))
                                    & ((1usize << (UNCOMMITTED - 260))
                                        | (1usize << (UNCONDITIONAL - 260))
                                        | (1usize << (UNIQUE - 260))
                                        | (1usize << (UNKNOWN - 260))
                                        | (1usize << (UNMATCHED - 260))
                                        | (1usize << (UPDATE - 260))
                                        | (1usize << (USE - 260))
                                        | (1usize << (USER - 260))
                                        | (1usize << (UTF16 - 260))
                                        | (1usize << (UTF32 - 260))
                                        | (1usize << (UTF8 - 260))
                                        | (1usize << (VALIDATE - 260))
                                        | (1usize << (VALUE - 260))
                                        | (1usize << (VERBOSE - 260))
                                        | (1usize << (VERSION - 260))
                                        | (1usize << (VIEW - 260))
                                        | (1usize << (WINDOW - 260))
                                        | (1usize << (WITHIN - 260))
                                        | (1usize << (WITHOUT - 260))
                                        | (1usize << (WORK - 260))
                                        | (1usize << (WRAPPER - 260))
                                        | (1usize << (WRITE - 260))
                                        | (1usize << (YEAR - 260))
                                        | (1usize << (ZONE - 260))))
                                    != 0)
                            || (((_la - 297) & !0x3f) == 0
                                && ((1usize << (_la - 297))
                                    & ((1usize << (PLUS - 297))
                                        | (1usize << (MINUS - 297))
                                        | (1usize << (QUESTION_MARK - 297))
                                        | (1usize << (STRING - 297))
                                        | (1usize << (UNICODE_STRING - 297))
                                        | (1usize << (BINARY_LITERAL - 297))
                                        | (1usize << (INTEGER_VALUE - 297))
                                        | (1usize << (DECIMAL_VALUE - 297))
                                        | (1usize << (DOUBLE_VALUE - 297))
                                        | (1usize << (IDENTIFIER - 297))
                                        | (1usize << (DIGIT_IDENTIFIER - 297))
                                        | (1usize << (QUOTED_IDENTIFIER - 297))
                                        | (1usize << (BACKQUOTED_IDENTIFIER - 297))))
                                    != 0)
                        {
                            {
                                /*InvokeRule callArgument*/
                                recog.base.set_state(618);
                                recog.callArgument()?;

                                recog.base.set_state(623);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(619);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule callArgument*/
                                            recog.base.set_state(620);
                                            recog.callArgument()?;
                                        }
                                    }
                                    recog.base.set_state(625);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                            }
                        }

                        recog.base.set_state(628);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                36 => {
                    let tmp = CreateRoleContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 36);
                    _localctx = tmp;
                    {
                        recog.base.set_state(630);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(631);
                        recog.base.match_token(ROLE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(632);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::CreateRoleContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.name = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(636);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(633);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                recog.base.set_state(634);
                                recog.base.match_token(ADMIN, &mut recog.err_handler)?;

                                /*InvokeRule grantor*/
                                recog.base.set_state(635);
                                recog.grantor()?;
                            }
                        }

                        recog.base.set_state(640);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == IN {
                            {
                                recog.base.set_state(638);
                                recog.base.match_token(IN, &mut recog.err_handler)?;

                                /*InvokeRule identifier*/
                                recog.base.set_state(639);
                                let tmp = recog.identifier()?;
                                if let StatementContextAll::CreateRoleContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.catalog = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }
                    }
                }
                37 => {
                    let tmp = DropRoleContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 37);
                    _localctx = tmp;
                    {
                        recog.base.set_state(642);
                        recog.base.match_token(DROP, &mut recog.err_handler)?;

                        recog.base.set_state(643);
                        recog.base.match_token(ROLE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(644);
                        let tmp = recog.identifier()?;
                        if let StatementContextAll::DropRoleContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.name = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(647);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == IN {
                            {
                                recog.base.set_state(645);
                                recog.base.match_token(IN, &mut recog.err_handler)?;

                                /*InvokeRule identifier*/
                                recog.base.set_state(646);
                                let tmp = recog.identifier()?;
                                if let StatementContextAll::DropRoleContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.catalog = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }
                    }
                }
                38 => {
                    let tmp = GrantRolesContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 38);
                    _localctx = tmp;
                    {
                        recog.base.set_state(649);
                        recog.base.match_token(GRANT, &mut recog.err_handler)?;

                        /*InvokeRule roles*/
                        recog.base.set_state(650);
                        recog.roles()?;

                        recog.base.set_state(651);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(652);
                        recog.principal()?;

                        recog.base.set_state(657);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(653);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule principal*/
                                    recog.base.set_state(654);
                                    recog.principal()?;
                                }
                            }
                            recog.base.set_state(659);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(663);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(660);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                recog.base.set_state(661);
                                recog.base.match_token(ADMIN, &mut recog.err_handler)?;

                                recog.base.set_state(662);
                                recog.base.match_token(OPTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(668);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == GRANTED {
                            {
                                recog.base.set_state(665);
                                recog
                                    .base
                                    .match_token(GRANTED, &mut recog.err_handler)?;

                                recog.base.set_state(666);
                                recog.base.match_token(BY, &mut recog.err_handler)?;

                                /*InvokeRule grantor*/
                                recog.base.set_state(667);
                                recog.grantor()?;
                            }
                        }

                        recog.base.set_state(672);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == IN {
                            {
                                recog.base.set_state(670);
                                recog.base.match_token(IN, &mut recog.err_handler)?;

                                /*InvokeRule identifier*/
                                recog.base.set_state(671);
                                let tmp = recog.identifier()?;
                                if let StatementContextAll::GrantRolesContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.catalog = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }
                    }
                }
                39 => {
                    let tmp = RevokeRolesContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 39);
                    _localctx = tmp;
                    {
                        recog.base.set_state(674);
                        recog.base.match_token(REVOKE, &mut recog.err_handler)?;

                        recog.base.set_state(678);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(56, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(675);
                                recog.base.match_token(ADMIN, &mut recog.err_handler)?;

                                recog.base.set_state(676);
                                recog.base.match_token(OPTION, &mut recog.err_handler)?;

                                recog.base.set_state(677);
                                recog.base.match_token(FOR, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule roles*/
                        recog.base.set_state(680);
                        recog.roles()?;

                        recog.base.set_state(681);
                        recog.base.match_token(FROM, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(682);
                        recog.principal()?;

                        recog.base.set_state(687);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(683);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule principal*/
                                    recog.base.set_state(684);
                                    recog.principal()?;
                                }
                            }
                            recog.base.set_state(689);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(693);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == GRANTED {
                            {
                                recog.base.set_state(690);
                                recog
                                    .base
                                    .match_token(GRANTED, &mut recog.err_handler)?;

                                recog.base.set_state(691);
                                recog.base.match_token(BY, &mut recog.err_handler)?;

                                /*InvokeRule grantor*/
                                recog.base.set_state(692);
                                recog.grantor()?;
                            }
                        }

                        recog.base.set_state(697);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == IN {
                            {
                                recog.base.set_state(695);
                                recog.base.match_token(IN, &mut recog.err_handler)?;

                                /*InvokeRule identifier*/
                                recog.base.set_state(696);
                                let tmp = recog.identifier()?;
                                if let StatementContextAll::RevokeRolesContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.catalog = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }
                    }
                }
                40 => {
                    let tmp = SetRoleContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 40);
                    _localctx = tmp;
                    {
                        recog.base.set_state(699);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(700);
                        recog.base.match_token(ROLE, &mut recog.err_handler)?;

                        recog.base.set_state(704);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(60, &mut recog.base)? {
                            1 => {
                                recog.base.set_state(701);
                                recog.base.match_token(ALL, &mut recog.err_handler)?;
                            }
                            2 => {
                                recog.base.set_state(702);
                                recog.base.match_token(NONE, &mut recog.err_handler)?;
                            }
                            3 => {
                                {
                                    /*InvokeRule identifier*/
                                    recog.base.set_state(703);
                                    let tmp = recog.identifier()?;
                                    if let StatementContextAll::SetRoleContext(ctx) =
                                        cast_mut::<_, StatementContextAll>(&mut _localctx)
                                    {
                                        ctx.role = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(708);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == IN {
                            {
                                recog.base.set_state(706);
                                recog.base.match_token(IN, &mut recog.err_handler)?;

                                /*InvokeRule identifier*/
                                recog.base.set_state(707);
                                let tmp = recog.identifier()?;
                                if let StatementContextAll::SetRoleContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.catalog = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }
                    }
                }
                41 => {
                    let tmp = GrantContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 41);
                    _localctx = tmp;
                    {
                        recog.base.set_state(710);
                        recog.base.match_token(GRANT, &mut recog.err_handler)?;

                        recog.base.set_state(721);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            CREATE | DELETE | INSERT | SELECT | UPDATE => {
                                {
                                    /*InvokeRule privilege*/
                                    recog.base.set_state(711);
                                    recog.privilege()?;

                                    recog.base.set_state(716);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(712);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule privilege*/
                                                recog.base.set_state(713);
                                                recog.privilege()?;
                                            }
                                        }
                                        recog.base.set_state(718);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            ALL => {
                                recog.base.set_state(719);
                                recog.base.match_token(ALL, &mut recog.err_handler)?;

                                recog.base.set_state(720);
                                recog
                                    .base
                                    .match_token(PRIVILEGES, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                                &mut recog.base,
                            )))?,
                        }
                        recog.base.set_state(723);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        recog.base.set_state(725);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(64, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(724);
                                _la = recog.base.input.la(1);
                                if { !(_la == SCHEMA || _la == TABLE) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(727);
                        recog.qualifiedName()?;

                        recog.base.set_state(728);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(729);
                        let tmp = recog.principal()?;
                        if let StatementContextAll::GrantContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.grantee = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(733);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WITH {
                            {
                                recog.base.set_state(730);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                recog.base.set_state(731);
                                recog.base.match_token(GRANT, &mut recog.err_handler)?;

                                recog.base.set_state(732);
                                recog.base.match_token(OPTION, &mut recog.err_handler)?;
                            }
                        }
                    }
                }
                42 => {
                    let tmp = DenyContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 42);
                    _localctx = tmp;
                    {
                        recog.base.set_state(735);
                        recog.base.match_token(DENY, &mut recog.err_handler)?;

                        recog.base.set_state(746);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            CREATE | DELETE | INSERT | SELECT | UPDATE => {
                                {
                                    /*InvokeRule privilege*/
                                    recog.base.set_state(736);
                                    recog.privilege()?;

                                    recog.base.set_state(741);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(737);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule privilege*/
                                                recog.base.set_state(738);
                                                recog.privilege()?;
                                            }
                                        }
                                        recog.base.set_state(743);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            ALL => {
                                recog.base.set_state(744);
                                recog.base.match_token(ALL, &mut recog.err_handler)?;

                                recog.base.set_state(745);
                                recog
                                    .base
                                    .match_token(PRIVILEGES, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                                &mut recog.base,
                            )))?,
                        }
                        recog.base.set_state(748);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        recog.base.set_state(750);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(68, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(749);
                                _la = recog.base.input.la(1);
                                if { !(_la == SCHEMA || _la == TABLE) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(752);
                        recog.qualifiedName()?;

                        recog.base.set_state(753);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(754);
                        let tmp = recog.principal()?;
                        if let StatementContextAll::DenyContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.grantee = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                43 => {
                    let tmp = RevokeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 43);
                    _localctx = tmp;
                    {
                        recog.base.set_state(756);
                        recog.base.match_token(REVOKE, &mut recog.err_handler)?;

                        recog.base.set_state(760);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == GRANT {
                            {
                                recog.base.set_state(757);
                                recog.base.match_token(GRANT, &mut recog.err_handler)?;

                                recog.base.set_state(758);
                                recog.base.match_token(OPTION, &mut recog.err_handler)?;

                                recog.base.set_state(759);
                                recog.base.match_token(FOR, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(772);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            CREATE | DELETE | INSERT | SELECT | UPDATE => {
                                {
                                    /*InvokeRule privilege*/
                                    recog.base.set_state(762);
                                    recog.privilege()?;

                                    recog.base.set_state(767);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(763);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule privilege*/
                                                recog.base.set_state(764);
                                                recog.privilege()?;
                                            }
                                        }
                                        recog.base.set_state(769);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            ALL => {
                                recog.base.set_state(770);
                                recog.base.match_token(ALL, &mut recog.err_handler)?;

                                recog.base.set_state(771);
                                recog
                                    .base
                                    .match_token(PRIVILEGES, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                                &mut recog.base,
                            )))?,
                        }
                        recog.base.set_state(774);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        recog.base.set_state(776);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(72, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(775);
                                _la = recog.base.input.la(1);
                                if { !(_la == SCHEMA || _la == TABLE) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                            }

                            _ => {}
                        }
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(778);
                        recog.qualifiedName()?;

                        recog.base.set_state(779);
                        recog.base.match_token(FROM, &mut recog.err_handler)?;

                        /*InvokeRule principal*/
                        recog.base.set_state(780);
                        let tmp = recog.principal()?;
                        if let StatementContextAll::RevokeContext(ctx) =
                            cast_mut::<_, StatementContextAll>(&mut _localctx)
                        {
                            ctx.grantee = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                44 => {
                    let tmp = ShowGrantsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 44);
                    _localctx = tmp;
                    {
                        recog.base.set_state(782);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(783);
                        recog.base.match_token(GRANTS, &mut recog.err_handler)?;

                        recog.base.set_state(789);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == ON {
                            {
                                recog.base.set_state(784);
                                recog.base.match_token(ON, &mut recog.err_handler)?;

                                recog.base.set_state(786);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == TABLE {
                                    {
                                        recog.base.set_state(785);
                                        recog
                                            .base
                                            .match_token(TABLE, &mut recog.err_handler)?;
                                    }
                                }

                                /*InvokeRule qualifiedName*/
                                recog.base.set_state(788);
                                recog.qualifiedName()?;
                            }
                        }
                    }
                }
                45 => {
                    let tmp = ExplainContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 45);
                    _localctx = tmp;
                    {
                        recog.base.set_state(791);
                        recog.base.match_token(EXPLAIN, &mut recog.err_handler)?;

                        recog.base.set_state(803);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(76, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(792);
                                    recog
                                        .base
                                        .match_token(T__1, &mut recog.err_handler)?;

                                    /*InvokeRule explainOption*/
                                    recog.base.set_state(793);
                                    recog.explainOption()?;

                                    recog.base.set_state(798);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(794);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule explainOption*/
                                                recog.base.set_state(795);
                                                recog.explainOption()?;
                                            }
                                        }
                                        recog.base.set_state(800);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                    recog.base.set_state(801);
                                    recog
                                        .base
                                        .match_token(T__2, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /*InvokeRule statement*/
                        recog.base.set_state(805);
                        recog.statement()?;
                    }
                }
                46 => {
                    let tmp = ExplainAnalyzeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 46);
                    _localctx = tmp;
                    {
                        recog.base.set_state(806);
                        recog.base.match_token(EXPLAIN, &mut recog.err_handler)?;

                        recog.base.set_state(807);
                        recog.base.match_token(ANALYZE, &mut recog.err_handler)?;

                        recog.base.set_state(809);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == VERBOSE {
                            {
                                recog.base.set_state(808);
                                recog
                                    .base
                                    .match_token(VERBOSE, &mut recog.err_handler)?;
                            }
                        }

                        /*InvokeRule statement*/
                        recog.base.set_state(811);
                        recog.statement()?;
                    }
                }
                47 => {
                    let tmp = ShowCreateTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 47);
                    _localctx = tmp;
                    {
                        recog.base.set_state(812);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(813);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(814);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(815);
                        recog.qualifiedName()?;
                    }
                }
                48 => {
                    let tmp = ShowCreateSchemaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 48);
                    _localctx = tmp;
                    {
                        recog.base.set_state(816);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(817);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(818);
                        recog.base.match_token(SCHEMA, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(819);
                        recog.qualifiedName()?;
                    }
                }
                49 => {
                    let tmp = ShowCreateViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 49);
                    _localctx = tmp;
                    {
                        recog.base.set_state(820);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(821);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(822);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(823);
                        recog.qualifiedName()?;
                    }
                }
                50 => {
                    let tmp = ShowCreateMaterializedViewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 50);
                    _localctx = tmp;
                    {
                        recog.base.set_state(824);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(825);
                        recog.base.match_token(CREATE, &mut recog.err_handler)?;

                        recog.base.set_state(826);
                        recog
                            .base
                            .match_token(MATERIALIZED, &mut recog.err_handler)?;

                        recog.base.set_state(827);
                        recog.base.match_token(VIEW, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(828);
                        recog.qualifiedName()?;
                    }
                }
                51 => {
                    let tmp = ShowTablesContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 51);
                    _localctx = tmp;
                    {
                        recog.base.set_state(829);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(830);
                        recog.base.match_token(TABLES, &mut recog.err_handler)?;

                        recog.base.set_state(833);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == FROM || _la == IN {
                            {
                                recog.base.set_state(831);
                                _la = recog.base.input.la(1);
                                if { !(_la == FROM || _la == IN) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /*InvokeRule qualifiedName*/
                                recog.base.set_state(832);
                                recog.qualifiedName()?;
                            }
                        }

                        recog.base.set_state(841);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == LIKE {
                            {
                                recog.base.set_state(835);
                                recog.base.match_token(LIKE, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(836);
                                let tmp = recog.string()?;
                                if let StatementContextAll::ShowTablesContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.pattern = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }

                                recog.base.set_state(839);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == ESCAPE {
                                    {
                                        recog.base.set_state(837);
                                        recog.base.match_token(
                                            ESCAPE,
                                            &mut recog.err_handler,
                                        )?;

                                        /*InvokeRule string*/
                                        recog.base.set_state(838);
                                        let tmp = recog.string()?;
                                        if let StatementContextAll::ShowTablesContext(
                                            ctx,
                                        ) = cast_mut::<_, StatementContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.escape = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                52 => {
                    let tmp = ShowSchemasContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 52);
                    _localctx = tmp;
                    {
                        recog.base.set_state(843);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(844);
                        recog.base.match_token(SCHEMAS, &mut recog.err_handler)?;

                        recog.base.set_state(847);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == FROM || _la == IN {
                            {
                                recog.base.set_state(845);
                                _la = recog.base.input.la(1);
                                if { !(_la == FROM || _la == IN) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /*InvokeRule identifier*/
                                recog.base.set_state(846);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(855);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == LIKE {
                            {
                                recog.base.set_state(849);
                                recog.base.match_token(LIKE, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(850);
                                let tmp = recog.string()?;
                                if let StatementContextAll::ShowSchemasContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.pattern = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }

                                recog.base.set_state(853);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == ESCAPE {
                                    {
                                        recog.base.set_state(851);
                                        recog.base.match_token(
                                            ESCAPE,
                                            &mut recog.err_handler,
                                        )?;

                                        /*InvokeRule string*/
                                        recog.base.set_state(852);
                                        let tmp = recog.string()?;
                                        if let StatementContextAll::ShowSchemasContext(
                                            ctx,
                                        ) = cast_mut::<_, StatementContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.escape = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                53 => {
                    let tmp = ShowCatalogsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 53);
                    _localctx = tmp;
                    {
                        recog.base.set_state(857);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(858);
                        recog.base.match_token(CATALOGS, &mut recog.err_handler)?;

                        recog.base.set_state(865);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == LIKE {
                            {
                                recog.base.set_state(859);
                                recog.base.match_token(LIKE, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(860);
                                let tmp = recog.string()?;
                                if let StatementContextAll::ShowCatalogsContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.pattern = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }

                                recog.base.set_state(863);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == ESCAPE {
                                    {
                                        recog.base.set_state(861);
                                        recog.base.match_token(
                                            ESCAPE,
                                            &mut recog.err_handler,
                                        )?;

                                        /*InvokeRule string*/
                                        recog.base.set_state(862);
                                        let tmp = recog.string()?;
                                        if let StatementContextAll::ShowCatalogsContext(
                                            ctx,
                                        ) = cast_mut::<_, StatementContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.escape = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                54 => {
                    let tmp = ShowColumnsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 54);
                    _localctx = tmp;
                    {
                        recog.base.set_state(867);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(868);
                        recog.base.match_token(COLUMNS, &mut recog.err_handler)?;

                        recog.base.set_state(869);
                        _la = recog.base.input.la(1);
                        if { !(_la == FROM || _la == IN) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        recog.base.set_state(871);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << ABSENT)
                                    | (1usize << ADD)
                                    | (1usize << ADMIN)
                                    | (1usize << AFTER)
                                    | (1usize << ALL)
                                    | (1usize << ANALYZE)
                                    | (1usize << ANY)
                                    | (1usize << ARRAY)
                                    | (1usize << ASC)
                                    | (1usize << AT)
                                    | (1usize << AUTHORIZATION)
                                    | (1usize << BERNOULLI)))
                                != 0)
                            || (((_la - 33) & !0x3f) == 0
                                && ((1usize << (_la - 33))
                                    & ((1usize << (BOTH - 33))
                                        | (1usize << (CALL - 33))
                                        | (1usize << (CASCADE - 33))
                                        | (1usize << (CATALOGS - 33))
                                        | (1usize << (COLUMN - 33))
                                        | (1usize << (COLUMNS - 33))
                                        | (1usize << (COMMENT - 33))
                                        | (1usize << (COMMIT - 33))
                                        | (1usize << (COMMITTED - 33))
                                        | (1usize << (CONDITIONAL - 33))
                                        | (1usize << (COUNT - 33))
                                        | (1usize << (COPARTITION - 33))
                                        | (1usize << (CURRENT - 33))
                                        | (1usize << (DATA - 33))
                                        | (1usize << (DATE - 33))
                                        | (1usize << (DAY - 33))))
                                    != 0)
                            || (((_la - 66) & !0x3f) == 0
                                && ((1usize << (_la - 66))
                                    & ((1usize << (DEFAULT - 66))
                                        | (1usize << (DEFINE - 66))
                                        | (1usize << (DEFINER - 66))
                                        | (1usize << (DENY - 66))
                                        | (1usize << (DESC - 66))
                                        | (1usize << (DESCRIPTOR - 66))
                                        | (1usize << (DISTRIBUTED - 66))
                                        | (1usize << (DOUBLE - 66))
                                        | (1usize << (EMPTY - 66))
                                        | (1usize << (ENCODING - 66))
                                        | (1usize << (ERROR - 66))
                                        | (1usize << (EXCLUDING - 66))
                                        | (1usize << (EXPLAIN - 66))
                                        | (1usize << (FETCH - 66))
                                        | (1usize << (FILTER - 66))
                                        | (1usize << (FINAL - 66))
                                        | (1usize << (FIRST - 66))
                                        | (1usize << (FOLLOWING - 66))
                                        | (1usize << (FORMAT - 66))))
                                    != 0)
                            || (((_la - 100) & !0x3f) == 0
                                && ((1usize << (_la - 100))
                                    & ((1usize << (FUNCTIONS - 100))
                                        | (1usize << (GRACE - 100))
                                        | (1usize << (GRANT - 100))
                                        | (1usize << (GRANTED - 100))
                                        | (1usize << (GRANTS - 100))
                                        | (1usize << (GRAPHVIZ - 100))
                                        | (1usize << (GROUPS - 100))
                                        | (1usize << (HOUR - 100))
                                        | (1usize << (IF - 100))
                                        | (1usize << (IGNORE - 100))
                                        | (1usize << (INCLUDING - 100))
                                        | (1usize << (INITIAL - 100))
                                        | (1usize << (INPUT - 100))
                                        | (1usize << (INTERVAL - 100))
                                        | (1usize << (INVOKER - 100))
                                        | (1usize << (IO - 100))
                                        | (1usize << (ISOLATION - 100))
                                        | (1usize << (JSON - 100))))
                                    != 0)
                            || (((_la - 133) & !0x3f) == 0
                                && ((1usize << (_la - 133))
                                    & ((1usize << (KEEP - 133))
                                        | (1usize << (KEY - 133))
                                        | (1usize << (KEYS - 133))
                                        | (1usize << (LAST - 133))
                                        | (1usize << (LATERAL - 133))
                                        | (1usize << (LEADING - 133))
                                        | (1usize << (LEVEL - 133))
                                        | (1usize << (LIMIT - 133))
                                        | (1usize << (LOCAL - 133))
                                        | (1usize << (LOGICAL - 133))
                                        | (1usize << (MAP - 133))
                                        | (1usize << (MATCH - 133))
                                        | (1usize << (MATCHED - 133))
                                        | (1usize << (MATCHES - 133))
                                        | (1usize << (MATCH_RECOGNIZE - 133))
                                        | (1usize << (MATERIALIZED - 133))
                                        | (1usize << (MEASURES - 133))
                                        | (1usize << (MERGE - 133))
                                        | (1usize << (MINUTE - 133))
                                        | (1usize << (MONTH - 133))
                                        | (1usize << (NEXT - 133))
                                        | (1usize << (NFC - 133))
                                        | (1usize << (NFD - 133))
                                        | (1usize << (NFKC - 133))
                                        | (1usize << (NFKD - 133))
                                        | (1usize << (NO - 133))))
                                    != 0)
                            || (((_la - 165) & !0x3f) == 0
                                && ((1usize << (_la - 165))
                                    & ((1usize << (NONE - 165))
                                        | (1usize << (NULLIF - 165))
                                        | (1usize << (NULLS - 165))
                                        | (1usize << (OBJECT - 165))
                                        | (1usize << (OF - 165))
                                        | (1usize << (OFFSET - 165))
                                        | (1usize << (OMIT - 165))
                                        | (1usize << (ONE - 165))
                                        | (1usize << (ONLY - 165))
                                        | (1usize << (OPTION - 165))
                                        | (1usize << (ORDINALITY - 165))
                                        | (1usize << (OUTPUT - 165))
                                        | (1usize << (OVER - 165))
                                        | (1usize << (OVERFLOW - 165))
                                        | (1usize << (PARTITION - 165))
                                        | (1usize << (PARTITIONS - 165))
                                        | (1usize << (PASSING - 165))
                                        | (1usize << (PAST - 165))
                                        | (1usize << (PATH - 165))
                                        | (1usize << (PATTERN - 165))
                                        | (1usize << (PER - 165))
                                        | (1usize << (PERIOD - 165))
                                        | (1usize << (PERMUTE - 165))
                                        | (1usize << (POSITION - 165))
                                        | (1usize << (PRECEDING - 165))))
                                    != 0)
                            || (((_la - 197) & !0x3f) == 0
                                && ((1usize << (_la - 197))
                                    & ((1usize << (PRECISION - 197))
                                        | (1usize << (PRIVILEGES - 197))
                                        | (1usize << (PROPERTIES - 197))
                                        | (1usize << (PRUNE - 197))
                                        | (1usize << (QUOTES - 197))
                                        | (1usize << (RANGE - 197))
                                        | (1usize << (READ - 197))
                                        | (1usize << (REFRESH - 197))
                                        | (1usize << (RENAME - 197))
                                        | (1usize << (REPEATABLE - 197))
                                        | (1usize << (REPLACE - 197))
                                        | (1usize << (RESET - 197))
                                        | (1usize << (RESPECT - 197))
                                        | (1usize << (RESTRICT - 197))
                                        | (1usize << (RETURNING - 197))
                                        | (1usize << (REVOKE - 197))
                                        | (1usize << (ROLE - 197))
                                        | (1usize << (ROLES - 197))
                                        | (1usize << (ROLLBACK - 197))
                                        | (1usize << (ROW - 197))
                                        | (1usize << (ROWS - 197))
                                        | (1usize << (RUNNING - 197))
                                        | (1usize << (SCALAR - 197))
                                        | (1usize << (SCHEMA - 197))
                                        | (1usize << (SCHEMAS - 197))
                                        | (1usize << (SECOND - 197))
                                        | (1usize << (SECURITY - 197))
                                        | (1usize << (SEEK - 197))))
                                    != 0)
                            || (((_la - 230) & !0x3f) == 0
                                && ((1usize << (_la - 230))
                                    & ((1usize << (SERIALIZABLE - 230))
                                        | (1usize << (SESSION - 230))
                                        | (1usize << (SET - 230))
                                        | (1usize << (SETS - 230))
                                        | (1usize << (SHOW - 230))
                                        | (1usize << (SOME - 230))
                                        | (1usize << (START - 230))
                                        | (1usize << (STATS - 230))
                                        | (1usize << (SUBSET - 230))
                                        | (1usize << (SUBSTRING - 230))
                                        | (1usize << (SYSTEM - 230))
                                        | (1usize << (TABLES - 230))
                                        | (1usize << (TABLESAMPLE - 230))
                                        | (1usize << (TEXT - 230))
                                        | (1usize << (TEXT_STRING - 230))
                                        | (1usize << (TIES - 230))
                                        | (1usize << (TIME - 230))
                                        | (1usize << (TIMESTAMP - 230))
                                        | (1usize << (TO - 230))
                                        | (1usize << (TRAILING - 230))
                                        | (1usize << (TRANSACTION - 230))
                                        | (1usize << (TRUNCATE - 230))
                                        | (1usize << (TRY_CAST - 230))
                                        | (1usize << (TYPE - 230))
                                        | (1usize << (UNBOUNDED - 230))
                                        | (1usize << (UNCOMMITTED - 230))
                                        | (1usize << (UNCONDITIONAL - 230))))
                                    != 0)
                            || (((_la - 263) & !0x3f) == 0
                                && ((1usize << (_la - 263))
                                    & ((1usize << (UNIQUE - 263))
                                        | (1usize << (UNKNOWN - 263))
                                        | (1usize << (UNMATCHED - 263))
                                        | (1usize << (UPDATE - 263))
                                        | (1usize << (USE - 263))
                                        | (1usize << (USER - 263))
                                        | (1usize << (UTF16 - 263))
                                        | (1usize << (UTF32 - 263))
                                        | (1usize << (UTF8 - 263))
                                        | (1usize << (VALIDATE - 263))
                                        | (1usize << (VALUE - 263))
                                        | (1usize << (VERBOSE - 263))
                                        | (1usize << (VERSION - 263))
                                        | (1usize << (VIEW - 263))
                                        | (1usize << (WINDOW - 263))
                                        | (1usize << (WITHIN - 263))
                                        | (1usize << (WITHOUT - 263))
                                        | (1usize << (WORK - 263))
                                        | (1usize << (WRAPPER - 263))
                                        | (1usize << (WRITE - 263))
                                        | (1usize << (YEAR - 263))
                                        | (1usize << (ZONE - 263))))
                                    != 0)
                            || (((_la - 310) & !0x3f) == 0
                                && ((1usize << (_la - 310))
                                    & ((1usize << (IDENTIFIER - 310))
                                        | (1usize << (DIGIT_IDENTIFIER - 310))
                                        | (1usize << (QUOTED_IDENTIFIER - 310))
                                        | (1usize << (BACKQUOTED_IDENTIFIER - 310))))
                                    != 0)
                        {
                            {
                                /*InvokeRule qualifiedName*/
                                recog.base.set_state(870);
                                recog.qualifiedName()?;
                            }
                        }

                        recog.base.set_state(879);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == LIKE {
                            {
                                recog.base.set_state(873);
                                recog.base.match_token(LIKE, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(874);
                                let tmp = recog.string()?;
                                if let StatementContextAll::ShowColumnsContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.pattern = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }

                                recog.base.set_state(877);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == ESCAPE {
                                    {
                                        recog.base.set_state(875);
                                        recog.base.match_token(
                                            ESCAPE,
                                            &mut recog.err_handler,
                                        )?;

                                        /*InvokeRule string*/
                                        recog.base.set_state(876);
                                        let tmp = recog.string()?;
                                        if let StatementContextAll::ShowColumnsContext(
                                            ctx,
                                        ) = cast_mut::<_, StatementContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.escape = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                55 => {
                    let tmp = ShowStatsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 55);
                    _localctx = tmp;
                    {
                        recog.base.set_state(881);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(882);
                        recog.base.match_token(STATS, &mut recog.err_handler)?;

                        recog.base.set_state(883);
                        recog.base.match_token(FOR, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(884);
                        recog.qualifiedName()?;
                    }
                }
                56 => {
                    let tmp = ShowStatsForQueryContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 56);
                    _localctx = tmp;
                    {
                        recog.base.set_state(885);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(886);
                        recog.base.match_token(STATS, &mut recog.err_handler)?;

                        recog.base.set_state(887);
                        recog.base.match_token(FOR, &mut recog.err_handler)?;

                        recog.base.set_state(888);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(889);
                        recog.query()?;

                        recog.base.set_state(890);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                57 => {
                    let tmp = ShowRolesContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 57);
                    _localctx = tmp;
                    {
                        recog.base.set_state(892);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(894);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == CURRENT {
                            {
                                recog.base.set_state(893);
                                recog
                                    .base
                                    .match_token(CURRENT, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(896);
                        recog.base.match_token(ROLES, &mut recog.err_handler)?;

                        recog.base.set_state(899);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == FROM || _la == IN {
                            {
                                recog.base.set_state(897);
                                _la = recog.base.input.la(1);
                                if { !(_la == FROM || _la == IN) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /*InvokeRule identifier*/
                                recog.base.set_state(898);
                                recog.identifier()?;
                            }
                        }
                    }
                }
                58 => {
                    let tmp = ShowRoleGrantsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 58);
                    _localctx = tmp;
                    {
                        recog.base.set_state(901);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(902);
                        recog.base.match_token(ROLE, &mut recog.err_handler)?;

                        recog.base.set_state(903);
                        recog.base.match_token(GRANTS, &mut recog.err_handler)?;

                        recog.base.set_state(906);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == FROM || _la == IN {
                            {
                                recog.base.set_state(904);
                                _la = recog.base.input.la(1);
                                if { !(_la == FROM || _la == IN) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /*InvokeRule identifier*/
                                recog.base.set_state(905);
                                recog.identifier()?;
                            }
                        }
                    }
                }
                59 => {
                    let tmp = ShowColumnsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 59);
                    _localctx = tmp;
                    {
                        recog.base.set_state(908);
                        recog.base.match_token(DESCRIBE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(909);
                        recog.qualifiedName()?;
                    }
                }
                60 => {
                    let tmp = ShowColumnsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 60);
                    _localctx = tmp;
                    {
                        recog.base.set_state(910);
                        recog.base.match_token(DESC, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(911);
                        recog.qualifiedName()?;
                    }
                }
                61 => {
                    let tmp = ShowFunctionsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 61);
                    _localctx = tmp;
                    {
                        recog.base.set_state(912);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(913);
                        recog.base.match_token(FUNCTIONS, &mut recog.err_handler)?;

                        recog.base.set_state(920);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == LIKE {
                            {
                                recog.base.set_state(914);
                                recog.base.match_token(LIKE, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(915);
                                let tmp = recog.string()?;
                                if let StatementContextAll::ShowFunctionsContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.pattern = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }

                                recog.base.set_state(918);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == ESCAPE {
                                    {
                                        recog.base.set_state(916);
                                        recog.base.match_token(
                                            ESCAPE,
                                            &mut recog.err_handler,
                                        )?;

                                        /*InvokeRule string*/
                                        recog.base.set_state(917);
                                        let tmp = recog.string()?;
                                        if let StatementContextAll::ShowFunctionsContext(
                                            ctx,
                                        ) = cast_mut::<_, StatementContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.escape = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                62 => {
                    let tmp = ShowSessionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 62);
                    _localctx = tmp;
                    {
                        recog.base.set_state(922);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(923);
                        recog.base.match_token(SESSION, &mut recog.err_handler)?;

                        recog.base.set_state(930);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == LIKE {
                            {
                                recog.base.set_state(924);
                                recog.base.match_token(LIKE, &mut recog.err_handler)?;

                                /*InvokeRule string*/
                                recog.base.set_state(925);
                                let tmp = recog.string()?;
                                if let StatementContextAll::ShowSessionContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.pattern = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }

                                recog.base.set_state(928);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == ESCAPE {
                                    {
                                        recog.base.set_state(926);
                                        recog.base.match_token(
                                            ESCAPE,
                                            &mut recog.err_handler,
                                        )?;

                                        /*InvokeRule string*/
                                        recog.base.set_state(927);
                                        let tmp = recog.string()?;
                                        if let StatementContextAll::ShowSessionContext(
                                            ctx,
                                        ) = cast_mut::<_, StatementContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.escape = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                63 => {
                    let tmp = SetSessionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 63);
                    _localctx = tmp;
                    {
                        recog.base.set_state(932);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(933);
                        recog.base.match_token(SESSION, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(934);
                        recog.qualifiedName()?;

                        recog.base.set_state(935);
                        recog.base.match_token(EQ, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(936);
                        recog.expression()?;
                    }
                }
                64 => {
                    let tmp = ResetSessionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 64);
                    _localctx = tmp;
                    {
                        recog.base.set_state(938);
                        recog.base.match_token(RESET, &mut recog.err_handler)?;

                        recog.base.set_state(939);
                        recog.base.match_token(SESSION, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(940);
                        recog.qualifiedName()?;
                    }
                }
                65 => {
                    let tmp = StartTransactionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 65);
                    _localctx = tmp;
                    {
                        recog.base.set_state(941);
                        recog.base.match_token(START, &mut recog.err_handler)?;

                        recog.base.set_state(942);
                        recog
                            .base
                            .match_token(TRANSACTION, &mut recog.err_handler)?;

                        recog.base.set_state(951);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == ISOLATION || _la == READ {
                            {
                                /*InvokeRule transactionMode*/
                                recog.base.set_state(943);
                                recog.transactionMode()?;

                                recog.base.set_state(948);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(944);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule transactionMode*/
                                            recog.base.set_state(945);
                                            recog.transactionMode()?;
                                        }
                                    }
                                    recog.base.set_state(950);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                            }
                        }
                    }
                }
                66 => {
                    let tmp = CommitContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 66);
                    _localctx = tmp;
                    {
                        recog.base.set_state(953);
                        recog.base.match_token(COMMIT, &mut recog.err_handler)?;

                        recog.base.set_state(955);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WORK {
                            {
                                recog.base.set_state(954);
                                recog.base.match_token(WORK, &mut recog.err_handler)?;
                            }
                        }
                    }
                }
                67 => {
                    let tmp = RollbackContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 67);
                    _localctx = tmp;
                    {
                        recog.base.set_state(957);
                        recog.base.match_token(ROLLBACK, &mut recog.err_handler)?;

                        recog.base.set_state(959);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WORK {
                            {
                                recog.base.set_state(958);
                                recog.base.match_token(WORK, &mut recog.err_handler)?;
                            }
                        }
                    }
                }
                68 => {
                    let tmp = PrepareContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 68);
                    _localctx = tmp;
                    {
                        recog.base.set_state(961);
                        recog.base.match_token(PREPARE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(962);
                        recog.identifier()?;

                        recog.base.set_state(963);
                        recog.base.match_token(FROM, &mut recog.err_handler)?;

                        /*InvokeRule statement*/
                        recog.base.set_state(964);
                        recog.statement()?;
                    }
                }
                69 => {
                    let tmp = DeallocateContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 69);
                    _localctx = tmp;
                    {
                        recog.base.set_state(966);
                        recog.base.match_token(DEALLOCATE, &mut recog.err_handler)?;

                        recog.base.set_state(967);
                        recog.base.match_token(PREPARE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(968);
                        recog.identifier()?;
                    }
                }
                70 => {
                    let tmp = ExecuteContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 70);
                    _localctx = tmp;
                    {
                        recog.base.set_state(969);
                        recog.base.match_token(EXECUTE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(970);
                        recog.identifier()?;

                        recog.base.set_state(980);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == USING {
                            {
                                recog.base.set_state(971);
                                recog.base.match_token(USING, &mut recog.err_handler)?;

                                /*InvokeRule expression*/
                                recog.base.set_state(972);
                                recog.expression()?;

                                recog.base.set_state(977);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(973);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule expression*/
                                            recog.base.set_state(974);
                                            recog.expression()?;
                                        }
                                    }
                                    recog.base.set_state(979);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                            }
                        }
                    }
                }
                71 => {
                    let tmp = DescribeInputContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 71);
                    _localctx = tmp;
                    {
                        recog.base.set_state(982);
                        recog.base.match_token(DESCRIBE, &mut recog.err_handler)?;

                        recog.base.set_state(983);
                        recog.base.match_token(INPUT, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(984);
                        recog.identifier()?;
                    }
                }
                72 => {
                    let tmp = DescribeOutputContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 72);
                    _localctx = tmp;
                    {
                        recog.base.set_state(985);
                        recog.base.match_token(DESCRIBE, &mut recog.err_handler)?;

                        recog.base.set_state(986);
                        recog.base.match_token(OUTPUT, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(987);
                        recog.identifier()?;
                    }
                }
                73 => {
                    let tmp = SetPathContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 73);
                    _localctx = tmp;
                    {
                        recog.base.set_state(988);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(989);
                        recog.base.match_token(PATH, &mut recog.err_handler)?;

                        /*InvokeRule pathSpecification*/
                        recog.base.set_state(990);
                        recog.pathSpecification()?;
                    }
                }
                74 => {
                    let tmp = SetTimeZoneContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 74);
                    _localctx = tmp;
                    {
                        recog.base.set_state(991);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        recog.base.set_state(992);
                        recog.base.match_token(TIME, &mut recog.err_handler)?;

                        recog.base.set_state(993);
                        recog.base.match_token(ZONE, &mut recog.err_handler)?;

                        recog.base.set_state(996);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(102, &mut recog.base)? {
                            1 => {
                                recog.base.set_state(994);
                                recog.base.match_token(LOCAL, &mut recog.err_handler)?;
                            }
                            2 => {
                                {
                                    /*InvokeRule expression*/
                                    recog.base.set_state(995);
                                    recog.expression()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                75 => {
                    let tmp = UpdateContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 75);
                    _localctx = tmp;
                    {
                        recog.base.set_state(998);
                        recog.base.match_token(UPDATE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(999);
                        recog.qualifiedName()?;

                        recog.base.set_state(1000);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        /*InvokeRule updateAssignment*/
                        recog.base.set_state(1001);
                        recog.updateAssignment()?;

                        recog.base.set_state(1006);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1002);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule updateAssignment*/
                                    recog.base.set_state(1003);
                                    recog.updateAssignment()?;
                                }
                            }
                            recog.base.set_state(1008);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1011);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == WHERE {
                            {
                                recog.base.set_state(1009);
                                recog.base.match_token(WHERE, &mut recog.err_handler)?;

                                /*InvokeRule booleanExpression*/
                                recog.base.set_state(1010);
                                let tmp = recog.booleanExpression_rec(0)?;
                                if let StatementContextAll::UpdateContext(ctx) =
                                    cast_mut::<_, StatementContextAll>(&mut _localctx)
                                {
                                    ctx.where_ = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }
                    }
                }
                76 => {
                    let tmp = MergeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 76);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1013);
                        recog.base.match_token(MERGE, &mut recog.err_handler)?;

                        recog.base.set_state(1014);
                        recog.base.match_token(INTO, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(1015);
                        recog.qualifiedName()?;

                        recog.base.set_state(1020);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << ABSENT)
                                    | (1usize << ADD)
                                    | (1usize << ADMIN)
                                    | (1usize << AFTER)
                                    | (1usize << ALL)
                                    | (1usize << ANALYZE)
                                    | (1usize << ANY)
                                    | (1usize << ARRAY)
                                    | (1usize << AS)
                                    | (1usize << ASC)
                                    | (1usize << AT)
                                    | (1usize << AUTHORIZATION)
                                    | (1usize << BERNOULLI)))
                                != 0)
                            || (((_la - 33) & !0x3f) == 0
                                && ((1usize << (_la - 33))
                                    & ((1usize << (BOTH - 33))
                                        | (1usize << (CALL - 33))
                                        | (1usize << (CASCADE - 33))
                                        | (1usize << (CATALOGS - 33))
                                        | (1usize << (COLUMN - 33))
                                        | (1usize << (COLUMNS - 33))
                                        | (1usize << (COMMENT - 33))
                                        | (1usize << (COMMIT - 33))
                                        | (1usize << (COMMITTED - 33))
                                        | (1usize << (CONDITIONAL - 33))
                                        | (1usize << (COUNT - 33))
                                        | (1usize << (COPARTITION - 33))
                                        | (1usize << (CURRENT - 33))
                                        | (1usize << (DATA - 33))
                                        | (1usize << (DATE - 33))
                                        | (1usize << (DAY - 33))))
                                    != 0)
                            || (((_la - 66) & !0x3f) == 0
                                && ((1usize << (_la - 66))
                                    & ((1usize << (DEFAULT - 66))
                                        | (1usize << (DEFINE - 66))
                                        | (1usize << (DEFINER - 66))
                                        | (1usize << (DENY - 66))
                                        | (1usize << (DESC - 66))
                                        | (1usize << (DESCRIPTOR - 66))
                                        | (1usize << (DISTRIBUTED - 66))
                                        | (1usize << (DOUBLE - 66))
                                        | (1usize << (EMPTY - 66))
                                        | (1usize << (ENCODING - 66))
                                        | (1usize << (ERROR - 66))
                                        | (1usize << (EXCLUDING - 66))
                                        | (1usize << (EXPLAIN - 66))
                                        | (1usize << (FETCH - 66))
                                        | (1usize << (FILTER - 66))
                                        | (1usize << (FINAL - 66))
                                        | (1usize << (FIRST - 66))
                                        | (1usize << (FOLLOWING - 66))
                                        | (1usize << (FORMAT - 66))))
                                    != 0)
                            || (((_la - 100) & !0x3f) == 0
                                && ((1usize << (_la - 100))
                                    & ((1usize << (FUNCTIONS - 100))
                                        | (1usize << (GRACE - 100))
                                        | (1usize << (GRANT - 100))
                                        | (1usize << (GRANTED - 100))
                                        | (1usize << (GRANTS - 100))
                                        | (1usize << (GRAPHVIZ - 100))
                                        | (1usize << (GROUPS - 100))
                                        | (1usize << (HOUR - 100))
                                        | (1usize << (IF - 100))
                                        | (1usize << (IGNORE - 100))
                                        | (1usize << (INCLUDING - 100))
                                        | (1usize << (INITIAL - 100))
                                        | (1usize << (INPUT - 100))
                                        | (1usize << (INTERVAL - 100))
                                        | (1usize << (INVOKER - 100))
                                        | (1usize << (IO - 100))
                                        | (1usize << (ISOLATION - 100))
                                        | (1usize << (JSON - 100))))
                                    != 0)
                            || (((_la - 133) & !0x3f) == 0
                                && ((1usize << (_la - 133))
                                    & ((1usize << (KEEP - 133))
                                        | (1usize << (KEY - 133))
                                        | (1usize << (KEYS - 133))
                                        | (1usize << (LAST - 133))
                                        | (1usize << (LATERAL - 133))
                                        | (1usize << (LEADING - 133))
                                        | (1usize << (LEVEL - 133))
                                        | (1usize << (LIMIT - 133))
                                        | (1usize << (LOCAL - 133))
                                        | (1usize << (LOGICAL - 133))
                                        | (1usize << (MAP - 133))
                                        | (1usize << (MATCH - 133))
                                        | (1usize << (MATCHED - 133))
                                        | (1usize << (MATCHES - 133))
                                        | (1usize << (MATCH_RECOGNIZE - 133))
                                        | (1usize << (MATERIALIZED - 133))
                                        | (1usize << (MEASURES - 133))
                                        | (1usize << (MERGE - 133))
                                        | (1usize << (MINUTE - 133))
                                        | (1usize << (MONTH - 133))
                                        | (1usize << (NEXT - 133))
                                        | (1usize << (NFC - 133))
                                        | (1usize << (NFD - 133))
                                        | (1usize << (NFKC - 133))
                                        | (1usize << (NFKD - 133))
                                        | (1usize << (NO - 133))))
                                    != 0)
                            || (((_la - 165) & !0x3f) == 0
                                && ((1usize << (_la - 165))
                                    & ((1usize << (NONE - 165))
                                        | (1usize << (NULLIF - 165))
                                        | (1usize << (NULLS - 165))
                                        | (1usize << (OBJECT - 165))
                                        | (1usize << (OF - 165))
                                        | (1usize << (OFFSET - 165))
                                        | (1usize << (OMIT - 165))
                                        | (1usize << (ONE - 165))
                                        | (1usize << (ONLY - 165))
                                        | (1usize << (OPTION - 165))
                                        | (1usize << (ORDINALITY - 165))
                                        | (1usize << (OUTPUT - 165))
                                        | (1usize << (OVER - 165))
                                        | (1usize << (OVERFLOW - 165))
                                        | (1usize << (PARTITION - 165))
                                        | (1usize << (PARTITIONS - 165))
                                        | (1usize << (PASSING - 165))
                                        | (1usize << (PAST - 165))
                                        | (1usize << (PATH - 165))
                                        | (1usize << (PATTERN - 165))
                                        | (1usize << (PER - 165))
                                        | (1usize << (PERIOD - 165))
                                        | (1usize << (PERMUTE - 165))
                                        | (1usize << (POSITION - 165))
                                        | (1usize << (PRECEDING - 165))))
                                    != 0)
                            || (((_la - 197) & !0x3f) == 0
                                && ((1usize << (_la - 197))
                                    & ((1usize << (PRECISION - 197))
                                        | (1usize << (PRIVILEGES - 197))
                                        | (1usize << (PROPERTIES - 197))
                                        | (1usize << (PRUNE - 197))
                                        | (1usize << (QUOTES - 197))
                                        | (1usize << (RANGE - 197))
                                        | (1usize << (READ - 197))
                                        | (1usize << (REFRESH - 197))
                                        | (1usize << (RENAME - 197))
                                        | (1usize << (REPEATABLE - 197))
                                        | (1usize << (REPLACE - 197))
                                        | (1usize << (RESET - 197))
                                        | (1usize << (RESPECT - 197))
                                        | (1usize << (RESTRICT - 197))
                                        | (1usize << (RETURNING - 197))
                                        | (1usize << (REVOKE - 197))
                                        | (1usize << (ROLE - 197))
                                        | (1usize << (ROLES - 197))
                                        | (1usize << (ROLLBACK - 197))
                                        | (1usize << (ROW - 197))
                                        | (1usize << (ROWS - 197))
                                        | (1usize << (RUNNING - 197))
                                        | (1usize << (SCALAR - 197))
                                        | (1usize << (SCHEMA - 197))
                                        | (1usize << (SCHEMAS - 197))
                                        | (1usize << (SECOND - 197))
                                        | (1usize << (SECURITY - 197))
                                        | (1usize << (SEEK - 197))))
                                    != 0)
                            || (((_la - 230) & !0x3f) == 0
                                && ((1usize << (_la - 230))
                                    & ((1usize << (SERIALIZABLE - 230))
                                        | (1usize << (SESSION - 230))
                                        | (1usize << (SET - 230))
                                        | (1usize << (SETS - 230))
                                        | (1usize << (SHOW - 230))
                                        | (1usize << (SOME - 230))
                                        | (1usize << (START - 230))
                                        | (1usize << (STATS - 230))
                                        | (1usize << (SUBSET - 230))
                                        | (1usize << (SUBSTRING - 230))
                                        | (1usize << (SYSTEM - 230))
                                        | (1usize << (TABLES - 230))
                                        | (1usize << (TABLESAMPLE - 230))
                                        | (1usize << (TEXT - 230))
                                        | (1usize << (TEXT_STRING - 230))
                                        | (1usize << (TIES - 230))
                                        | (1usize << (TIME - 230))
                                        | (1usize << (TIMESTAMP - 230))
                                        | (1usize << (TO - 230))
                                        | (1usize << (TRAILING - 230))
                                        | (1usize << (TRANSACTION - 230))
                                        | (1usize << (TRUNCATE - 230))
                                        | (1usize << (TRY_CAST - 230))
                                        | (1usize << (TYPE - 230))
                                        | (1usize << (UNBOUNDED - 230))
                                        | (1usize << (UNCOMMITTED - 230))
                                        | (1usize << (UNCONDITIONAL - 230))))
                                    != 0)
                            || (((_la - 263) & !0x3f) == 0
                                && ((1usize << (_la - 263))
                                    & ((1usize << (UNIQUE - 263))
                                        | (1usize << (UNKNOWN - 263))
                                        | (1usize << (UNMATCHED - 263))
                                        | (1usize << (UPDATE - 263))
                                        | (1usize << (USE - 263))
                                        | (1usize << (USER - 263))
                                        | (1usize << (UTF16 - 263))
                                        | (1usize << (UTF32 - 263))
                                        | (1usize << (UTF8 - 263))
                                        | (1usize << (VALIDATE - 263))
                                        | (1usize << (VALUE - 263))
                                        | (1usize << (VERBOSE - 263))
                                        | (1usize << (VERSION - 263))
                                        | (1usize << (VIEW - 263))
                                        | (1usize << (WINDOW - 263))
                                        | (1usize << (WITHIN - 263))
                                        | (1usize << (WITHOUT - 263))
                                        | (1usize << (WORK - 263))
                                        | (1usize << (WRAPPER - 263))
                                        | (1usize << (WRITE - 263))
                                        | (1usize << (YEAR - 263))
                                        | (1usize << (ZONE - 263))))
                                    != 0)
                            || (((_la - 310) & !0x3f) == 0
                                && ((1usize << (_la - 310))
                                    & ((1usize << (IDENTIFIER - 310))
                                        | (1usize << (DIGIT_IDENTIFIER - 310))
                                        | (1usize << (QUOTED_IDENTIFIER - 310))
                                        | (1usize << (BACKQUOTED_IDENTIFIER - 310))))
                                    != 0)
                        {
                            {
                                recog.base.set_state(1017);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == AS {
                                    {
                                        recog.base.set_state(1016);
                                        recog
                                            .base
                                            .match_token(AS, &mut recog.err_handler)?;
                                    }
                                }

                                /*InvokeRule identifier*/
                                recog.base.set_state(1019);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(1022);
                        recog.base.match_token(USING, &mut recog.err_handler)?;

                        /*InvokeRule relation*/
                        recog.base.set_state(1023);
                        recog.relation_rec(0)?;

                        recog.base.set_state(1024);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(1025);
                        recog.expression()?;

                        recog.base.set_state(1027);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        loop {
                            {
                                {
                                    /*InvokeRule mergeCase*/
                                    recog.base.set_state(1026);
                                    recog.mergeCase()?;
                                }
                            }
                            recog.base.set_state(1029);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if !(_la == WHEN) {
                                break;
                            }
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- query ----------------
pub type QueryContextAll<'input> = QueryContext<'input>;

pub type QueryContext<'input> = BaseParserRuleContext<'input, QueryContextExt<'input>>;

#[derive(Clone)]
pub struct QueryContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QueryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for QueryContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_query(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_query(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for QueryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_query
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_query }
}
antlr_rust::tid! {QueryContextExt<'a>}

impl<'input> QueryContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QueryContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            QueryContextExt { ph: PhantomData },
        ))
    }
}

pub trait QueryContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QueryContextExt<'input>>
{
    fn queryNoWith(&self) -> Option<Rc<QueryNoWithContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn with(&self) -> Option<Rc<WithContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> QueryContextAttrs<'input> for QueryContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn query(&mut self) -> Result<Rc<QueryContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            QueryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_query);
        let mut _localctx: Rc<QueryContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1034);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == WITH {
                    {
                        /*InvokeRule with*/
                        recog.base.set_state(1033);
                        recog.with()?;
                    }
                }

                /*InvokeRule queryNoWith*/
                recog.base.set_state(1036);
                recog.queryNoWith()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- with ----------------
pub type WithContextAll<'input> = WithContext<'input>;

pub type WithContext<'input> = BaseParserRuleContext<'input, WithContextExt<'input>>;

#[derive(Clone)]
pub struct WithContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for WithContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for WithContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_with(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_with(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for WithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_with
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_with }
}
antlr_rust::tid! {WithContextExt<'a>}

impl<'input> WithContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<WithContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            WithContextExt { ph: PhantomData },
        ))
    }
}

pub trait WithContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<WithContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    fn namedQuery_all(&self) -> Vec<Rc<NamedQueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn namedQuery(&self, i: usize) -> Option<Rc<NamedQueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token RECURSIVE
    /// Returns `None` if there is no child corresponding to token RECURSIVE
    fn RECURSIVE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RECURSIVE, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> WithContextAttrs<'input> for WithContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn with(&mut self) -> Result<Rc<WithContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            WithContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_with);
        let mut _localctx: Rc<WithContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1038);
                recog.base.match_token(WITH, &mut recog.err_handler)?;

                recog.base.set_state(1040);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == RECURSIVE {
                    {
                        recog.base.set_state(1039);
                        recog.base.match_token(RECURSIVE, &mut recog.err_handler)?;
                    }
                }

                /*InvokeRule namedQuery*/
                recog.base.set_state(1042);
                recog.namedQuery()?;

                recog.base.set_state(1047);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA {
                    {
                        {
                            recog.base.set_state(1043);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule namedQuery*/
                            recog.base.set_state(1044);
                            recog.namedQuery()?;
                        }
                    }
                    recog.base.set_state(1049);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tableElement ----------------
pub type TableElementContextAll<'input> = TableElementContext<'input>;

pub type TableElementContext<'input> =
    BaseParserRuleContext<'input, TableElementContextExt<'input>>;

#[derive(Clone)]
pub struct TableElementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TableElementContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableElementContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableElement(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_tableElement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableElementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tableElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tableElement }
}
antlr_rust::tid! {TableElementContextExt<'a>}

impl<'input> TableElementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TableElementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            TableElementContextExt { ph: PhantomData },
        ))
    }
}

pub trait TableElementContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TableElementContextExt<'input>>
{
    fn columnDefinition(&self) -> Option<Rc<ColumnDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn likeClause(&self) -> Option<Rc<LikeClauseContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TableElementContextAttrs<'input> for TableElementContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tableElement(
        &mut self,
    ) -> Result<Rc<TableElementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            TableElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 16, RULE_tableElement);
        let mut _localctx: Rc<TableElementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1052);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ABSENT
                | ADD
                | ADMIN
                | AFTER
                | ALL
                | ANALYZE
                | ANY
                | ARRAY
                | ASC
                | AT
                | AUTHORIZATION
                | BERNOULLI
                | BOTH
                | CALL
                | CASCADE
                | CATALOGS
                | COLUMN
                | COLUMNS
                | COMMENT
                | COMMIT
                | COMMITTED
                | CONDITIONAL
                | COUNT
                | COPARTITION
                | CURRENT
                | DATA
                | DATE
                | DAY
                | DEFAULT
                | DEFINE
                | DEFINER
                | DENY
                | DESC
                | DESCRIPTOR
                | DISTRIBUTED
                | DOUBLE
                | EMPTY
                | ENCODING
                | ERROR
                | EXCLUDING
                | EXPLAIN
                | FETCH
                | FILTER
                | FINAL
                | FIRST
                | FOLLOWING
                | FORMAT
                | FUNCTIONS
                | GRACE
                | GRANT
                | GRANTED
                | GRANTS
                | GRAPHVIZ
                | GROUPS
                | HOUR
                | IF
                | IGNORE
                | INCLUDING
                | INITIAL
                | INPUT
                | INTERVAL
                | INVOKER
                | IO
                | ISOLATION
                | JSON
                | KEEP
                | KEY
                | KEYS
                | LAST
                | LATERAL
                | LEADING
                | LEVEL
                | LIMIT
                | LOCAL
                | LOGICAL
                | MAP
                | MATCH
                | MATCHED
                | MATCHES
                | MATCH_RECOGNIZE
                | MATERIALIZED
                | MEASURES
                | MERGE
                | MINUTE
                | MONTH
                | NEXT
                | NFC
                | NFD
                | NFKC
                | NFKD
                | NO
                | NONE
                | NULLIF
                | NULLS
                | OBJECT
                | OF
                | OFFSET
                | OMIT
                | ONE
                | ONLY
                | OPTION
                | ORDINALITY
                | OUTPUT
                | OVER
                | OVERFLOW
                | PARTITION
                | PARTITIONS
                | PASSING
                | PAST
                | PATH
                | PATTERN
                | PER
                | PERIOD
                | PERMUTE
                | POSITION
                | PRECEDING
                | PRECISION
                | PRIVILEGES
                | PROPERTIES
                | PRUNE
                | QUOTES
                | RANGE
                | READ
                | REFRESH
                | RENAME
                | REPEATABLE
                | REPLACE
                | RESET
                | RESPECT
                | RESTRICT
                | RETURNING
                | REVOKE
                | ROLE
                | ROLES
                | ROLLBACK
                | ROW
                | ROWS
                | RUNNING
                | SCALAR
                | SCHEMA
                | SCHEMAS
                | SECOND
                | SECURITY
                | SEEK
                | SERIALIZABLE
                | SESSION
                | SET
                | SETS
                | SHOW
                | SOME
                | START
                | STATS
                | SUBSET
                | SUBSTRING
                | SYSTEM
                | TABLES
                | TABLESAMPLE
                | TEXT
                | TEXT_STRING
                | TIES
                | TIME
                | TIMESTAMP
                | TO
                | TRAILING
                | TRANSACTION
                | TRUNCATE
                | TRY_CAST
                | TYPE
                | UNBOUNDED
                | UNCOMMITTED
                | UNCONDITIONAL
                | UNIQUE
                | UNKNOWN
                | UNMATCHED
                | UPDATE
                | USE
                | USER
                | UTF16
                | UTF32
                | UTF8
                | VALIDATE
                | VALUE
                | VERBOSE
                | VERSION
                | VIEW
                | WINDOW
                | WITHIN
                | WITHOUT
                | WORK
                | WRAPPER
                | WRITE
                | YEAR
                | ZONE
                | IDENTIFIER
                | DIGIT_IDENTIFIER
                | QUOTED_IDENTIFIER
                | BACKQUOTED_IDENTIFIER => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /*InvokeRule columnDefinition*/
                        recog.base.set_state(1050);
                        recog.columnDefinition()?;
                    }
                }

                LIKE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /*InvokeRule likeClause*/
                        recog.base.set_state(1051);
                        recog.likeClause()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- columnDefinition ----------------
pub type ColumnDefinitionContextAll<'input> = ColumnDefinitionContext<'input>;

pub type ColumnDefinitionContext<'input> =
    BaseParserRuleContext<'input, ColumnDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnDefinitionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ColumnDefinitionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ColumnDefinitionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_columnDefinition(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_columnDefinition(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ColumnDefinitionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_columnDefinition
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_columnDefinition }
}
antlr_rust::tid! {ColumnDefinitionContextExt<'a>}

impl<'input> ColumnDefinitionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ColumnDefinitionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ColumnDefinitionContextExt { ph: PhantomData },
        ))
    }
}

pub trait ColumnDefinitionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ColumnDefinitionContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ColumnDefinitionContextAttrs<'input> for ColumnDefinitionContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn columnDefinition(
        &mut self,
    ) -> Result<Rc<ColumnDefinitionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            ColumnDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 18, RULE_columnDefinition);
        let mut _localctx: Rc<ColumnDefinitionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(1054);
                recog.identifier()?;

                /*InvokeRule type_*/
                recog.base.set_state(1055);
                recog.type__rec(0)?;

                recog.base.set_state(1058);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == NOT {
                    {
                        recog.base.set_state(1056);
                        recog.base.match_token(NOT, &mut recog.err_handler)?;

                        recog.base.set_state(1057);
                        recog.base.match_token(NULL, &mut recog.err_handler)?;
                    }
                }

                recog.base.set_state(1062);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COMMENT {
                    {
                        recog.base.set_state(1060);
                        recog.base.match_token(COMMENT, &mut recog.err_handler)?;

                        /*InvokeRule string*/
                        recog.base.set_state(1061);
                        recog.string()?;
                    }
                }

                recog.base.set_state(1066);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == WITH {
                    {
                        recog.base.set_state(1064);
                        recog.base.match_token(WITH, &mut recog.err_handler)?;

                        /*InvokeRule properties*/
                        recog.base.set_state(1065);
                        recog.properties()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- likeClause ----------------
pub type LikeClauseContextAll<'input> = LikeClauseContext<'input>;

pub type LikeClauseContext<'input> =
    BaseParserRuleContext<'input, LikeClauseContextExt<'input>>;

#[derive(Clone)]
pub struct LikeClauseContextExt<'input> {
    pub optionType: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for LikeClauseContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for LikeClauseContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_likeClause(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_likeClause(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for LikeClauseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_likeClause
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_likeClause }
}
antlr_rust::tid! {LikeClauseContextExt<'a>}

impl<'input> LikeClauseContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<LikeClauseContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            LikeClauseContextExt {
                optionType: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait LikeClauseContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<LikeClauseContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PROPERTIES
    /// Returns `None` if there is no child corresponding to token PROPERTIES
    fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PROPERTIES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INCLUDING
    /// Returns `None` if there is no child corresponding to token INCLUDING
    fn INCLUDING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INCLUDING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXCLUDING
    /// Returns `None` if there is no child corresponding to token EXCLUDING
    fn EXCLUDING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXCLUDING, 0)
    }
}

impl<'input> LikeClauseContextAttrs<'input> for LikeClauseContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn likeClause(&mut self) -> Result<Rc<LikeClauseContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            LikeClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 20, RULE_likeClause);
        let mut _localctx: Rc<LikeClauseContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1068);
                recog.base.match_token(LIKE, &mut recog.err_handler)?;

                /*InvokeRule qualifiedName*/
                recog.base.set_state(1069);
                recog.qualifiedName()?;

                recog.base.set_state(1072);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == EXCLUDING || _la == INCLUDING {
                    {
                        recog.base.set_state(1070);
                        cast_mut::<_, LikeClauseContext>(&mut _localctx).optionType =
                            recog.base.input.lt(1).cloned();

                        _la = recog.base.input.la(1);
                        if { !(_la == EXCLUDING || _la == INCLUDING) } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            cast_mut::<_, LikeClauseContext>(&mut _localctx).optionType =
                                Some(&tmp);
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        recog.base.set_state(1071);
                        recog.base.match_token(PROPERTIES, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- properties ----------------
pub type PropertiesContextAll<'input> = PropertiesContext<'input>;

pub type PropertiesContext<'input> =
    BaseParserRuleContext<'input, PropertiesContextExt<'input>>;

#[derive(Clone)]
pub struct PropertiesContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PropertiesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PropertiesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_properties(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_properties(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for PropertiesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_properties
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_properties }
}
antlr_rust::tid! {PropertiesContextExt<'a>}

impl<'input> PropertiesContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PropertiesContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            PropertiesContextExt { ph: PhantomData },
        ))
    }
}

pub trait PropertiesContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PropertiesContextExt<'input>>
{
    fn propertyAssignments(&self) -> Option<Rc<PropertyAssignmentsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> PropertiesContextAttrs<'input> for PropertiesContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn properties(&mut self) -> Result<Rc<PropertiesContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PropertiesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 22, RULE_properties);
        let mut _localctx: Rc<PropertiesContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1074);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                /*InvokeRule propertyAssignments*/
                recog.base.set_state(1075);
                recog.propertyAssignments()?;

                recog.base.set_state(1076);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- propertyAssignments ----------------
pub type PropertyAssignmentsContextAll<'input> = PropertyAssignmentsContext<'input>;

pub type PropertyAssignmentsContext<'input> =
    BaseParserRuleContext<'input, PropertyAssignmentsContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyAssignmentsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PropertyAssignmentsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PropertyAssignmentsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_propertyAssignments(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_propertyAssignments(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for PropertyAssignmentsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_propertyAssignments
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_propertyAssignments }
}
antlr_rust::tid! {PropertyAssignmentsContextExt<'a>}

impl<'input> PropertyAssignmentsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PropertyAssignmentsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            PropertyAssignmentsContextExt { ph: PhantomData },
        ))
    }
}

pub trait PropertyAssignmentsContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PropertyAssignmentsContextExt<'input>>
{
    fn property_all(&self) -> Vec<Rc<PropertyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> PropertyAssignmentsContextAttrs<'input>
    for PropertyAssignmentsContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn propertyAssignments(
        &mut self,
    ) -> Result<Rc<PropertyAssignmentsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = PropertyAssignmentsContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 24, RULE_propertyAssignments);
        let mut _localctx: Rc<PropertyAssignmentsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule property*/
                recog.base.set_state(1078);
                recog.property()?;

                recog.base.set_state(1083);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA {
                    {
                        {
                            recog.base.set_state(1079);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule property*/
                            recog.base.set_state(1080);
                            recog.property()?;
                        }
                    }
                    recog.base.set_state(1085);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- property ----------------
pub type PropertyContextAll<'input> = PropertyContext<'input>;

pub type PropertyContext<'input> =
    BaseParserRuleContext<'input, PropertyContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PropertyContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for PropertyContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_property(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_property(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for PropertyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_property
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_property }
}
antlr_rust::tid! {PropertyContextExt<'a>}

impl<'input> PropertyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PropertyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            PropertyContextExt { ph: PhantomData },
        ))
    }
}

pub trait PropertyContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PropertyContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EQ
    /// Returns `None` if there is no child corresponding to token EQ
    fn EQ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EQ, 0)
    }
    fn propertyValue(&self) -> Option<Rc<PropertyValueContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> PropertyContextAttrs<'input> for PropertyContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn property(&mut self) -> Result<Rc<PropertyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PropertyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_property);
        let mut _localctx: Rc<PropertyContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(1086);
                recog.identifier()?;

                recog.base.set_state(1087);
                recog.base.match_token(EQ, &mut recog.err_handler)?;

                /*InvokeRule propertyValue*/
                recog.base.set_state(1088);
                recog.propertyValue()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- propertyValue ----------------
#[derive(Debug)]
pub enum PropertyValueContextAll<'input> {
    DefaultPropertyValueContext(DefaultPropertyValueContext<'input>),
    NonDefaultPropertyValueContext(NonDefaultPropertyValueContext<'input>),
    Error(PropertyValueContext<'input>),
}
antlr_rust::tid! {PropertyValueContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for PropertyValueContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for PropertyValueContextAll<'input> {}

impl<'input> Deref for PropertyValueContextAll<'input> {
    type Target = dyn PropertyValueContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use PropertyValueContextAll::*;
        match self {
            DefaultPropertyValueContext(inner) => inner,
            NonDefaultPropertyValueContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PropertyValueContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type PropertyValueContext<'input> =
    BaseParserRuleContext<'input, PropertyValueContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyValueContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PropertyValueContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PropertyValueContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for PropertyValueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_propertyValue
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_propertyValue }
}
antlr_rust::tid! {PropertyValueContextExt<'a>}

impl<'input> PropertyValueContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PropertyValueContextAll<'input>> {
        Rc::new(PropertyValueContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                PropertyValueContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait PropertyValueContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PropertyValueContextExt<'input>>
{
}

impl<'input> PropertyValueContextAttrs<'input> for PropertyValueContext<'input> {}

pub type DefaultPropertyValueContext<'input> =
    BaseParserRuleContext<'input, DefaultPropertyValueContextExt<'input>>;

pub trait DefaultPropertyValueContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DEFAULT
    /// Returns `None` if there is no child corresponding to token DEFAULT
    fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFAULT, 0)
    }
}

impl<'input> DefaultPropertyValueContextAttrs<'input>
    for DefaultPropertyValueContext<'input>
{
}

pub struct DefaultPropertyValueContextExt<'input> {
    base: PropertyValueContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DefaultPropertyValueContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DefaultPropertyValueContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DefaultPropertyValueContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_defaultPropertyValue(self);
    }
}

impl<'input> CustomRuleContext<'input> for DefaultPropertyValueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_propertyValue
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_propertyValue }
}

impl<'input> Borrow<PropertyValueContextExt<'input>>
    for DefaultPropertyValueContext<'input>
{
    fn borrow(&self) -> &PropertyValueContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PropertyValueContextExt<'input>>
    for DefaultPropertyValueContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PropertyValueContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PropertyValueContextAttrs<'input> for DefaultPropertyValueContext<'input> {}

impl<'input> DefaultPropertyValueContextExt<'input> {
    fn new(
        ctx: &dyn PropertyValueContextAttrs<'input>,
    ) -> Rc<PropertyValueContextAll<'input>> {
        Rc::new(PropertyValueContextAll::DefaultPropertyValueContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DefaultPropertyValueContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type NonDefaultPropertyValueContext<'input> =
    BaseParserRuleContext<'input, NonDefaultPropertyValueContextExt<'input>>;

pub trait NonDefaultPropertyValueContextAttrs<'input>:
    PrestoParserContext<'input>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> NonDefaultPropertyValueContextAttrs<'input>
    for NonDefaultPropertyValueContext<'input>
{
}

pub struct NonDefaultPropertyValueContextExt<'input> {
    base: PropertyValueContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NonDefaultPropertyValueContextExt<'a>}

impl<'input> PrestoParserContext<'input> for NonDefaultPropertyValueContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NonDefaultPropertyValueContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_nonDefaultPropertyValue(self);
    }
}

impl<'input> CustomRuleContext<'input> for NonDefaultPropertyValueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_propertyValue
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_propertyValue }
}

impl<'input> Borrow<PropertyValueContextExt<'input>>
    for NonDefaultPropertyValueContext<'input>
{
    fn borrow(&self) -> &PropertyValueContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PropertyValueContextExt<'input>>
    for NonDefaultPropertyValueContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PropertyValueContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PropertyValueContextAttrs<'input>
    for NonDefaultPropertyValueContext<'input>
{
}

impl<'input> NonDefaultPropertyValueContextExt<'input> {
    fn new(
        ctx: &dyn PropertyValueContextAttrs<'input>,
    ) -> Rc<PropertyValueContextAll<'input>> {
        Rc::new(PropertyValueContextAll::NonDefaultPropertyValueContext(
            BaseParserRuleContext::copy_from(
                ctx,
                NonDefaultPropertyValueContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn propertyValue(
        &mut self,
    ) -> Result<Rc<PropertyValueContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PropertyValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 28, RULE_propertyValue);
        let mut _localctx: Rc<PropertyValueContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1092);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(118, &mut recog.base)? {
                1 => {
                    let tmp = DefaultPropertyValueContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1090);
                        recog.base.match_token(DEFAULT, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    let tmp = NonDefaultPropertyValueContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /*InvokeRule expression*/
                        recog.base.set_state(1091);
                        recog.expression()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- queryNoWith ----------------
pub type QueryNoWithContextAll<'input> = QueryNoWithContext<'input>;

pub type QueryNoWithContext<'input> =
    BaseParserRuleContext<'input, QueryNoWithContextExt<'input>>;

#[derive(Clone)]
pub struct QueryNoWithContextExt<'input> {
    pub offset: Option<Rc<RowCountContextAll<'input>>>,
    pub limit: Option<Rc<LimitRowCountContextAll<'input>>>,
    pub fetchFirst: Option<Rc<RowCountContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QueryNoWithContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryNoWithContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_queryNoWith(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_queryNoWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for QueryNoWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryNoWith
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryNoWith }
}
antlr_rust::tid! {QueryNoWithContextExt<'a>}

impl<'input> QueryNoWithContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QueryNoWithContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            QueryNoWithContextExt {
                offset: None,
                limit: None,
                fetchFirst: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait QueryNoWithContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QueryNoWithContextExt<'input>>
{
    fn queryTerm(&self) -> Option<Rc<QueryTermContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token ORDER
    /// Returns `None` if there is no child corresponding to token ORDER
    fn ORDER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BY
    /// Returns `None` if there is no child corresponding to token BY
    fn BY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, 0)
    }
    fn sortItem_all(&self) -> Vec<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET
    /// Returns `None` if there is no child corresponding to token OFFSET
    fn OFFSET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET, 0)
    }
    fn rowCount_all(&self) -> Vec<Rc<RowCountContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn rowCount(&self, i: usize) -> Option<Rc<RowCountContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token LIMIT
    /// Returns `None` if there is no child corresponding to token LIMIT
    fn LIMIT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIMIT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FETCH
    /// Returns `None` if there is no child corresponding to token FETCH
    fn FETCH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FETCH, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn limitRowCount(&self) -> Option<Rc<LimitRowCountContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FIRST
    /// Returns `None` if there is no child corresponding to token FIRST
    fn FIRST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FIRST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NEXT
    /// Returns `None` if there is no child corresponding to token NEXT
    fn NEXT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NEXT, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token ROW in current rule
    fn ROW_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token ROW, starting from 0.
    /// Returns `None` if number of children corresponding to token ROW is less or equal than `i`.
    fn ROW(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROW, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token ROWS in current rule
    fn ROWS_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token ROWS, starting from 0.
    /// Returns `None` if number of children corresponding to token ROWS is less or equal than `i`.
    fn ROWS(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROWS, i)
    }
    /// Retrieves first TerminalNode corresponding to token ONLY
    /// Returns `None` if there is no child corresponding to token ONLY
    fn ONLY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ONLY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TIES
    /// Returns `None` if there is no child corresponding to token TIES
    fn TIES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIES, 0)
    }
}

impl<'input> QueryNoWithContextAttrs<'input> for QueryNoWithContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn queryNoWith(
        &mut self,
    ) -> Result<Rc<QueryNoWithContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            QueryNoWithContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 30, RULE_queryNoWith);
        let mut _localctx: Rc<QueryNoWithContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule queryTerm*/
                recog.base.set_state(1094);
                recog.queryTerm_rec(0)?;

                recog.base.set_state(1105);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == ORDER {
                    {
                        recog.base.set_state(1095);
                        recog.base.match_token(ORDER, &mut recog.err_handler)?;

                        recog.base.set_state(1096);
                        recog.base.match_token(BY, &mut recog.err_handler)?;

                        /*InvokeRule sortItem*/
                        recog.base.set_state(1097);
                        recog.sortItem()?;

                        recog.base.set_state(1102);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1098);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule sortItem*/
                                    recog.base.set_state(1099);
                                    recog.sortItem()?;
                                }
                            }
                            recog.base.set_state(1104);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }

                recog.base.set_state(1112);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OFFSET {
                    {
                        recog.base.set_state(1107);
                        recog.base.match_token(OFFSET, &mut recog.err_handler)?;

                        /*InvokeRule rowCount*/
                        recog.base.set_state(1108);
                        let tmp = recog.rowCount()?;
                        cast_mut::<_, QueryNoWithContext>(&mut _localctx).offset =
                            Some(tmp.clone());

                        recog.base.set_state(1110);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == ROW || _la == ROWS {
                            {
                                recog.base.set_state(1109);
                                _la = recog.base.input.la(1);
                                if { !(_la == ROW || _la == ROWS) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                            }
                        }
                    }
                }

                recog.base.set_state(1127);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    LIMIT => {
                        {
                            {
                                recog.base.set_state(1114);
                                recog.base.match_token(LIMIT, &mut recog.err_handler)?;

                                /*InvokeRule limitRowCount*/
                                recog.base.set_state(1115);
                                let tmp = recog.limitRowCount()?;
                                cast_mut::<_, QueryNoWithContext>(&mut _localctx).limit =
                                    Some(tmp.clone());
                            }
                        }
                    }

                    FETCH => {
                        {
                            {
                                recog.base.set_state(1116);
                                recog.base.match_token(FETCH, &mut recog.err_handler)?;

                                recog.base.set_state(1117);
                                _la = recog.base.input.la(1);
                                if { !(_la == FIRST || _la == NEXT) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                recog.base.set_state(1119);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == QUESTION_MARK || _la == INTEGER_VALUE {
                                    {
                                        /*InvokeRule rowCount*/
                                        recog.base.set_state(1118);
                                        let tmp = recog.rowCount()?;
                                        cast_mut::<_, QueryNoWithContext>(
                                            &mut _localctx,
                                        )
                                        .fetchFirst = Some(tmp.clone());
                                    }
                                }

                                recog.base.set_state(1121);
                                _la = recog.base.input.la(1);
                                if { !(_la == ROW || _la == ROWS) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                recog.base.set_state(1125);
                                recog.err_handler.sync(&mut recog.base)?;
                                match recog.base.input.la(1) {
                                    ONLY => {
                                        recog.base.set_state(1122);
                                        recog
                                            .base
                                            .match_token(ONLY, &mut recog.err_handler)?;
                                    }

                                    WITH => {
                                        recog.base.set_state(1123);
                                        recog
                                            .base
                                            .match_token(WITH, &mut recog.err_handler)?;

                                        recog.base.set_state(1124);
                                        recog
                                            .base
                                            .match_token(TIES, &mut recog.err_handler)?;
                                    }

                                    _ => Err(ANTLRError::NoAltError(
                                        NoViableAltError::new(&mut recog.base),
                                    ))?,
                                }
                            }
                        }
                    }

                    EOF | T__2 | WITH => {}

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- limitRowCount ----------------
pub type LimitRowCountContextAll<'input> = LimitRowCountContext<'input>;

pub type LimitRowCountContext<'input> =
    BaseParserRuleContext<'input, LimitRowCountContextExt<'input>>;

#[derive(Clone)]
pub struct LimitRowCountContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for LimitRowCountContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for LimitRowCountContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_limitRowCount(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_limitRowCount(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for LimitRowCountContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_limitRowCount
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_limitRowCount }
}
antlr_rust::tid! {LimitRowCountContextExt<'a>}

impl<'input> LimitRowCountContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<LimitRowCountContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            LimitRowCountContextExt { ph: PhantomData },
        ))
    }
}

pub trait LimitRowCountContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<LimitRowCountContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    fn rowCount(&self) -> Option<Rc<RowCountContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> LimitRowCountContextAttrs<'input> for LimitRowCountContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn limitRowCount(
        &mut self,
    ) -> Result<Rc<LimitRowCountContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            LimitRowCountContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 32, RULE_limitRowCount);
        let mut _localctx: Rc<LimitRowCountContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1131);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ALL => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1129);
                        recog.base.match_token(ALL, &mut recog.err_handler)?;
                    }
                }

                QUESTION_MARK | INTEGER_VALUE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /*InvokeRule rowCount*/
                        recog.base.set_state(1130);
                        recog.rowCount()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- rowCount ----------------
pub type RowCountContextAll<'input> = RowCountContext<'input>;

pub type RowCountContext<'input> =
    BaseParserRuleContext<'input, RowCountContextExt<'input>>;

#[derive(Clone)]
pub struct RowCountContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RowCountContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RowCountContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rowCount(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_rowCount(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for RowCountContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rowCount
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rowCount }
}
antlr_rust::tid! {RowCountContextExt<'a>}

impl<'input> RowCountContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RowCountContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            RowCountContextExt { ph: PhantomData },
        ))
    }
}

pub trait RowCountContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RowCountContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
    /// Returns `None` if there is no child corresponding to token INTEGER_VALUE
    fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER_VALUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token QUESTION_MARK
    /// Returns `None` if there is no child corresponding to token QUESTION_MARK
    fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUESTION_MARK, 0)
    }
}

impl<'input> RowCountContextAttrs<'input> for RowCountContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn rowCount(&mut self) -> Result<Rc<RowCountContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            RowCountContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_rowCount);
        let mut _localctx: Rc<RowCountContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1133);
                _la = recog.base.input.la(1);
                if { !(_la == QUESTION_MARK || _la == INTEGER_VALUE) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- queryTerm ----------------
#[derive(Debug)]
pub enum QueryTermContextAll<'input> {
    QueryTermDefaultContext(QueryTermDefaultContext<'input>),
    SetOperationContext(SetOperationContext<'input>),
    Error(QueryTermContext<'input>),
}
antlr_rust::tid! {QueryTermContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for QueryTermContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for QueryTermContextAll<'input> {}

impl<'input> Deref for QueryTermContextAll<'input> {
    type Target = dyn QueryTermContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use QueryTermContextAll::*;
        match self {
            QueryTermDefaultContext(inner) => inner,
            SetOperationContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryTermContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type QueryTermContext<'input> =
    BaseParserRuleContext<'input, QueryTermContextExt<'input>>;

#[derive(Clone)]
pub struct QueryTermContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QueryTermContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryTermContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for QueryTermContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryTerm
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryTerm }
}
antlr_rust::tid! {QueryTermContextExt<'a>}

impl<'input> QueryTermContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QueryTermContextAll<'input>> {
        Rc::new(QueryTermContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                QueryTermContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait QueryTermContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QueryTermContextExt<'input>>
{
}

impl<'input> QueryTermContextAttrs<'input> for QueryTermContext<'input> {}

pub type QueryTermDefaultContext<'input> =
    BaseParserRuleContext<'input, QueryTermDefaultContextExt<'input>>;

pub trait QueryTermDefaultContextAttrs<'input>: PrestoParserContext<'input> {
    fn queryPrimary(&self) -> Option<Rc<QueryPrimaryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> QueryTermDefaultContextAttrs<'input> for QueryTermDefaultContext<'input> {}

pub struct QueryTermDefaultContextExt<'input> {
    base: QueryTermContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {QueryTermDefaultContextExt<'a>}

impl<'input> PrestoParserContext<'input> for QueryTermDefaultContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryTermDefaultContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_queryTermDefault(self);
    }
}

impl<'input> CustomRuleContext<'input> for QueryTermDefaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryTerm
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryTerm }
}

impl<'input> Borrow<QueryTermContextExt<'input>> for QueryTermDefaultContext<'input> {
    fn borrow(&self) -> &QueryTermContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<QueryTermContextExt<'input>> for QueryTermDefaultContext<'input> {
    fn borrow_mut(&mut self) -> &mut QueryTermContextExt<'input> {
        &mut self.base
    }
}

impl<'input> QueryTermContextAttrs<'input> for QueryTermDefaultContext<'input> {}

impl<'input> QueryTermDefaultContextExt<'input> {
    fn new(ctx: &dyn QueryTermContextAttrs<'input>) -> Rc<QueryTermContextAll<'input>> {
        Rc::new(QueryTermContextAll::QueryTermDefaultContext(
            BaseParserRuleContext::copy_from(
                ctx,
                QueryTermDefaultContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SetOperationContext<'input> =
    BaseParserRuleContext<'input, SetOperationContextExt<'input>>;

pub trait SetOperationContextAttrs<'input>: PrestoParserContext<'input> {
    fn queryTerm_all(&self) -> Vec<Rc<QueryTermContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn queryTerm(&self, i: usize) -> Option<Rc<QueryTermContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token INTERSECT
    /// Returns `None` if there is no child corresponding to token INTERSECT
    fn INTERSECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTERSECT, 0)
    }
    fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token UNION
    /// Returns `None` if there is no child corresponding to token UNION
    fn UNION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXCEPT
    /// Returns `None` if there is no child corresponding to token EXCEPT
    fn EXCEPT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXCEPT, 0)
    }
}

impl<'input> SetOperationContextAttrs<'input> for SetOperationContext<'input> {}

pub struct SetOperationContextExt<'input> {
    base: QueryTermContextExt<'input>,
    pub left: Option<Rc<QueryTermContextAll<'input>>>,
    pub operator: Option<TokenType<'input>>,
    pub right: Option<Rc<QueryTermContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SetOperationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SetOperationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetOperationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setOperation(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetOperationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryTerm
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryTerm }
}

impl<'input> Borrow<QueryTermContextExt<'input>> for SetOperationContext<'input> {
    fn borrow(&self) -> &QueryTermContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<QueryTermContextExt<'input>> for SetOperationContext<'input> {
    fn borrow_mut(&mut self) -> &mut QueryTermContextExt<'input> {
        &mut self.base
    }
}

impl<'input> QueryTermContextAttrs<'input> for SetOperationContext<'input> {}

impl<'input> SetOperationContextExt<'input> {
    fn new(ctx: &dyn QueryTermContextAttrs<'input>) -> Rc<QueryTermContextAll<'input>> {
        Rc::new(QueryTermContextAll::SetOperationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SetOperationContextExt {
                    operator: None,
                    left: None,
                    right: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn queryTerm(&mut self) -> Result<Rc<QueryTermContextAll<'input>>, ANTLRError> {
        self.queryTerm_rec(0)
    }

    fn queryTerm_rec(
        &mut self,
        _p: isize,
    ) -> Result<Rc<QueryTermContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx =
            QueryTermContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_recursion_rule(_localctx.clone(), 36, RULE_queryTerm, _p);
        let mut _localctx: Rc<QueryTermContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 36;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                {
                    let mut tmp = QueryTermDefaultContextExt::new(&**_localctx);
                    recog.ctx = Some(tmp.clone());
                    _localctx = tmp;
                    _prevctx = _localctx.clone();

                    /*InvokeRule queryPrimary*/
                    recog.base.set_state(1136);
                    recog.queryPrimary()?;
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1152);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(130, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1150);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(129, &mut recog.base)?
                            {
                                1 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = SetOperationContextExt::new(
                                            &**QueryTermContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        if let QueryTermContextAll::SetOperationContext(
                                            ctx,
                                        ) =
                                            cast_mut::<_, QueryTermContextAll>(&mut tmp)
                                        {
                                            ctx.left = Some(_prevctx.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_queryTerm,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1138);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 2)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1139);
                                        let tmp = recog.base.match_token(
                                            INTERSECT,
                                            &mut recog.err_handler,
                                        )?;
                                        if let QueryTermContextAll::SetOperationContext(
                                            ctx,
                                        ) = cast_mut::<_, QueryTermContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.operator = Some(&tmp);
                                        } else {
                                            unreachable!("cant cast");
                                        }

                                        recog.base.set_state(1141);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == ALL || _la == DISTINCT {
                                            {
                                                /*InvokeRule setQuantifier*/
                                                recog.base.set_state(1140);
                                                recog.setQuantifier()?;
                                            }
                                        }

                                        /*InvokeRule queryTerm*/
                                        recog.base.set_state(1143);
                                        let tmp = recog.queryTerm_rec(3)?;
                                        if let QueryTermContextAll::SetOperationContext(
                                            ctx,
                                        ) = cast_mut::<_, QueryTermContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.right = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                2 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = SetOperationContextExt::new(
                                            &**QueryTermContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        if let QueryTermContextAll::SetOperationContext(
                                            ctx,
                                        ) =
                                            cast_mut::<_, QueryTermContextAll>(&mut tmp)
                                        {
                                            ctx.left = Some(_prevctx.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_queryTerm,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1144);
                                        if !({ recog.precpred(None, 1) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 1)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1145);
                                        if let QueryTermContextAll::SetOperationContext(
                                            ctx,
                                        ) = cast_mut::<_, QueryTermContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.operator =
                                                recog.base.input.lt(1).cloned();
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                        _la = recog.base.input.la(1);
                                        if { !(_la == EXCEPT || _la == UNION) } {
                                            let tmp = recog
                                                .err_handler
                                                .recover_inline(&mut recog.base)?;
                                            if let QueryTermContextAll::SetOperationContext(ctx) = cast_mut::<_,QueryTermContextAll >(&mut _localctx){
								ctx.operator = Some(&tmp); } else {unreachable!("cant cast");}
                                        } else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog
                                                .err_handler
                                                .report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        recog.base.set_state(1147);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == ALL || _la == DISTINCT {
                                            {
                                                /*InvokeRule setQuantifier*/
                                                recog.base.set_state(1146);
                                                recog.setQuantifier()?;
                                            }
                                        }

                                        /*InvokeRule queryTerm*/
                                        recog.base.set_state(1149);
                                        let tmp = recog.queryTerm_rec(2)?;
                                        if let QueryTermContextAll::SetOperationContext(
                                            ctx,
                                        ) = cast_mut::<_, QueryTermContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.right = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1154);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(130, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- queryPrimary ----------------
#[derive(Debug)]
pub enum QueryPrimaryContextAll<'input> {
    SubqueryContext(SubqueryContext<'input>),
    QueryPrimaryDefaultContext(QueryPrimaryDefaultContext<'input>),
    TableContext(TableContext<'input>),
    InlineTableContext(InlineTableContext<'input>),
    Error(QueryPrimaryContext<'input>),
}
antlr_rust::tid! {QueryPrimaryContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for QueryPrimaryContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for QueryPrimaryContextAll<'input> {}

impl<'input> Deref for QueryPrimaryContextAll<'input> {
    type Target = dyn QueryPrimaryContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use QueryPrimaryContextAll::*;
        match self {
            SubqueryContext(inner) => inner,
            QueryPrimaryDefaultContext(inner) => inner,
            TableContext(inner) => inner,
            InlineTableContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryPrimaryContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type QueryPrimaryContext<'input> =
    BaseParserRuleContext<'input, QueryPrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct QueryPrimaryContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QueryPrimaryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryPrimaryContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for QueryPrimaryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}
antlr_rust::tid! {QueryPrimaryContextExt<'a>}

impl<'input> QueryPrimaryContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QueryPrimaryContextAll<'input>> {
        Rc::new(QueryPrimaryContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                QueryPrimaryContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait QueryPrimaryContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QueryPrimaryContextExt<'input>>
{
}

impl<'input> QueryPrimaryContextAttrs<'input> for QueryPrimaryContext<'input> {}

pub type SubqueryContext<'input> =
    BaseParserRuleContext<'input, SubqueryContextExt<'input>>;

pub trait SubqueryContextAttrs<'input>: PrestoParserContext<'input> {
    fn queryNoWith(&self) -> Option<Rc<QueryNoWithContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SubqueryContextAttrs<'input> for SubqueryContext<'input> {}

pub struct SubqueryContextExt<'input> {
    base: QueryPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SubqueryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SubqueryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for SubqueryContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_subquery(self);
    }
}

impl<'input> CustomRuleContext<'input> for SubqueryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}

impl<'input> Borrow<QueryPrimaryContextExt<'input>> for SubqueryContext<'input> {
    fn borrow(&self) -> &QueryPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<QueryPrimaryContextExt<'input>> for SubqueryContext<'input> {
    fn borrow_mut(&mut self) -> &mut QueryPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> QueryPrimaryContextAttrs<'input> for SubqueryContext<'input> {}

impl<'input> SubqueryContextExt<'input> {
    fn new(
        ctx: &dyn QueryPrimaryContextAttrs<'input>,
    ) -> Rc<QueryPrimaryContextAll<'input>> {
        Rc::new(QueryPrimaryContextAll::SubqueryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SubqueryContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type QueryPrimaryDefaultContext<'input> =
    BaseParserRuleContext<'input, QueryPrimaryDefaultContextExt<'input>>;

pub trait QueryPrimaryDefaultContextAttrs<'input>: PrestoParserContext<'input> {
    fn querySpecification(&self) -> Option<Rc<QuerySpecificationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> QueryPrimaryDefaultContextAttrs<'input>
    for QueryPrimaryDefaultContext<'input>
{
}

pub struct QueryPrimaryDefaultContextExt<'input> {
    base: QueryPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {QueryPrimaryDefaultContextExt<'a>}

impl<'input> PrestoParserContext<'input> for QueryPrimaryDefaultContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryPrimaryDefaultContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_queryPrimaryDefault(self);
    }
}

impl<'input> CustomRuleContext<'input> for QueryPrimaryDefaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}

impl<'input> Borrow<QueryPrimaryContextExt<'input>>
    for QueryPrimaryDefaultContext<'input>
{
    fn borrow(&self) -> &QueryPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<QueryPrimaryContextExt<'input>>
    for QueryPrimaryDefaultContext<'input>
{
    fn borrow_mut(&mut self) -> &mut QueryPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> QueryPrimaryContextAttrs<'input> for QueryPrimaryDefaultContext<'input> {}

impl<'input> QueryPrimaryDefaultContextExt<'input> {
    fn new(
        ctx: &dyn QueryPrimaryContextAttrs<'input>,
    ) -> Rc<QueryPrimaryContextAll<'input>> {
        Rc::new(QueryPrimaryContextAll::QueryPrimaryDefaultContext(
            BaseParserRuleContext::copy_from(
                ctx,
                QueryPrimaryDefaultContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TableContext<'input> = BaseParserRuleContext<'input, TableContextExt<'input>>;

pub trait TableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TableContextAttrs<'input> for TableContext<'input> {}

pub struct TableContextExt<'input> {
    base: QueryPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for TableContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_table(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}

impl<'input> Borrow<QueryPrimaryContextExt<'input>> for TableContext<'input> {
    fn borrow(&self) -> &QueryPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<QueryPrimaryContextExt<'input>> for TableContext<'input> {
    fn borrow_mut(&mut self) -> &mut QueryPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> QueryPrimaryContextAttrs<'input> for TableContext<'input> {}

impl<'input> TableContextExt<'input> {
    fn new(
        ctx: &dyn QueryPrimaryContextAttrs<'input>,
    ) -> Rc<QueryPrimaryContextAll<'input>> {
        Rc::new(QueryPrimaryContextAll::TableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type InlineTableContext<'input> =
    BaseParserRuleContext<'input, InlineTableContextExt<'input>>;

pub trait InlineTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token VALUES
    /// Returns `None` if there is no child corresponding to token VALUES
    fn VALUES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VALUES, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> InlineTableContextAttrs<'input> for InlineTableContext<'input> {}

pub struct InlineTableContextExt<'input> {
    base: QueryPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {InlineTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for InlineTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for InlineTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_inlineTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for InlineTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}

impl<'input> Borrow<QueryPrimaryContextExt<'input>> for InlineTableContext<'input> {
    fn borrow(&self) -> &QueryPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<QueryPrimaryContextExt<'input>> for InlineTableContext<'input> {
    fn borrow_mut(&mut self) -> &mut QueryPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> QueryPrimaryContextAttrs<'input> for InlineTableContext<'input> {}

impl<'input> InlineTableContextExt<'input> {
    fn new(
        ctx: &dyn QueryPrimaryContextAttrs<'input>,
    ) -> Rc<QueryPrimaryContextAll<'input>> {
        Rc::new(QueryPrimaryContextAll::InlineTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                InlineTableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn queryPrimary(
        &mut self,
    ) -> Result<Rc<QueryPrimaryContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            QueryPrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 38, RULE_queryPrimary);
        let mut _localctx: Rc<QueryPrimaryContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1171);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                SELECT => {
                    let tmp = QueryPrimaryDefaultContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule querySpecification*/
                        recog.base.set_state(1155);
                        recog.querySpecification()?;
                    }
                }

                TABLE => {
                    let tmp = TableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1156);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(1157);
                        recog.qualifiedName()?;
                    }
                }

                VALUES => {
                    let tmp = InlineTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1158);
                        recog.base.match_token(VALUES, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(1159);
                        recog.expression()?;

                        recog.base.set_state(1164);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt =
                            recog.interpreter.adaptive_predict(131, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1160);
                                        recog
                                            .base
                                            .match_token(COMMA, &mut recog.err_handler)?;

                                        /*InvokeRule expression*/
                                        recog.base.set_state(1161);
                                        recog.expression()?;
                                    }
                                }
                            }
                            recog.base.set_state(1166);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog
                                .interpreter
                                .adaptive_predict(131, &mut recog.base)?;
                        }
                    }
                }

                T__1 => {
                    let tmp = SubqueryContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1167);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule queryNoWith*/
                        recog.base.set_state(1168);
                        recog.queryNoWith()?;

                        recog.base.set_state(1169);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- sortItem ----------------
pub type SortItemContextAll<'input> = SortItemContext<'input>;

pub type SortItemContext<'input> =
    BaseParserRuleContext<'input, SortItemContextExt<'input>>;

#[derive(Clone)]
pub struct SortItemContextExt<'input> {
    pub ordering: Option<TokenType<'input>>,
    pub nullOrdering: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SortItemContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for SortItemContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_sortItem(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_sortItem(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for SortItemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_sortItem
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_sortItem }
}
antlr_rust::tid! {SortItemContextExt<'a>}

impl<'input> SortItemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SortItemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            SortItemContextExt {
                ordering: None,
                nullOrdering: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait SortItemContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SortItemContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NULLS
    /// Returns `None` if there is no child corresponding to token NULLS
    fn NULLS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULLS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ASC
    /// Returns `None` if there is no child corresponding to token ASC
    fn ASC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ASC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DESC
    /// Returns `None` if there is no child corresponding to token DESC
    fn DESC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FIRST
    /// Returns `None` if there is no child corresponding to token FIRST
    fn FIRST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FIRST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LAST
    /// Returns `None` if there is no child corresponding to token LAST
    fn LAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LAST, 0)
    }
}

impl<'input> SortItemContextAttrs<'input> for SortItemContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn sortItem(&mut self) -> Result<Rc<SortItemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SortItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_sortItem);
        let mut _localctx: Rc<SortItemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule expression*/
                recog.base.set_state(1173);
                recog.expression()?;

                recog.base.set_state(1175);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == ASC || _la == DESC {
                    {
                        recog.base.set_state(1174);
                        cast_mut::<_, SortItemContext>(&mut _localctx).ordering =
                            recog.base.input.lt(1).cloned();

                        _la = recog.base.input.la(1);
                        if { !(_la == ASC || _la == DESC) } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            cast_mut::<_, SortItemContext>(&mut _localctx).ordering =
                                Some(&tmp);
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                recog.base.set_state(1179);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == NULLS {
                    {
                        recog.base.set_state(1177);
                        recog.base.match_token(NULLS, &mut recog.err_handler)?;

                        recog.base.set_state(1178);
                        cast_mut::<_, SortItemContext>(&mut _localctx).nullOrdering =
                            recog.base.input.lt(1).cloned();

                        _la = recog.base.input.la(1);
                        if { !(_la == FIRST || _la == LAST) } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            cast_mut::<_, SortItemContext>(&mut _localctx).nullOrdering =
                                Some(&tmp);
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- querySpecification ----------------
pub type QuerySpecificationContextAll<'input> = QuerySpecificationContext<'input>;

pub type QuerySpecificationContext<'input> =
    BaseParserRuleContext<'input, QuerySpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct QuerySpecificationContextExt<'input> {
    pub where_: Option<Rc<BooleanExpressionContextAll<'input>>>,
    pub having: Option<Rc<BooleanExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QuerySpecificationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QuerySpecificationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_querySpecification(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_querySpecification(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for QuerySpecificationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_querySpecification
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_querySpecification }
}
antlr_rust::tid! {QuerySpecificationContextExt<'a>}

impl<'input> QuerySpecificationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QuerySpecificationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            QuerySpecificationContextExt {
                where_: None,
                having: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait QuerySpecificationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QuerySpecificationContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token SELECT
    /// Returns `None` if there is no child corresponding to token SELECT
    fn SELECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SELECT, 0)
    }
    fn querySelectItems(&self) -> Option<Rc<QuerySelectItemsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn relation_all(&self) -> Vec<Rc<RelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn relation(&self, i: usize) -> Option<Rc<RelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token WHERE
    /// Returns `None` if there is no child corresponding to token WHERE
    fn WHERE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHERE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GROUP
    /// Returns `None` if there is no child corresponding to token GROUP
    fn GROUP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GROUP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BY
    /// Returns `None` if there is no child corresponding to token BY
    fn BY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, 0)
    }
    fn groupBy(&self) -> Option<Rc<GroupByContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token HAVING
    /// Returns `None` if there is no child corresponding to token HAVING
    fn HAVING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(HAVING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WINDOW
    /// Returns `None` if there is no child corresponding to token WINDOW
    fn WINDOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WINDOW, 0)
    }
    fn windowDefinition_all(&self) -> Vec<Rc<WindowDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn windowDefinition(&self, i: usize) -> Option<Rc<WindowDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn booleanExpression_all(&self) -> Vec<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn booleanExpression(
        &self,
        i: usize,
    ) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> QuerySpecificationContextAttrs<'input>
    for QuerySpecificationContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn querySpecification(
        &mut self,
    ) -> Result<Rc<QuerySpecificationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            QuerySpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 42, RULE_querySpecification);
        let mut _localctx: Rc<QuerySpecificationContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1181);
                recog.base.match_token(SELECT, &mut recog.err_handler)?;

                recog.base.set_state(1183);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(135, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /*InvokeRule setQuantifier*/
                            recog.base.set_state(1182);
                            recog.setQuantifier()?;
                        }
                    }

                    _ => {}
                }
                /*InvokeRule querySelectItems*/
                recog.base.set_state(1185);
                recog.querySelectItems()?;

                recog.base.set_state(1195);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(137, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1186);
                            recog.base.match_token(FROM, &mut recog.err_handler)?;

                            /*InvokeRule relation*/
                            recog.base.set_state(1187);
                            recog.relation_rec(0)?;

                            recog.base.set_state(1192);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog
                                .interpreter
                                .adaptive_predict(136, &mut recog.base)?;
                            while { _alt != 2 && _alt != INVALID_ALT } {
                                if _alt == 1 {
                                    {
                                        {
                                            recog.base.set_state(1188);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule relation*/
                                            recog.base.set_state(1189);
                                            recog.relation_rec(0)?;
                                        }
                                    }
                                }
                                recog.base.set_state(1194);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog
                                    .interpreter
                                    .adaptive_predict(136, &mut recog.base)?;
                            }
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1199);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(138, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1197);
                            recog.base.match_token(WHERE, &mut recog.err_handler)?;

                            /*InvokeRule booleanExpression*/
                            recog.base.set_state(1198);
                            let tmp = recog.booleanExpression_rec(0)?;
                            cast_mut::<_, QuerySpecificationContext>(&mut _localctx)
                                .where_ = Some(tmp.clone());
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1204);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(139, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1201);
                            recog.base.match_token(GROUP, &mut recog.err_handler)?;

                            recog.base.set_state(1202);
                            recog.base.match_token(BY, &mut recog.err_handler)?;

                            /*InvokeRule groupBy*/
                            recog.base.set_state(1203);
                            recog.groupBy()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1208);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(140, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1206);
                            recog.base.match_token(HAVING, &mut recog.err_handler)?;

                            /*InvokeRule booleanExpression*/
                            recog.base.set_state(1207);
                            let tmp = recog.booleanExpression_rec(0)?;
                            cast_mut::<_, QuerySpecificationContext>(&mut _localctx)
                                .having = Some(tmp.clone());
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1219);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(142, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1210);
                            recog.base.match_token(WINDOW, &mut recog.err_handler)?;

                            /*InvokeRule windowDefinition*/
                            recog.base.set_state(1211);
                            recog.windowDefinition()?;

                            recog.base.set_state(1216);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog
                                .interpreter
                                .adaptive_predict(141, &mut recog.base)?;
                            while { _alt != 2 && _alt != INVALID_ALT } {
                                if _alt == 1 {
                                    {
                                        {
                                            recog.base.set_state(1212);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule windowDefinition*/
                                            recog.base.set_state(1213);
                                            recog.windowDefinition()?;
                                        }
                                    }
                                }
                                recog.base.set_state(1218);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog
                                    .interpreter
                                    .adaptive_predict(141, &mut recog.base)?;
                            }
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- querySelectItems ----------------
pub type QuerySelectItemsContextAll<'input> = QuerySelectItemsContext<'input>;

pub type QuerySelectItemsContext<'input> =
    BaseParserRuleContext<'input, QuerySelectItemsContextExt<'input>>;

#[derive(Clone)]
pub struct QuerySelectItemsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QuerySelectItemsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QuerySelectItemsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_querySelectItems(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_querySelectItems(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for QuerySelectItemsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_querySelectItems
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_querySelectItems }
}
antlr_rust::tid! {QuerySelectItemsContextExt<'a>}

impl<'input> QuerySelectItemsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QuerySelectItemsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            QuerySelectItemsContextExt { ph: PhantomData },
        ))
    }
}

pub trait QuerySelectItemsContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QuerySelectItemsContextExt<'input>>
{
    fn selectItem_all(&self) -> Vec<Rc<SelectItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn selectItem(&self, i: usize) -> Option<Rc<SelectItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> QuerySelectItemsContextAttrs<'input> for QuerySelectItemsContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn querySelectItems(
        &mut self,
    ) -> Result<Rc<QuerySelectItemsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            QuerySelectItemsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 44, RULE_querySelectItems);
        let mut _localctx: Rc<QuerySelectItemsContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule selectItem*/
                recog.base.set_state(1221);
                recog.selectItem()?;

                recog.base.set_state(1226);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(143, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(1222);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                /*InvokeRule selectItem*/
                                recog.base.set_state(1223);
                                recog.selectItem()?;
                            }
                        }
                    }
                    recog.base.set_state(1228);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(143, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- groupBy ----------------
pub type GroupByContextAll<'input> = GroupByContext<'input>;

pub type GroupByContext<'input> =
    BaseParserRuleContext<'input, GroupByContextExt<'input>>;

#[derive(Clone)]
pub struct GroupByContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for GroupByContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for GroupByContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_groupBy(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_groupBy(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for GroupByContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_groupBy
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_groupBy }
}
antlr_rust::tid! {GroupByContextExt<'a>}

impl<'input> GroupByContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<GroupByContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            GroupByContextExt { ph: PhantomData },
        ))
    }
}

pub trait GroupByContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<GroupByContextExt<'input>>
{
    fn groupingElement_all(&self) -> Vec<Rc<GroupingElementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn groupingElement(&self, i: usize) -> Option<Rc<GroupingElementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> GroupByContextAttrs<'input> for GroupByContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn groupBy(&mut self) -> Result<Rc<GroupByContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            GroupByContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_groupBy);
        let mut _localctx: Rc<GroupByContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1230);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(144, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /*InvokeRule setQuantifier*/
                            recog.base.set_state(1229);
                            recog.setQuantifier()?;
                        }
                    }

                    _ => {}
                }
                /*InvokeRule groupingElement*/
                recog.base.set_state(1232);
                recog.groupingElement()?;

                recog.base.set_state(1237);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(145, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(1233);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                /*InvokeRule groupingElement*/
                                recog.base.set_state(1234);
                                recog.groupingElement()?;
                            }
                        }
                    }
                    recog.base.set_state(1239);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(145, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- groupingElement ----------------
#[derive(Debug)]
pub enum GroupingElementContextAll<'input> {
    MultipleGroupingSetsContext(MultipleGroupingSetsContext<'input>),
    SingleGroupingSetContext(SingleGroupingSetContext<'input>),
    CubeContext(CubeContext<'input>),
    RollupContext(RollupContext<'input>),
    Error(GroupingElementContext<'input>),
}
antlr_rust::tid! {GroupingElementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for GroupingElementContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for GroupingElementContextAll<'input> {}

impl<'input> Deref for GroupingElementContextAll<'input> {
    type Target = dyn GroupingElementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use GroupingElementContextAll::*;
        match self {
            MultipleGroupingSetsContext(inner) => inner,
            SingleGroupingSetContext(inner) => inner,
            CubeContext(inner) => inner,
            RollupContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GroupingElementContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type GroupingElementContext<'input> =
    BaseParserRuleContext<'input, GroupingElementContextExt<'input>>;

#[derive(Clone)]
pub struct GroupingElementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for GroupingElementContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GroupingElementContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for GroupingElementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_groupingElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}
antlr_rust::tid! {GroupingElementContextExt<'a>}

impl<'input> GroupingElementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<GroupingElementContextAll<'input>> {
        Rc::new(GroupingElementContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                GroupingElementContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait GroupingElementContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<GroupingElementContextExt<'input>>
{
}

impl<'input> GroupingElementContextAttrs<'input> for GroupingElementContext<'input> {}

pub type MultipleGroupingSetsContext<'input> =
    BaseParserRuleContext<'input, MultipleGroupingSetsContextExt<'input>>;

pub trait MultipleGroupingSetsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token GROUPING
    /// Returns `None` if there is no child corresponding to token GROUPING
    fn GROUPING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GROUPING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SETS
    /// Returns `None` if there is no child corresponding to token SETS
    fn SETS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SETS, 0)
    }
    fn groupingSet_all(&self) -> Vec<Rc<GroupingSetContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn groupingSet(&self, i: usize) -> Option<Rc<GroupingSetContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> MultipleGroupingSetsContextAttrs<'input>
    for MultipleGroupingSetsContext<'input>
{
}

pub struct MultipleGroupingSetsContextExt<'input> {
    base: GroupingElementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MultipleGroupingSetsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for MultipleGroupingSetsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for MultipleGroupingSetsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_multipleGroupingSets(self);
    }
}

impl<'input> CustomRuleContext<'input> for MultipleGroupingSetsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_groupingElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>>
    for MultipleGroupingSetsContext<'input>
{
    fn borrow(&self) -> &GroupingElementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>>
    for MultipleGroupingSetsContext<'input>
{
    fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> GroupingElementContextAttrs<'input> for MultipleGroupingSetsContext<'input> {}

impl<'input> MultipleGroupingSetsContextExt<'input> {
    fn new(
        ctx: &dyn GroupingElementContextAttrs<'input>,
    ) -> Rc<GroupingElementContextAll<'input>> {
        Rc::new(GroupingElementContextAll::MultipleGroupingSetsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                MultipleGroupingSetsContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SingleGroupingSetContext<'input> =
    BaseParserRuleContext<'input, SingleGroupingSetContextExt<'input>>;

pub trait SingleGroupingSetContextAttrs<'input>: PrestoParserContext<'input> {
    fn groupingSet(&self) -> Option<Rc<GroupingSetContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SingleGroupingSetContextAttrs<'input> for SingleGroupingSetContext<'input> {}

pub struct SingleGroupingSetContextExt<'input> {
    base: GroupingElementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SingleGroupingSetContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SingleGroupingSetContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SingleGroupingSetContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_singleGroupingSet(self);
    }
}

impl<'input> CustomRuleContext<'input> for SingleGroupingSetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_groupingElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>>
    for SingleGroupingSetContext<'input>
{
    fn borrow(&self) -> &GroupingElementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>>
    for SingleGroupingSetContext<'input>
{
    fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> GroupingElementContextAttrs<'input> for SingleGroupingSetContext<'input> {}

impl<'input> SingleGroupingSetContextExt<'input> {
    fn new(
        ctx: &dyn GroupingElementContextAttrs<'input>,
    ) -> Rc<GroupingElementContextAll<'input>> {
        Rc::new(GroupingElementContextAll::SingleGroupingSetContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SingleGroupingSetContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CubeContext<'input> = BaseParserRuleContext<'input, CubeContextExt<'input>>;

pub trait CubeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CUBE
    /// Returns `None` if there is no child corresponding to token CUBE
    fn CUBE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CUBE, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> CubeContextAttrs<'input> for CubeContext<'input> {}

pub struct CubeContextExt<'input> {
    base: GroupingElementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CubeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CubeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for CubeContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_cube(self);
    }
}

impl<'input> CustomRuleContext<'input> for CubeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_groupingElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>> for CubeContext<'input> {
    fn borrow(&self) -> &GroupingElementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>> for CubeContext<'input> {
    fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> GroupingElementContextAttrs<'input> for CubeContext<'input> {}

impl<'input> CubeContextExt<'input> {
    fn new(
        ctx: &dyn GroupingElementContextAttrs<'input>,
    ) -> Rc<GroupingElementContextAll<'input>> {
        Rc::new(GroupingElementContextAll::CubeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CubeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RollupContext<'input> = BaseParserRuleContext<'input, RollupContextExt<'input>>;

pub trait RollupContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ROLLUP
    /// Returns `None` if there is no child corresponding to token ROLLUP
    fn ROLLUP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLLUP, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> RollupContextAttrs<'input> for RollupContext<'input> {}

pub struct RollupContextExt<'input> {
    base: GroupingElementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RollupContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RollupContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RollupContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rollup(self);
    }
}

impl<'input> CustomRuleContext<'input> for RollupContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_groupingElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>> for RollupContext<'input> {
    fn borrow(&self) -> &GroupingElementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>> for RollupContext<'input> {
    fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> GroupingElementContextAttrs<'input> for RollupContext<'input> {}

impl<'input> RollupContextExt<'input> {
    fn new(
        ctx: &dyn GroupingElementContextAttrs<'input>,
    ) -> Rc<GroupingElementContextAll<'input>> {
        Rc::new(GroupingElementContextAll::RollupContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RollupContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn groupingElement(
        &mut self,
    ) -> Result<Rc<GroupingElementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            GroupingElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 48, RULE_groupingElement);
        let mut _localctx: Rc<GroupingElementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1280);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(151, &mut recog.base)? {
                1 => {
                    let tmp = SingleGroupingSetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule groupingSet*/
                        recog.base.set_state(1240);
                        recog.groupingSet()?;
                    }
                }
                2 => {
                    let tmp = RollupContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1241);
                        recog.base.match_token(ROLLUP, &mut recog.err_handler)?;

                        recog.base.set_state(1242);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        recog.base.set_state(1251);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << T__1)
                                    | (1usize << ABSENT)
                                    | (1usize << ADD)
                                    | (1usize << ADMIN)
                                    | (1usize << AFTER)
                                    | (1usize << ALL)
                                    | (1usize << ANALYZE)
                                    | (1usize << ANY)
                                    | (1usize << ARRAY)
                                    | (1usize << ASC)
                                    | (1usize << AT)
                                    | (1usize << AUTHORIZATION)
                                    | (1usize << BERNOULLI)))
                                != 0)
                            || (((_la - 33) & !0x3f) == 0
                                && ((1usize << (_la - 33))
                                    & ((1usize << (BOTH - 33))
                                        | (1usize << (CALL - 33))
                                        | (1usize << (CASCADE - 33))
                                        | (1usize << (CASE - 33))
                                        | (1usize << (CAST - 33))
                                        | (1usize << (CATALOGS - 33))
                                        | (1usize << (COLUMN - 33))
                                        | (1usize << (COLUMNS - 33))
                                        | (1usize << (COMMENT - 33))
                                        | (1usize << (COMMIT - 33))
                                        | (1usize << (COMMITTED - 33))
                                        | (1usize << (CONDITIONAL - 33))
                                        | (1usize << (COUNT - 33))
                                        | (1usize << (COPARTITION - 33))
                                        | (1usize << (CURRENT - 33))
                                        | (1usize << (CURRENT_CATALOG - 33))
                                        | (1usize << (CURRENT_DATE - 33))
                                        | (1usize << (CURRENT_PATH - 33))
                                        | (1usize << (CURRENT_SCHEMA - 33))
                                        | (1usize << (CURRENT_TIME - 33))
                                        | (1usize << (CURRENT_TIMESTAMP - 33))
                                        | (1usize << (CURRENT_USER - 33))
                                        | (1usize << (DATA - 33))
                                        | (1usize << (DATE - 33))
                                        | (1usize << (DAY - 33))))
                                    != 0)
                            || (((_la - 66) & !0x3f) == 0
                                && ((1usize << (_la - 66))
                                    & ((1usize << (DEFAULT - 66))
                                        | (1usize << (DEFINE - 66))
                                        | (1usize << (DEFINER - 66))
                                        | (1usize << (DENY - 66))
                                        | (1usize << (DESC - 66))
                                        | (1usize << (DESCRIPTOR - 66))
                                        | (1usize << (DISTRIBUTED - 66))
                                        | (1usize << (DOUBLE - 66))
                                        | (1usize << (EMPTY - 66))
                                        | (1usize << (ENCODING - 66))
                                        | (1usize << (ERROR - 66))
                                        | (1usize << (EXCLUDING - 66))
                                        | (1usize << (EXISTS - 66))
                                        | (1usize << (EXPLAIN - 66))
                                        | (1usize << (EXTRACT - 66))
                                        | (1usize << (FALSE - 66))
                                        | (1usize << (FETCH - 66))
                                        | (1usize << (FILTER - 66))
                                        | (1usize << (FINAL - 66))
                                        | (1usize << (FIRST - 66))
                                        | (1usize << (FOLLOWING - 66))
                                        | (1usize << (FORMAT - 66))))
                                    != 0)
                            || (((_la - 100) & !0x3f) == 0
                                && ((1usize << (_la - 100))
                                    & ((1usize << (FUNCTIONS - 100))
                                        | (1usize << (GRACE - 100))
                                        | (1usize << (GRANT - 100))
                                        | (1usize << (GRANTED - 100))
                                        | (1usize << (GRANTS - 100))
                                        | (1usize << (GRAPHVIZ - 100))
                                        | (1usize << (GROUPING - 100))
                                        | (1usize << (GROUPS - 100))
                                        | (1usize << (HOUR - 100))
                                        | (1usize << (IF - 100))
                                        | (1usize << (IGNORE - 100))
                                        | (1usize << (INCLUDING - 100))
                                        | (1usize << (INITIAL - 100))
                                        | (1usize << (INPUT - 100))
                                        | (1usize << (INTERVAL - 100))
                                        | (1usize << (INVOKER - 100))
                                        | (1usize << (IO - 100))
                                        | (1usize << (ISOLATION - 100))
                                        | (1usize << (JSON - 100))
                                        | (1usize << (JSON_ARRAY - 100))
                                        | (1usize << (JSON_EXISTS - 100))
                                        | (1usize << (JSON_OBJECT - 100))
                                        | (1usize << (JSON_QUERY - 100))))
                                    != 0)
                            || (((_la - 132) & !0x3f) == 0
                                && ((1usize << (_la - 132))
                                    & ((1usize << (JSON_VALUE - 132))
                                        | (1usize << (KEEP - 132))
                                        | (1usize << (KEY - 132))
                                        | (1usize << (KEYS - 132))
                                        | (1usize << (LAST - 132))
                                        | (1usize << (LATERAL - 132))
                                        | (1usize << (LEADING - 132))
                                        | (1usize << (LEVEL - 132))
                                        | (1usize << (LIMIT - 132))
                                        | (1usize << (LISTAGG - 132))
                                        | (1usize << (LOCAL - 132))
                                        | (1usize << (LOCALTIME - 132))
                                        | (1usize << (LOCALTIMESTAMP - 132))
                                        | (1usize << (LOGICAL - 132))
                                        | (1usize << (MAP - 132))
                                        | (1usize << (MATCH - 132))
                                        | (1usize << (MATCHED - 132))
                                        | (1usize << (MATCHES - 132))
                                        | (1usize << (MATCH_RECOGNIZE - 132))
                                        | (1usize << (MATERIALIZED - 132))
                                        | (1usize << (MEASURES - 132))
                                        | (1usize << (MERGE - 132))
                                        | (1usize << (MINUTE - 132))
                                        | (1usize << (MONTH - 132))
                                        | (1usize << (NEXT - 132))
                                        | (1usize << (NFC - 132))
                                        | (1usize << (NFD - 132))
                                        | (1usize << (NFKC - 132))
                                        | (1usize << (NFKD - 132))))
                                    != 0)
                            || (((_la - 164) & !0x3f) == 0
                                && ((1usize << (_la - 164))
                                    & ((1usize << (NO - 164))
                                        | (1usize << (NONE - 164))
                                        | (1usize << (NORMALIZE - 164))
                                        | (1usize << (NOT - 164))
                                        | (1usize << (NULL - 164))
                                        | (1usize << (NULLIF - 164))
                                        | (1usize << (NULLS - 164))
                                        | (1usize << (OBJECT - 164))
                                        | (1usize << (OF - 164))
                                        | (1usize << (OFFSET - 164))
                                        | (1usize << (OMIT - 164))
                                        | (1usize << (ONE - 164))
                                        | (1usize << (ONLY - 164))
                                        | (1usize << (OPTION - 164))
                                        | (1usize << (ORDINALITY - 164))
                                        | (1usize << (OUTPUT - 164))
                                        | (1usize << (OVER - 164))
                                        | (1usize << (OVERFLOW - 164))
                                        | (1usize << (PARTITION - 164))
                                        | (1usize << (PARTITIONS - 164))
                                        | (1usize << (PASSING - 164))
                                        | (1usize << (PAST - 164))
                                        | (1usize << (PATH - 164))
                                        | (1usize << (PATTERN - 164))
                                        | (1usize << (PER - 164))
                                        | (1usize << (PERIOD - 164))
                                        | (1usize << (PERMUTE - 164))
                                        | (1usize << (POSITION - 164))))
                                    != 0)
                            || (((_la - 196) & !0x3f) == 0
                                && ((1usize << (_la - 196))
                                    & ((1usize << (PRECEDING - 196))
                                        | (1usize << (PRECISION - 196))
                                        | (1usize << (PRIVILEGES - 196))
                                        | (1usize << (PROPERTIES - 196))
                                        | (1usize << (PRUNE - 196))
                                        | (1usize << (QUOTES - 196))
                                        | (1usize << (RANGE - 196))
                                        | (1usize << (READ - 196))
                                        | (1usize << (REFRESH - 196))
                                        | (1usize << (RENAME - 196))
                                        | (1usize << (REPEATABLE - 196))
                                        | (1usize << (REPLACE - 196))
                                        | (1usize << (RESET - 196))
                                        | (1usize << (RESPECT - 196))
                                        | (1usize << (RESTRICT - 196))
                                        | (1usize << (RETURNING - 196))
                                        | (1usize << (REVOKE - 196))
                                        | (1usize << (ROLE - 196))
                                        | (1usize << (ROLES - 196))
                                        | (1usize << (ROLLBACK - 196))
                                        | (1usize << (ROW - 196))
                                        | (1usize << (ROWS - 196))
                                        | (1usize << (RUNNING - 196))
                                        | (1usize << (SCALAR - 196))
                                        | (1usize << (SCHEMA - 196))
                                        | (1usize << (SCHEMAS - 196))
                                        | (1usize << (SECOND - 196))
                                        | (1usize << (SECURITY - 196))))
                                    != 0)
                            || (((_la - 228) & !0x3f) == 0
                                && ((1usize << (_la - 228))
                                    & ((1usize << (SEEK - 228))
                                        | (1usize << (SERIALIZABLE - 228))
                                        | (1usize << (SESSION - 228))
                                        | (1usize << (SET - 228))
                                        | (1usize << (SETS - 228))
                                        | (1usize << (SHOW - 228))
                                        | (1usize << (SOME - 228))
                                        | (1usize << (START - 228))
                                        | (1usize << (STATS - 228))
                                        | (1usize << (SUBSET - 228))
                                        | (1usize << (SUBSTRING - 228))
                                        | (1usize << (SYSTEM - 228))
                                        | (1usize << (TABLES - 228))
                                        | (1usize << (TABLESAMPLE - 228))
                                        | (1usize << (TEXT - 228))
                                        | (1usize << (TEXT_STRING - 228))
                                        | (1usize << (TIES - 228))
                                        | (1usize << (TIME - 228))
                                        | (1usize << (TIMESTAMP - 228))
                                        | (1usize << (TO - 228))
                                        | (1usize << (TRAILING - 228))
                                        | (1usize << (TRANSACTION - 228))
                                        | (1usize << (TRIM - 228))
                                        | (1usize << (TRUE - 228))
                                        | (1usize << (TRUNCATE - 228))
                                        | (1usize << (TRY_CAST - 228))
                                        | (1usize << (TYPE - 228))
                                        | (1usize << (UNBOUNDED - 228))))
                                    != 0)
                            || (((_la - 260) & !0x3f) == 0
                                && ((1usize << (_la - 260))
                                    & ((1usize << (UNCOMMITTED - 260))
                                        | (1usize << (UNCONDITIONAL - 260))
                                        | (1usize << (UNIQUE - 260))
                                        | (1usize << (UNKNOWN - 260))
                                        | (1usize << (UNMATCHED - 260))
                                        | (1usize << (UPDATE - 260))
                                        | (1usize << (USE - 260))
                                        | (1usize << (USER - 260))
                                        | (1usize << (UTF16 - 260))
                                        | (1usize << (UTF32 - 260))
                                        | (1usize << (UTF8 - 260))
                                        | (1usize << (VALIDATE - 260))
                                        | (1usize << (VALUE - 260))
                                        | (1usize << (VERBOSE - 260))
                                        | (1usize << (VERSION - 260))
                                        | (1usize << (VIEW - 260))
                                        | (1usize << (WINDOW - 260))
                                        | (1usize << (WITHIN - 260))
                                        | (1usize << (WITHOUT - 260))
                                        | (1usize << (WORK - 260))
                                        | (1usize << (WRAPPER - 260))
                                        | (1usize << (WRITE - 260))
                                        | (1usize << (YEAR - 260))
                                        | (1usize << (ZONE - 260))))
                                    != 0)
                            || (((_la - 297) & !0x3f) == 0
                                && ((1usize << (_la - 297))
                                    & ((1usize << (PLUS - 297))
                                        | (1usize << (MINUS - 297))
                                        | (1usize << (QUESTION_MARK - 297))
                                        | (1usize << (STRING - 297))
                                        | (1usize << (UNICODE_STRING - 297))
                                        | (1usize << (BINARY_LITERAL - 297))
                                        | (1usize << (INTEGER_VALUE - 297))
                                        | (1usize << (DECIMAL_VALUE - 297))
                                        | (1usize << (DOUBLE_VALUE - 297))
                                        | (1usize << (IDENTIFIER - 297))
                                        | (1usize << (DIGIT_IDENTIFIER - 297))
                                        | (1usize << (QUOTED_IDENTIFIER - 297))
                                        | (1usize << (BACKQUOTED_IDENTIFIER - 297))))
                                    != 0)
                        {
                            {
                                /*InvokeRule expression*/
                                recog.base.set_state(1243);
                                recog.expression()?;

                                recog.base.set_state(1248);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(1244);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule expression*/
                                            recog.base.set_state(1245);
                                            recog.expression()?;
                                        }
                                    }
                                    recog.base.set_state(1250);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                            }
                        }

                        recog.base.set_state(1253);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = CubeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1254);
                        recog.base.match_token(CUBE, &mut recog.err_handler)?;

                        recog.base.set_state(1255);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        recog.base.set_state(1264);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << T__1)
                                    | (1usize << ABSENT)
                                    | (1usize << ADD)
                                    | (1usize << ADMIN)
                                    | (1usize << AFTER)
                                    | (1usize << ALL)
                                    | (1usize << ANALYZE)
                                    | (1usize << ANY)
                                    | (1usize << ARRAY)
                                    | (1usize << ASC)
                                    | (1usize << AT)
                                    | (1usize << AUTHORIZATION)
                                    | (1usize << BERNOULLI)))
                                != 0)
                            || (((_la - 33) & !0x3f) == 0
                                && ((1usize << (_la - 33))
                                    & ((1usize << (BOTH - 33))
                                        | (1usize << (CALL - 33))
                                        | (1usize << (CASCADE - 33))
                                        | (1usize << (CASE - 33))
                                        | (1usize << (CAST - 33))
                                        | (1usize << (CATALOGS - 33))
                                        | (1usize << (COLUMN - 33))
                                        | (1usize << (COLUMNS - 33))
                                        | (1usize << (COMMENT - 33))
                                        | (1usize << (COMMIT - 33))
                                        | (1usize << (COMMITTED - 33))
                                        | (1usize << (CONDITIONAL - 33))
                                        | (1usize << (COUNT - 33))
                                        | (1usize << (COPARTITION - 33))
                                        | (1usize << (CURRENT - 33))
                                        | (1usize << (CURRENT_CATALOG - 33))
                                        | (1usize << (CURRENT_DATE - 33))
                                        | (1usize << (CURRENT_PATH - 33))
                                        | (1usize << (CURRENT_SCHEMA - 33))
                                        | (1usize << (CURRENT_TIME - 33))
                                        | (1usize << (CURRENT_TIMESTAMP - 33))
                                        | (1usize << (CURRENT_USER - 33))
                                        | (1usize << (DATA - 33))
                                        | (1usize << (DATE - 33))
                                        | (1usize << (DAY - 33))))
                                    != 0)
                            || (((_la - 66) & !0x3f) == 0
                                && ((1usize << (_la - 66))
                                    & ((1usize << (DEFAULT - 66))
                                        | (1usize << (DEFINE - 66))
                                        | (1usize << (DEFINER - 66))
                                        | (1usize << (DENY - 66))
                                        | (1usize << (DESC - 66))
                                        | (1usize << (DESCRIPTOR - 66))
                                        | (1usize << (DISTRIBUTED - 66))
                                        | (1usize << (DOUBLE - 66))
                                        | (1usize << (EMPTY - 66))
                                        | (1usize << (ENCODING - 66))
                                        | (1usize << (ERROR - 66))
                                        | (1usize << (EXCLUDING - 66))
                                        | (1usize << (EXISTS - 66))
                                        | (1usize << (EXPLAIN - 66))
                                        | (1usize << (EXTRACT - 66))
                                        | (1usize << (FALSE - 66))
                                        | (1usize << (FETCH - 66))
                                        | (1usize << (FILTER - 66))
                                        | (1usize << (FINAL - 66))
                                        | (1usize << (FIRST - 66))
                                        | (1usize << (FOLLOWING - 66))
                                        | (1usize << (FORMAT - 66))))
                                    != 0)
                            || (((_la - 100) & !0x3f) == 0
                                && ((1usize << (_la - 100))
                                    & ((1usize << (FUNCTIONS - 100))
                                        | (1usize << (GRACE - 100))
                                        | (1usize << (GRANT - 100))
                                        | (1usize << (GRANTED - 100))
                                        | (1usize << (GRANTS - 100))
                                        | (1usize << (GRAPHVIZ - 100))
                                        | (1usize << (GROUPING - 100))
                                        | (1usize << (GROUPS - 100))
                                        | (1usize << (HOUR - 100))
                                        | (1usize << (IF - 100))
                                        | (1usize << (IGNORE - 100))
                                        | (1usize << (INCLUDING - 100))
                                        | (1usize << (INITIAL - 100))
                                        | (1usize << (INPUT - 100))
                                        | (1usize << (INTERVAL - 100))
                                        | (1usize << (INVOKER - 100))
                                        | (1usize << (IO - 100))
                                        | (1usize << (ISOLATION - 100))
                                        | (1usize << (JSON - 100))
                                        | (1usize << (JSON_ARRAY - 100))
                                        | (1usize << (JSON_EXISTS - 100))
                                        | (1usize << (JSON_OBJECT - 100))
                                        | (1usize << (JSON_QUERY - 100))))
                                    != 0)
                            || (((_la - 132) & !0x3f) == 0
                                && ((1usize << (_la - 132))
                                    & ((1usize << (JSON_VALUE - 132))
                                        | (1usize << (KEEP - 132))
                                        | (1usize << (KEY - 132))
                                        | (1usize << (KEYS - 132))
                                        | (1usize << (LAST - 132))
                                        | (1usize << (LATERAL - 132))
                                        | (1usize << (LEADING - 132))
                                        | (1usize << (LEVEL - 132))
                                        | (1usize << (LIMIT - 132))
                                        | (1usize << (LISTAGG - 132))
                                        | (1usize << (LOCAL - 132))
                                        | (1usize << (LOCALTIME - 132))
                                        | (1usize << (LOCALTIMESTAMP - 132))
                                        | (1usize << (LOGICAL - 132))
                                        | (1usize << (MAP - 132))
                                        | (1usize << (MATCH - 132))
                                        | (1usize << (MATCHED - 132))
                                        | (1usize << (MATCHES - 132))
                                        | (1usize << (MATCH_RECOGNIZE - 132))
                                        | (1usize << (MATERIALIZED - 132))
                                        | (1usize << (MEASURES - 132))
                                        | (1usize << (MERGE - 132))
                                        | (1usize << (MINUTE - 132))
                                        | (1usize << (MONTH - 132))
                                        | (1usize << (NEXT - 132))
                                        | (1usize << (NFC - 132))
                                        | (1usize << (NFD - 132))
                                        | (1usize << (NFKC - 132))
                                        | (1usize << (NFKD - 132))))
                                    != 0)
                            || (((_la - 164) & !0x3f) == 0
                                && ((1usize << (_la - 164))
                                    & ((1usize << (NO - 164))
                                        | (1usize << (NONE - 164))
                                        | (1usize << (NORMALIZE - 164))
                                        | (1usize << (NOT - 164))
                                        | (1usize << (NULL - 164))
                                        | (1usize << (NULLIF - 164))
                                        | (1usize << (NULLS - 164))
                                        | (1usize << (OBJECT - 164))
                                        | (1usize << (OF - 164))
                                        | (1usize << (OFFSET - 164))
                                        | (1usize << (OMIT - 164))
                                        | (1usize << (ONE - 164))
                                        | (1usize << (ONLY - 164))
                                        | (1usize << (OPTION - 164))
                                        | (1usize << (ORDINALITY - 164))
                                        | (1usize << (OUTPUT - 164))
                                        | (1usize << (OVER - 164))
                                        | (1usize << (OVERFLOW - 164))
                                        | (1usize << (PARTITION - 164))
                                        | (1usize << (PARTITIONS - 164))
                                        | (1usize << (PASSING - 164))
                                        | (1usize << (PAST - 164))
                                        | (1usize << (PATH - 164))
                                        | (1usize << (PATTERN - 164))
                                        | (1usize << (PER - 164))
                                        | (1usize << (PERIOD - 164))
                                        | (1usize << (PERMUTE - 164))
                                        | (1usize << (POSITION - 164))))
                                    != 0)
                            || (((_la - 196) & !0x3f) == 0
                                && ((1usize << (_la - 196))
                                    & ((1usize << (PRECEDING - 196))
                                        | (1usize << (PRECISION - 196))
                                        | (1usize << (PRIVILEGES - 196))
                                        | (1usize << (PROPERTIES - 196))
                                        | (1usize << (PRUNE - 196))
                                        | (1usize << (QUOTES - 196))
                                        | (1usize << (RANGE - 196))
                                        | (1usize << (READ - 196))
                                        | (1usize << (REFRESH - 196))
                                        | (1usize << (RENAME - 196))
                                        | (1usize << (REPEATABLE - 196))
                                        | (1usize << (REPLACE - 196))
                                        | (1usize << (RESET - 196))
                                        | (1usize << (RESPECT - 196))
                                        | (1usize << (RESTRICT - 196))
                                        | (1usize << (RETURNING - 196))
                                        | (1usize << (REVOKE - 196))
                                        | (1usize << (ROLE - 196))
                                        | (1usize << (ROLES - 196))
                                        | (1usize << (ROLLBACK - 196))
                                        | (1usize << (ROW - 196))
                                        | (1usize << (ROWS - 196))
                                        | (1usize << (RUNNING - 196))
                                        | (1usize << (SCALAR - 196))
                                        | (1usize << (SCHEMA - 196))
                                        | (1usize << (SCHEMAS - 196))
                                        | (1usize << (SECOND - 196))
                                        | (1usize << (SECURITY - 196))))
                                    != 0)
                            || (((_la - 228) & !0x3f) == 0
                                && ((1usize << (_la - 228))
                                    & ((1usize << (SEEK - 228))
                                        | (1usize << (SERIALIZABLE - 228))
                                        | (1usize << (SESSION - 228))
                                        | (1usize << (SET - 228))
                                        | (1usize << (SETS - 228))
                                        | (1usize << (SHOW - 228))
                                        | (1usize << (SOME - 228))
                                        | (1usize << (START - 228))
                                        | (1usize << (STATS - 228))
                                        | (1usize << (SUBSET - 228))
                                        | (1usize << (SUBSTRING - 228))
                                        | (1usize << (SYSTEM - 228))
                                        | (1usize << (TABLES - 228))
                                        | (1usize << (TABLESAMPLE - 228))
                                        | (1usize << (TEXT - 228))
                                        | (1usize << (TEXT_STRING - 228))
                                        | (1usize << (TIES - 228))
                                        | (1usize << (TIME - 228))
                                        | (1usize << (TIMESTAMP - 228))
                                        | (1usize << (TO - 228))
                                        | (1usize << (TRAILING - 228))
                                        | (1usize << (TRANSACTION - 228))
                                        | (1usize << (TRIM - 228))
                                        | (1usize << (TRUE - 228))
                                        | (1usize << (TRUNCATE - 228))
                                        | (1usize << (TRY_CAST - 228))
                                        | (1usize << (TYPE - 228))
                                        | (1usize << (UNBOUNDED - 228))))
                                    != 0)
                            || (((_la - 260) & !0x3f) == 0
                                && ((1usize << (_la - 260))
                                    & ((1usize << (UNCOMMITTED - 260))
                                        | (1usize << (UNCONDITIONAL - 260))
                                        | (1usize << (UNIQUE - 260))
                                        | (1usize << (UNKNOWN - 260))
                                        | (1usize << (UNMATCHED - 260))
                                        | (1usize << (UPDATE - 260))
                                        | (1usize << (USE - 260))
                                        | (1usize << (USER - 260))
                                        | (1usize << (UTF16 - 260))
                                        | (1usize << (UTF32 - 260))
                                        | (1usize << (UTF8 - 260))
                                        | (1usize << (VALIDATE - 260))
                                        | (1usize << (VALUE - 260))
                                        | (1usize << (VERBOSE - 260))
                                        | (1usize << (VERSION - 260))
                                        | (1usize << (VIEW - 260))
                                        | (1usize << (WINDOW - 260))
                                        | (1usize << (WITHIN - 260))
                                        | (1usize << (WITHOUT - 260))
                                        | (1usize << (WORK - 260))
                                        | (1usize << (WRAPPER - 260))
                                        | (1usize << (WRITE - 260))
                                        | (1usize << (YEAR - 260))
                                        | (1usize << (ZONE - 260))))
                                    != 0)
                            || (((_la - 297) & !0x3f) == 0
                                && ((1usize << (_la - 297))
                                    & ((1usize << (PLUS - 297))
                                        | (1usize << (MINUS - 297))
                                        | (1usize << (QUESTION_MARK - 297))
                                        | (1usize << (STRING - 297))
                                        | (1usize << (UNICODE_STRING - 297))
                                        | (1usize << (BINARY_LITERAL - 297))
                                        | (1usize << (INTEGER_VALUE - 297))
                                        | (1usize << (DECIMAL_VALUE - 297))
                                        | (1usize << (DOUBLE_VALUE - 297))
                                        | (1usize << (IDENTIFIER - 297))
                                        | (1usize << (DIGIT_IDENTIFIER - 297))
                                        | (1usize << (QUOTED_IDENTIFIER - 297))
                                        | (1usize << (BACKQUOTED_IDENTIFIER - 297))))
                                    != 0)
                        {
                            {
                                /*InvokeRule expression*/
                                recog.base.set_state(1256);
                                recog.expression()?;

                                recog.base.set_state(1261);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(1257);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule expression*/
                                            recog.base.set_state(1258);
                                            recog.expression()?;
                                        }
                                    }
                                    recog.base.set_state(1263);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                            }
                        }

                        recog.base.set_state(1266);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    let tmp = MultipleGroupingSetsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1267);
                        recog.base.match_token(GROUPING, &mut recog.err_handler)?;

                        recog.base.set_state(1268);
                        recog.base.match_token(SETS, &mut recog.err_handler)?;

                        recog.base.set_state(1269);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule groupingSet*/
                        recog.base.set_state(1270);
                        recog.groupingSet()?;

                        recog.base.set_state(1275);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1271);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule groupingSet*/
                                    recog.base.set_state(1272);
                                    recog.groupingSet()?;
                                }
                            }
                            recog.base.set_state(1277);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1278);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- groupingSet ----------------
pub type GroupingSetContextAll<'input> = GroupingSetContext<'input>;

pub type GroupingSetContext<'input> =
    BaseParserRuleContext<'input, GroupingSetContextExt<'input>>;

#[derive(Clone)]
pub struct GroupingSetContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for GroupingSetContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GroupingSetContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_groupingSet(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_groupingSet(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for GroupingSetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_groupingSet
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_groupingSet }
}
antlr_rust::tid! {GroupingSetContextExt<'a>}

impl<'input> GroupingSetContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<GroupingSetContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            GroupingSetContextExt { ph: PhantomData },
        ))
    }
}

pub trait GroupingSetContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<GroupingSetContextExt<'input>>
{
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> GroupingSetContextAttrs<'input> for GroupingSetContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn groupingSet(
        &mut self,
    ) -> Result<Rc<GroupingSetContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            GroupingSetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 50, RULE_groupingSet);
        let mut _localctx: Rc<GroupingSetContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1295);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(154, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1282);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        recog.base.set_state(1291);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << T__1)
                                    | (1usize << ABSENT)
                                    | (1usize << ADD)
                                    | (1usize << ADMIN)
                                    | (1usize << AFTER)
                                    | (1usize << ALL)
                                    | (1usize << ANALYZE)
                                    | (1usize << ANY)
                                    | (1usize << ARRAY)
                                    | (1usize << ASC)
                                    | (1usize << AT)
                                    | (1usize << AUTHORIZATION)
                                    | (1usize << BERNOULLI)))
                                != 0)
                            || (((_la - 33) & !0x3f) == 0
                                && ((1usize << (_la - 33))
                                    & ((1usize << (BOTH - 33))
                                        | (1usize << (CALL - 33))
                                        | (1usize << (CASCADE - 33))
                                        | (1usize << (CASE - 33))
                                        | (1usize << (CAST - 33))
                                        | (1usize << (CATALOGS - 33))
                                        | (1usize << (COLUMN - 33))
                                        | (1usize << (COLUMNS - 33))
                                        | (1usize << (COMMENT - 33))
                                        | (1usize << (COMMIT - 33))
                                        | (1usize << (COMMITTED - 33))
                                        | (1usize << (CONDITIONAL - 33))
                                        | (1usize << (COUNT - 33))
                                        | (1usize << (COPARTITION - 33))
                                        | (1usize << (CURRENT - 33))
                                        | (1usize << (CURRENT_CATALOG - 33))
                                        | (1usize << (CURRENT_DATE - 33))
                                        | (1usize << (CURRENT_PATH - 33))
                                        | (1usize << (CURRENT_SCHEMA - 33))
                                        | (1usize << (CURRENT_TIME - 33))
                                        | (1usize << (CURRENT_TIMESTAMP - 33))
                                        | (1usize << (CURRENT_USER - 33))
                                        | (1usize << (DATA - 33))
                                        | (1usize << (DATE - 33))
                                        | (1usize << (DAY - 33))))
                                    != 0)
                            || (((_la - 66) & !0x3f) == 0
                                && ((1usize << (_la - 66))
                                    & ((1usize << (DEFAULT - 66))
                                        | (1usize << (DEFINE - 66))
                                        | (1usize << (DEFINER - 66))
                                        | (1usize << (DENY - 66))
                                        | (1usize << (DESC - 66))
                                        | (1usize << (DESCRIPTOR - 66))
                                        | (1usize << (DISTRIBUTED - 66))
                                        | (1usize << (DOUBLE - 66))
                                        | (1usize << (EMPTY - 66))
                                        | (1usize << (ENCODING - 66))
                                        | (1usize << (ERROR - 66))
                                        | (1usize << (EXCLUDING - 66))
                                        | (1usize << (EXISTS - 66))
                                        | (1usize << (EXPLAIN - 66))
                                        | (1usize << (EXTRACT - 66))
                                        | (1usize << (FALSE - 66))
                                        | (1usize << (FETCH - 66))
                                        | (1usize << (FILTER - 66))
                                        | (1usize << (FINAL - 66))
                                        | (1usize << (FIRST - 66))
                                        | (1usize << (FOLLOWING - 66))
                                        | (1usize << (FORMAT - 66))))
                                    != 0)
                            || (((_la - 100) & !0x3f) == 0
                                && ((1usize << (_la - 100))
                                    & ((1usize << (FUNCTIONS - 100))
                                        | (1usize << (GRACE - 100))
                                        | (1usize << (GRANT - 100))
                                        | (1usize << (GRANTED - 100))
                                        | (1usize << (GRANTS - 100))
                                        | (1usize << (GRAPHVIZ - 100))
                                        | (1usize << (GROUPING - 100))
                                        | (1usize << (GROUPS - 100))
                                        | (1usize << (HOUR - 100))
                                        | (1usize << (IF - 100))
                                        | (1usize << (IGNORE - 100))
                                        | (1usize << (INCLUDING - 100))
                                        | (1usize << (INITIAL - 100))
                                        | (1usize << (INPUT - 100))
                                        | (1usize << (INTERVAL - 100))
                                        | (1usize << (INVOKER - 100))
                                        | (1usize << (IO - 100))
                                        | (1usize << (ISOLATION - 100))
                                        | (1usize << (JSON - 100))
                                        | (1usize << (JSON_ARRAY - 100))
                                        | (1usize << (JSON_EXISTS - 100))
                                        | (1usize << (JSON_OBJECT - 100))
                                        | (1usize << (JSON_QUERY - 100))))
                                    != 0)
                            || (((_la - 132) & !0x3f) == 0
                                && ((1usize << (_la - 132))
                                    & ((1usize << (JSON_VALUE - 132))
                                        | (1usize << (KEEP - 132))
                                        | (1usize << (KEY - 132))
                                        | (1usize << (KEYS - 132))
                                        | (1usize << (LAST - 132))
                                        | (1usize << (LATERAL - 132))
                                        | (1usize << (LEADING - 132))
                                        | (1usize << (LEVEL - 132))
                                        | (1usize << (LIMIT - 132))
                                        | (1usize << (LISTAGG - 132))
                                        | (1usize << (LOCAL - 132))
                                        | (1usize << (LOCALTIME - 132))
                                        | (1usize << (LOCALTIMESTAMP - 132))
                                        | (1usize << (LOGICAL - 132))
                                        | (1usize << (MAP - 132))
                                        | (1usize << (MATCH - 132))
                                        | (1usize << (MATCHED - 132))
                                        | (1usize << (MATCHES - 132))
                                        | (1usize << (MATCH_RECOGNIZE - 132))
                                        | (1usize << (MATERIALIZED - 132))
                                        | (1usize << (MEASURES - 132))
                                        | (1usize << (MERGE - 132))
                                        | (1usize << (MINUTE - 132))
                                        | (1usize << (MONTH - 132))
                                        | (1usize << (NEXT - 132))
                                        | (1usize << (NFC - 132))
                                        | (1usize << (NFD - 132))
                                        | (1usize << (NFKC - 132))
                                        | (1usize << (NFKD - 132))))
                                    != 0)
                            || (((_la - 164) & !0x3f) == 0
                                && ((1usize << (_la - 164))
                                    & ((1usize << (NO - 164))
                                        | (1usize << (NONE - 164))
                                        | (1usize << (NORMALIZE - 164))
                                        | (1usize << (NOT - 164))
                                        | (1usize << (NULL - 164))
                                        | (1usize << (NULLIF - 164))
                                        | (1usize << (NULLS - 164))
                                        | (1usize << (OBJECT - 164))
                                        | (1usize << (OF - 164))
                                        | (1usize << (OFFSET - 164))
                                        | (1usize << (OMIT - 164))
                                        | (1usize << (ONE - 164))
                                        | (1usize << (ONLY - 164))
                                        | (1usize << (OPTION - 164))
                                        | (1usize << (ORDINALITY - 164))
                                        | (1usize << (OUTPUT - 164))
                                        | (1usize << (OVER - 164))
                                        | (1usize << (OVERFLOW - 164))
                                        | (1usize << (PARTITION - 164))
                                        | (1usize << (PARTITIONS - 164))
                                        | (1usize << (PASSING - 164))
                                        | (1usize << (PAST - 164))
                                        | (1usize << (PATH - 164))
                                        | (1usize << (PATTERN - 164))
                                        | (1usize << (PER - 164))
                                        | (1usize << (PERIOD - 164))
                                        | (1usize << (PERMUTE - 164))
                                        | (1usize << (POSITION - 164))))
                                    != 0)
                            || (((_la - 196) & !0x3f) == 0
                                && ((1usize << (_la - 196))
                                    & ((1usize << (PRECEDING - 196))
                                        | (1usize << (PRECISION - 196))
                                        | (1usize << (PRIVILEGES - 196))
                                        | (1usize << (PROPERTIES - 196))
                                        | (1usize << (PRUNE - 196))
                                        | (1usize << (QUOTES - 196))
                                        | (1usize << (RANGE - 196))
                                        | (1usize << (READ - 196))
                                        | (1usize << (REFRESH - 196))
                                        | (1usize << (RENAME - 196))
                                        | (1usize << (REPEATABLE - 196))
                                        | (1usize << (REPLACE - 196))
                                        | (1usize << (RESET - 196))
                                        | (1usize << (RESPECT - 196))
                                        | (1usize << (RESTRICT - 196))
                                        | (1usize << (RETURNING - 196))
                                        | (1usize << (REVOKE - 196))
                                        | (1usize << (ROLE - 196))
                                        | (1usize << (ROLES - 196))
                                        | (1usize << (ROLLBACK - 196))
                                        | (1usize << (ROW - 196))
                                        | (1usize << (ROWS - 196))
                                        | (1usize << (RUNNING - 196))
                                        | (1usize << (SCALAR - 196))
                                        | (1usize << (SCHEMA - 196))
                                        | (1usize << (SCHEMAS - 196))
                                        | (1usize << (SECOND - 196))
                                        | (1usize << (SECURITY - 196))))
                                    != 0)
                            || (((_la - 228) & !0x3f) == 0
                                && ((1usize << (_la - 228))
                                    & ((1usize << (SEEK - 228))
                                        | (1usize << (SERIALIZABLE - 228))
                                        | (1usize << (SESSION - 228))
                                        | (1usize << (SET - 228))
                                        | (1usize << (SETS - 228))
                                        | (1usize << (SHOW - 228))
                                        | (1usize << (SOME - 228))
                                        | (1usize << (START - 228))
                                        | (1usize << (STATS - 228))
                                        | (1usize << (SUBSET - 228))
                                        | (1usize << (SUBSTRING - 228))
                                        | (1usize << (SYSTEM - 228))
                                        | (1usize << (TABLES - 228))
                                        | (1usize << (TABLESAMPLE - 228))
                                        | (1usize << (TEXT - 228))
                                        | (1usize << (TEXT_STRING - 228))
                                        | (1usize << (TIES - 228))
                                        | (1usize << (TIME - 228))
                                        | (1usize << (TIMESTAMP - 228))
                                        | (1usize << (TO - 228))
                                        | (1usize << (TRAILING - 228))
                                        | (1usize << (TRANSACTION - 228))
                                        | (1usize << (TRIM - 228))
                                        | (1usize << (TRUE - 228))
                                        | (1usize << (TRUNCATE - 228))
                                        | (1usize << (TRY_CAST - 228))
                                        | (1usize << (TYPE - 228))
                                        | (1usize << (UNBOUNDED - 228))))
                                    != 0)
                            || (((_la - 260) & !0x3f) == 0
                                && ((1usize << (_la - 260))
                                    & ((1usize << (UNCOMMITTED - 260))
                                        | (1usize << (UNCONDITIONAL - 260))
                                        | (1usize << (UNIQUE - 260))
                                        | (1usize << (UNKNOWN - 260))
                                        | (1usize << (UNMATCHED - 260))
                                        | (1usize << (UPDATE - 260))
                                        | (1usize << (USE - 260))
                                        | (1usize << (USER - 260))
                                        | (1usize << (UTF16 - 260))
                                        | (1usize << (UTF32 - 260))
                                        | (1usize << (UTF8 - 260))
                                        | (1usize << (VALIDATE - 260))
                                        | (1usize << (VALUE - 260))
                                        | (1usize << (VERBOSE - 260))
                                        | (1usize << (VERSION - 260))
                                        | (1usize << (VIEW - 260))
                                        | (1usize << (WINDOW - 260))
                                        | (1usize << (WITHIN - 260))
                                        | (1usize << (WITHOUT - 260))
                                        | (1usize << (WORK - 260))
                                        | (1usize << (WRAPPER - 260))
                                        | (1usize << (WRITE - 260))
                                        | (1usize << (YEAR - 260))
                                        | (1usize << (ZONE - 260))))
                                    != 0)
                            || (((_la - 297) & !0x3f) == 0
                                && ((1usize << (_la - 297))
                                    & ((1usize << (PLUS - 297))
                                        | (1usize << (MINUS - 297))
                                        | (1usize << (QUESTION_MARK - 297))
                                        | (1usize << (STRING - 297))
                                        | (1usize << (UNICODE_STRING - 297))
                                        | (1usize << (BINARY_LITERAL - 297))
                                        | (1usize << (INTEGER_VALUE - 297))
                                        | (1usize << (DECIMAL_VALUE - 297))
                                        | (1usize << (DOUBLE_VALUE - 297))
                                        | (1usize << (IDENTIFIER - 297))
                                        | (1usize << (DIGIT_IDENTIFIER - 297))
                                        | (1usize << (QUOTED_IDENTIFIER - 297))
                                        | (1usize << (BACKQUOTED_IDENTIFIER - 297))))
                                    != 0)
                        {
                            {
                                /*InvokeRule expression*/
                                recog.base.set_state(1283);
                                recog.expression()?;

                                recog.base.set_state(1288);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(1284);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule expression*/
                                            recog.base.set_state(1285);
                                            recog.expression()?;
                                        }
                                    }
                                    recog.base.set_state(1290);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                            }
                        }

                        recog.base.set_state(1293);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /*InvokeRule expression*/
                        recog.base.set_state(1294);
                        recog.expression()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- windowDefinition ----------------
pub type WindowDefinitionContextAll<'input> = WindowDefinitionContext<'input>;

pub type WindowDefinitionContext<'input> =
    BaseParserRuleContext<'input, WindowDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct WindowDefinitionContextExt<'input> {
    pub name: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for WindowDefinitionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for WindowDefinitionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_windowDefinition(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_windowDefinition(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for WindowDefinitionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_windowDefinition
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_windowDefinition }
}
antlr_rust::tid! {WindowDefinitionContextExt<'a>}

impl<'input> WindowDefinitionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<WindowDefinitionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            WindowDefinitionContextExt {
                name: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait WindowDefinitionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<WindowDefinitionContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn windowSpecification(&self) -> Option<Rc<WindowSpecificationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> WindowDefinitionContextAttrs<'input> for WindowDefinitionContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn windowDefinition(
        &mut self,
    ) -> Result<Rc<WindowDefinitionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            WindowDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 52, RULE_windowDefinition);
        let mut _localctx: Rc<WindowDefinitionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(1297);
                let tmp = recog.identifier()?;
                cast_mut::<_, WindowDefinitionContext>(&mut _localctx).name =
                    Some(tmp.clone());

                recog.base.set_state(1298);
                recog.base.match_token(AS, &mut recog.err_handler)?;

                recog.base.set_state(1299);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                /*InvokeRule windowSpecification*/
                recog.base.set_state(1300);
                recog.windowSpecification()?;

                recog.base.set_state(1301);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- windowSpecification ----------------
pub type WindowSpecificationContextAll<'input> = WindowSpecificationContext<'input>;

pub type WindowSpecificationContext<'input> =
    BaseParserRuleContext<'input, WindowSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct WindowSpecificationContextExt<'input> {
    pub existingWindowName: Option<Rc<IdentifierContextAll<'input>>>,
    pub expression: Option<Rc<ExpressionContextAll<'input>>>,
    pub partition: Vec<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for WindowSpecificationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for WindowSpecificationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_windowSpecification(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_windowSpecification(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for WindowSpecificationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_windowSpecification
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_windowSpecification }
}
antlr_rust::tid! {WindowSpecificationContextExt<'a>}

impl<'input> WindowSpecificationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<WindowSpecificationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            WindowSpecificationContextExt {
                existingWindowName: None,
                expression: None,
                partition: Vec::new(),
                ph: PhantomData,
            },
        ))
    }
}

pub trait WindowSpecificationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<WindowSpecificationContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARTITION
    /// Returns `None` if there is no child corresponding to token PARTITION
    fn PARTITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARTITION, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token BY in current rule
    fn BY_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
    /// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
    fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, i)
    }
    /// Retrieves first TerminalNode corresponding to token ORDER
    /// Returns `None` if there is no child corresponding to token ORDER
    fn ORDER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDER, 0)
    }
    fn sortItem_all(&self) -> Vec<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn windowFrame(&self) -> Option<Rc<WindowFrameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> WindowSpecificationContextAttrs<'input>
    for WindowSpecificationContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn windowSpecification(
        &mut self,
    ) -> Result<Rc<WindowSpecificationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = WindowSpecificationContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 54, RULE_windowSpecification);
        let mut _localctx: Rc<WindowSpecificationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1304);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(155, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /*InvokeRule identifier*/
                            recog.base.set_state(1303);
                            let tmp = recog.identifier()?;
                            cast_mut::<_, WindowSpecificationContext>(&mut _localctx)
                                .existingWindowName = Some(tmp.clone());
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1316);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARTITION {
                    {
                        recog.base.set_state(1306);
                        recog.base.match_token(PARTITION, &mut recog.err_handler)?;

                        recog.base.set_state(1307);
                        recog.base.match_token(BY, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(1308);
                        let tmp = recog.expression()?;
                        cast_mut::<_, WindowSpecificationContext>(&mut _localctx)
                            .expression = Some(tmp.clone());

                        let temp =
                            cast_mut::<_, WindowSpecificationContext>(&mut _localctx)
                                .expression
                                .clone()
                                .unwrap();
                        cast_mut::<_, WindowSpecificationContext>(&mut _localctx)
                            .partition
                            .push(temp);

                        recog.base.set_state(1313);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1309);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(1310);
                                    let tmp = recog.expression()?;
                                    cast_mut::<_, WindowSpecificationContext>(
                                        &mut _localctx,
                                    )
                                    .expression = Some(tmp.clone());

                                    let temp = cast_mut::<_, WindowSpecificationContext>(
                                        &mut _localctx,
                                    )
                                    .expression
                                    .clone()
                                    .unwrap();
                                    cast_mut::<_, WindowSpecificationContext>(
                                        &mut _localctx,
                                    )
                                    .partition
                                    .push(temp);
                                }
                            }
                            recog.base.set_state(1315);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }

                recog.base.set_state(1328);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == ORDER {
                    {
                        recog.base.set_state(1318);
                        recog.base.match_token(ORDER, &mut recog.err_handler)?;

                        recog.base.set_state(1319);
                        recog.base.match_token(BY, &mut recog.err_handler)?;

                        /*InvokeRule sortItem*/
                        recog.base.set_state(1320);
                        recog.sortItem()?;

                        recog.base.set_state(1325);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1321);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule sortItem*/
                                    recog.base.set_state(1322);
                                    recog.sortItem()?;
                                }
                            }
                            recog.base.set_state(1327);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }

                recog.base.set_state(1331);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == GROUPS || _la == MEASURES || _la == RANGE || _la == ROWS {
                    {
                        /*InvokeRule windowFrame*/
                        recog.base.set_state(1330);
                        recog.windowFrame()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namedQuery ----------------
pub type NamedQueryContextAll<'input> = NamedQueryContext<'input>;

pub type NamedQueryContext<'input> =
    BaseParserRuleContext<'input, NamedQueryContextExt<'input>>;

#[derive(Clone)]
pub struct NamedQueryContextExt<'input> {
    pub name: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for NamedQueryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NamedQueryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namedQuery(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_namedQuery(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for NamedQueryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namedQuery
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namedQuery }
}
antlr_rust::tid! {NamedQueryContextExt<'a>}

impl<'input> NamedQueryContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NamedQueryContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            NamedQueryContextExt {
                name: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait NamedQueryContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<NamedQueryContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> NamedQueryContextAttrs<'input> for NamedQueryContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namedQuery(&mut self) -> Result<Rc<NamedQueryContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            NamedQueryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 56, RULE_namedQuery);
        let mut _localctx: Rc<NamedQueryContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(1333);
                let tmp = recog.identifier()?;
                cast_mut::<_, NamedQueryContext>(&mut _localctx).name = Some(tmp.clone());

                recog.base.set_state(1335);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == T__1 {
                    {
                        /*InvokeRule columnAliases*/
                        recog.base.set_state(1334);
                        recog.columnAliases()?;
                    }
                }

                recog.base.set_state(1337);
                recog.base.match_token(AS, &mut recog.err_handler)?;

                recog.base.set_state(1338);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                /*InvokeRule query*/
                recog.base.set_state(1339);
                recog.query()?;

                recog.base.set_state(1340);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- setQuantifier ----------------
pub type SetQuantifierContextAll<'input> = SetQuantifierContext<'input>;

pub type SetQuantifierContext<'input> =
    BaseParserRuleContext<'input, SetQuantifierContextExt<'input>>;

#[derive(Clone)]
pub struct SetQuantifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SetQuantifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SetQuantifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_setQuantifier(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_setQuantifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for SetQuantifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_setQuantifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_setQuantifier }
}
antlr_rust::tid! {SetQuantifierContextExt<'a>}

impl<'input> SetQuantifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SetQuantifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            SetQuantifierContextExt { ph: PhantomData },
        ))
    }
}

pub trait SetQuantifierContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SetQuantifierContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token DISTINCT
    /// Returns `None` if there is no child corresponding to token DISTINCT
    fn DISTINCT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DISTINCT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
}

impl<'input> SetQuantifierContextAttrs<'input> for SetQuantifierContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn setQuantifier(
        &mut self,
    ) -> Result<Rc<SetQuantifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SetQuantifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 58, RULE_setQuantifier);
        let mut _localctx: Rc<SetQuantifierContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1342);
                _la = recog.base.input.la(1);
                if { !(_la == ALL || _la == DISTINCT) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- selectItem ----------------
#[derive(Debug)]
pub enum SelectItemContextAll<'input> {
    SelectAllContext(SelectAllContext<'input>),
    SelectSingleContext(SelectSingleContext<'input>),
    Error(SelectItemContext<'input>),
}
antlr_rust::tid! {SelectItemContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for SelectItemContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for SelectItemContextAll<'input> {}

impl<'input> Deref for SelectItemContextAll<'input> {
    type Target = dyn SelectItemContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use SelectItemContextAll::*;
        match self {
            SelectAllContext(inner) => inner,
            SelectSingleContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SelectItemContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type SelectItemContext<'input> =
    BaseParserRuleContext<'input, SelectItemContextExt<'input>>;

#[derive(Clone)]
pub struct SelectItemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SelectItemContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SelectItemContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for SelectItemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_selectItem
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_selectItem }
}
antlr_rust::tid! {SelectItemContextExt<'a>}

impl<'input> SelectItemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SelectItemContextAll<'input>> {
        Rc::new(SelectItemContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                SelectItemContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait SelectItemContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SelectItemContextExt<'input>>
{
}

impl<'input> SelectItemContextAttrs<'input> for SelectItemContext<'input> {}

pub type SelectAllContext<'input> =
    BaseParserRuleContext<'input, SelectAllContextExt<'input>>;

pub trait SelectAllContextAttrs<'input>: PrestoParserContext<'input> {
    fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token ASTERISK
    /// Returns `None` if there is no child corresponding to token ASTERISK
    fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ASTERISK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SelectAllContextAttrs<'input> for SelectAllContext<'input> {}

pub struct SelectAllContextExt<'input> {
    base: SelectItemContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SelectAllContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SelectAllContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SelectAllContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_selectAll(self);
    }
}

impl<'input> CustomRuleContext<'input> for SelectAllContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_selectItem
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_selectItem }
}

impl<'input> Borrow<SelectItemContextExt<'input>> for SelectAllContext<'input> {
    fn borrow(&self) -> &SelectItemContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<SelectItemContextExt<'input>> for SelectAllContext<'input> {
    fn borrow_mut(&mut self) -> &mut SelectItemContextExt<'input> {
        &mut self.base
    }
}

impl<'input> SelectItemContextAttrs<'input> for SelectAllContext<'input> {}

impl<'input> SelectAllContextExt<'input> {
    fn new(ctx: &dyn SelectItemContextAttrs<'input>) -> Rc<SelectItemContextAll<'input>> {
        Rc::new(SelectItemContextAll::SelectAllContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SelectAllContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SelectSingleContext<'input> =
    BaseParserRuleContext<'input, SelectSingleContextExt<'input>>;

pub trait SelectSingleContextAttrs<'input>: PrestoParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
}

impl<'input> SelectSingleContextAttrs<'input> for SelectSingleContext<'input> {}

pub struct SelectSingleContextExt<'input> {
    base: SelectItemContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SelectSingleContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SelectSingleContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SelectSingleContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_selectSingle(self);
    }
}

impl<'input> CustomRuleContext<'input> for SelectSingleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_selectItem
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_selectItem }
}

impl<'input> Borrow<SelectItemContextExt<'input>> for SelectSingleContext<'input> {
    fn borrow(&self) -> &SelectItemContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<SelectItemContextExt<'input>> for SelectSingleContext<'input> {
    fn borrow_mut(&mut self) -> &mut SelectItemContextExt<'input> {
        &mut self.base
    }
}

impl<'input> SelectItemContextAttrs<'input> for SelectSingleContext<'input> {}

impl<'input> SelectSingleContextExt<'input> {
    fn new(ctx: &dyn SelectItemContextAttrs<'input>) -> Rc<SelectItemContextAll<'input>> {
        Rc::new(SelectItemContextAll::SelectSingleContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SelectSingleContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn selectItem(&mut self) -> Result<Rc<SelectItemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SelectItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 60, RULE_selectItem);
        let mut _localctx: Rc<SelectItemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1359);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(165, &mut recog.base)? {
                1 => {
                    let tmp = SelectSingleContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule expression*/
                        recog.base.set_state(1344);
                        recog.expression()?;

                        recog.base.set_state(1349);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(163, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1346);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == AS {
                                        {
                                            recog.base.set_state(1345);
                                            recog.base.match_token(
                                                AS,
                                                &mut recog.err_handler,
                                            )?;
                                        }
                                    }

                                    /*InvokeRule identifier*/
                                    recog.base.set_state(1348);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    let tmp = SelectAllContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /*InvokeRule primaryExpression*/
                        recog.base.set_state(1351);
                        recog.primaryExpression_rec(0)?;

                        recog.base.set_state(1352);
                        recog.base.match_token(T__0, &mut recog.err_handler)?;

                        recog.base.set_state(1353);
                        recog.base.match_token(ASTERISK, &mut recog.err_handler)?;

                        recog.base.set_state(1356);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(164, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1354);
                                    recog.base.match_token(AS, &mut recog.err_handler)?;

                                    /*InvokeRule columnAliases*/
                                    recog.base.set_state(1355);
                                    recog.columnAliases()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                3 => {
                    let tmp = SelectAllContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1358);
                        recog.base.match_token(ASTERISK, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- relation ----------------
#[derive(Debug)]
pub enum RelationContextAll<'input> {
    RelationDefaultContext(RelationDefaultContext<'input>),
    JoinRelationContext(JoinRelationContext<'input>),
    Error(RelationContext<'input>),
}
antlr_rust::tid! {RelationContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for RelationContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for RelationContextAll<'input> {}

impl<'input> Deref for RelationContextAll<'input> {
    type Target = dyn RelationContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use RelationContextAll::*;
        match self {
            RelationDefaultContext(inner) => inner,
            JoinRelationContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RelationContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type RelationContext<'input> =
    BaseParserRuleContext<'input, RelationContextExt<'input>>;

#[derive(Clone)]
pub struct RelationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RelationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RelationContext<'input> {}

impl<'input> CustomRuleContext<'input> for RelationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relation }
}
antlr_rust::tid! {RelationContextExt<'a>}

impl<'input> RelationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RelationContextAll<'input>> {
        Rc::new(RelationContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                RelationContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait RelationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RelationContextExt<'input>>
{
}

impl<'input> RelationContextAttrs<'input> for RelationContext<'input> {}

pub type RelationDefaultContext<'input> =
    BaseParserRuleContext<'input, RelationDefaultContextExt<'input>>;

pub trait RelationDefaultContextAttrs<'input>: PrestoParserContext<'input> {
    fn sampledRelation(&self) -> Option<Rc<SampledRelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> RelationDefaultContextAttrs<'input> for RelationDefaultContext<'input> {}

pub struct RelationDefaultContextExt<'input> {
    base: RelationContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RelationDefaultContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RelationDefaultContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RelationDefaultContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_relationDefault(self);
    }
}

impl<'input> CustomRuleContext<'input> for RelationDefaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relation }
}

impl<'input> Borrow<RelationContextExt<'input>> for RelationDefaultContext<'input> {
    fn borrow(&self) -> &RelationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationContextExt<'input>> for RelationDefaultContext<'input> {
    fn borrow_mut(&mut self) -> &mut RelationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationContextAttrs<'input> for RelationDefaultContext<'input> {}

impl<'input> RelationDefaultContextExt<'input> {
    fn new(ctx: &dyn RelationContextAttrs<'input>) -> Rc<RelationContextAll<'input>> {
        Rc::new(RelationContextAll::RelationDefaultContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RelationDefaultContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type JoinRelationContext<'input> =
    BaseParserRuleContext<'input, JoinRelationContextExt<'input>>;

pub trait JoinRelationContextAttrs<'input>: PrestoParserContext<'input> {
    fn relation_all(&self) -> Vec<Rc<RelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn relation(&self, i: usize) -> Option<Rc<RelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token CROSS
    /// Returns `None` if there is no child corresponding to token CROSS
    fn CROSS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CROSS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token JOIN
    /// Returns `None` if there is no child corresponding to token JOIN
    fn JOIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JOIN, 0)
    }
    fn joinType(&self) -> Option<Rc<JoinTypeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn joinCriteria(&self) -> Option<Rc<JoinCriteriaContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NATURAL
    /// Returns `None` if there is no child corresponding to token NATURAL
    fn NATURAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NATURAL, 0)
    }
    fn sampledRelation(&self) -> Option<Rc<SampledRelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> JoinRelationContextAttrs<'input> for JoinRelationContext<'input> {}

pub struct JoinRelationContextExt<'input> {
    base: RelationContextExt<'input>,
    pub left: Option<Rc<RelationContextAll<'input>>>,
    pub right: Option<Rc<SampledRelationContextAll<'input>>>,
    pub rightRelation: Option<Rc<RelationContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {JoinRelationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for JoinRelationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JoinRelationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_joinRelation(self);
    }
}

impl<'input> CustomRuleContext<'input> for JoinRelationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relation }
}

impl<'input> Borrow<RelationContextExt<'input>> for JoinRelationContext<'input> {
    fn borrow(&self) -> &RelationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationContextExt<'input>> for JoinRelationContext<'input> {
    fn borrow_mut(&mut self) -> &mut RelationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationContextAttrs<'input> for JoinRelationContext<'input> {}

impl<'input> JoinRelationContextExt<'input> {
    fn new(ctx: &dyn RelationContextAttrs<'input>) -> Rc<RelationContextAll<'input>> {
        Rc::new(RelationContextAll::JoinRelationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                JoinRelationContextExt {
                    left: None,
                    right: None,
                    rightRelation: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn relation(&mut self) -> Result<Rc<RelationContextAll<'input>>, ANTLRError> {
        self.relation_rec(0)
    }

    fn relation_rec(
        &mut self,
        _p: isize,
    ) -> Result<Rc<RelationContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx =
            RelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_recursion_rule(_localctx.clone(), 62, RULE_relation, _p);
        let mut _localctx: Rc<RelationContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 62;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                {
                    let mut tmp = RelationDefaultContextExt::new(&**_localctx);
                    recog.ctx = Some(tmp.clone());
                    _localctx = tmp;
                    _prevctx = _localctx.clone();

                    /*InvokeRule sampledRelation*/
                    recog.base.set_state(1362);
                    recog.sampledRelation()?;
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1382);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(167, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            {
                                /*recRuleLabeledAltStartAction*/
                                let mut tmp = JoinRelationContextExt::new(
                                    &**RelationContextExt::new(
                                        _parentctx.clone(),
                                        _parentState,
                                    ),
                                );
                                if let RelationContextAll::JoinRelationContext(ctx) =
                                    cast_mut::<_, RelationContextAll>(&mut tmp)
                                {
                                    ctx.left = Some(_prevctx.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                                recog.push_new_recursion_context(
                                    tmp.clone(),
                                    _startState,
                                    RULE_relation,
                                );
                                _localctx = tmp;
                                recog.base.set_state(1364);
                                if !({ recog.precpred(None, 2) }) {
                                    Err(FailedPredicateError::new(
                                        &mut recog.base,
                                        Some("recog.precpred(None, 2)".to_owned()),
                                        None,
                                    ))?;
                                }
                                recog.base.set_state(1378);
                                recog.err_handler.sync(&mut recog.base)?;
                                match recog.base.input.la(1) {
                                    CROSS => {
                                        {
                                            recog.base.set_state(1365);
                                            recog.base.match_token(
                                                CROSS,
                                                &mut recog.err_handler,
                                            )?;

                                            recog.base.set_state(1366);
                                            recog.base.match_token(
                                                JOIN,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule sampledRelation*/
                                            recog.base.set_state(1367);
                                            let tmp = recog.sampledRelation()?;
                                            if let RelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,RelationContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                        }
                                    }

                                    FULL | INNER | JOIN | LEFT | RIGHT => {
                                        {
                                            /*InvokeRule joinType*/
                                            recog.base.set_state(1368);
                                            recog.joinType()?;

                                            recog.base.set_state(1369);
                                            recog.base.match_token(
                                                JOIN,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule relation*/
                                            recog.base.set_state(1370);
                                            let tmp = recog.relation_rec(0)?;
                                            if let RelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,RelationContextAll >(&mut _localctx){
							ctx.rightRelation = Some(tmp.clone()); } else {unreachable!("cant cast");}

                                            /*InvokeRule joinCriteria*/
                                            recog.base.set_state(1371);
                                            recog.joinCriteria()?;
                                        }
                                    }

                                    NATURAL => {
                                        {
                                            recog.base.set_state(1373);
                                            recog.base.match_token(
                                                NATURAL,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule joinType*/
                                            recog.base.set_state(1374);
                                            recog.joinType()?;

                                            recog.base.set_state(1375);
                                            recog.base.match_token(
                                                JOIN,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule sampledRelation*/
                                            recog.base.set_state(1376);
                                            let tmp = recog.sampledRelation()?;
                                            if let RelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,RelationContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                        }
                                    }

                                    _ => Err(ANTLRError::NoAltError(
                                        NoViableAltError::new(&mut recog.base),
                                    ))?,
                                }
                            }
                        }
                    }
                    recog.base.set_state(1384);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(167, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- joinType ----------------
pub type JoinTypeContextAll<'input> = JoinTypeContext<'input>;

pub type JoinTypeContext<'input> =
    BaseParserRuleContext<'input, JoinTypeContextExt<'input>>;

#[derive(Clone)]
pub struct JoinTypeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JoinTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for JoinTypeContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_joinType(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_joinType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JoinTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_joinType
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_joinType }
}
antlr_rust::tid! {JoinTypeContextExt<'a>}

impl<'input> JoinTypeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JoinTypeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JoinTypeContextExt { ph: PhantomData },
        ))
    }
}

pub trait JoinTypeContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JoinTypeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token INNER
    /// Returns `None` if there is no child corresponding to token INNER
    fn INNER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INNER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LEFT
    /// Returns `None` if there is no child corresponding to token LEFT
    fn LEFT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LEFT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OUTER
    /// Returns `None` if there is no child corresponding to token OUTER
    fn OUTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OUTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RIGHT
    /// Returns `None` if there is no child corresponding to token RIGHT
    fn RIGHT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RIGHT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FULL
    /// Returns `None` if there is no child corresponding to token FULL
    fn FULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FULL, 0)
    }
}

impl<'input> JoinTypeContextAttrs<'input> for JoinTypeContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn joinType(&mut self) -> Result<Rc<JoinTypeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JoinTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_joinType);
        let mut _localctx: Rc<JoinTypeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1400);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                INNER | JOIN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1386);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == INNER {
                            {
                                recog.base.set_state(1385);
                                recog.base.match_token(INNER, &mut recog.err_handler)?;
                            }
                        }
                    }
                }

                LEFT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1388);
                        recog.base.match_token(LEFT, &mut recog.err_handler)?;

                        recog.base.set_state(1390);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OUTER {
                            {
                                recog.base.set_state(1389);
                                recog.base.match_token(OUTER, &mut recog.err_handler)?;
                            }
                        }
                    }
                }

                RIGHT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1392);
                        recog.base.match_token(RIGHT, &mut recog.err_handler)?;

                        recog.base.set_state(1394);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OUTER {
                            {
                                recog.base.set_state(1393);
                                recog.base.match_token(OUTER, &mut recog.err_handler)?;
                            }
                        }
                    }
                }

                FULL => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1396);
                        recog.base.match_token(FULL, &mut recog.err_handler)?;

                        recog.base.set_state(1398);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OUTER {
                            {
                                recog.base.set_state(1397);
                                recog.base.match_token(OUTER, &mut recog.err_handler)?;
                            }
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- joinCriteria ----------------
pub type JoinCriteriaContextAll<'input> = JoinCriteriaContext<'input>;

pub type JoinCriteriaContext<'input> =
    BaseParserRuleContext<'input, JoinCriteriaContextExt<'input>>;

#[derive(Clone)]
pub struct JoinCriteriaContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JoinCriteriaContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JoinCriteriaContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_joinCriteria(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_joinCriteria(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JoinCriteriaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_joinCriteria
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_joinCriteria }
}
antlr_rust::tid! {JoinCriteriaContextExt<'a>}

impl<'input> JoinCriteriaContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JoinCriteriaContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JoinCriteriaContextExt { ph: PhantomData },
        ))
    }
}

pub trait JoinCriteriaContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JoinCriteriaContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token USING
    /// Returns `None` if there is no child corresponding to token USING
    fn USING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(USING, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> JoinCriteriaContextAttrs<'input> for JoinCriteriaContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn joinCriteria(
        &mut self,
    ) -> Result<Rc<JoinCriteriaContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JoinCriteriaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 66, RULE_joinCriteria);
        let mut _localctx: Rc<JoinCriteriaContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1416);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1402);
                        recog.base.match_token(ON, &mut recog.err_handler)?;

                        /*InvokeRule booleanExpression*/
                        recog.base.set_state(1403);
                        recog.booleanExpression_rec(0)?;
                    }
                }

                USING => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1404);
                        recog.base.match_token(USING, &mut recog.err_handler)?;

                        recog.base.set_state(1405);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(1406);
                        recog.identifier()?;

                        recog.base.set_state(1411);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1407);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule identifier*/
                                    recog.base.set_state(1408);
                                    recog.identifier()?;
                                }
                            }
                            recog.base.set_state(1413);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1414);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- sampledRelation ----------------
pub type SampledRelationContextAll<'input> = SampledRelationContext<'input>;

pub type SampledRelationContext<'input> =
    BaseParserRuleContext<'input, SampledRelationContextExt<'input>>;

#[derive(Clone)]
pub struct SampledRelationContextExt<'input> {
    pub percentage: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SampledRelationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SampledRelationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_sampledRelation(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_sampledRelation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for SampledRelationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_sampledRelation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_sampledRelation }
}
antlr_rust::tid! {SampledRelationContextExt<'a>}

impl<'input> SampledRelationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SampledRelationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            SampledRelationContextExt {
                percentage: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait SampledRelationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SampledRelationContextExt<'input>>
{
    fn patternRecognition(&self) -> Option<Rc<PatternRecognitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLESAMPLE
    /// Returns `None` if there is no child corresponding to token TABLESAMPLE
    fn TABLESAMPLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLESAMPLE, 0)
    }
    fn sampleType(&self) -> Option<Rc<SampleTypeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SampledRelationContextAttrs<'input> for SampledRelationContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn sampledRelation(
        &mut self,
    ) -> Result<Rc<SampledRelationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SampledRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 68, RULE_sampledRelation);
        let mut _localctx: Rc<SampledRelationContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule patternRecognition*/
                recog.base.set_state(1418);
                recog.patternRecognition()?;

                recog.base.set_state(1425);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(175, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1419);
                            recog
                                .base
                                .match_token(TABLESAMPLE, &mut recog.err_handler)?;

                            /*InvokeRule sampleType*/
                            recog.base.set_state(1420);
                            recog.sampleType()?;

                            recog.base.set_state(1421);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(1422);
                            let tmp = recog.expression()?;
                            cast_mut::<_, SampledRelationContext>(&mut _localctx)
                                .percentage = Some(tmp.clone());

                            recog.base.set_state(1423);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- sampleType ----------------
pub type SampleTypeContextAll<'input> = SampleTypeContext<'input>;

pub type SampleTypeContext<'input> =
    BaseParserRuleContext<'input, SampleTypeContextExt<'input>>;

#[derive(Clone)]
pub struct SampleTypeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SampleTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SampleTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_sampleType(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_sampleType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for SampleTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_sampleType
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_sampleType }
}
antlr_rust::tid! {SampleTypeContextExt<'a>}

impl<'input> SampleTypeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SampleTypeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            SampleTypeContextExt { ph: PhantomData },
        ))
    }
}

pub trait SampleTypeContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SampleTypeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BERNOULLI
    /// Returns `None` if there is no child corresponding to token BERNOULLI
    fn BERNOULLI(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BERNOULLI, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SYSTEM
    /// Returns `None` if there is no child corresponding to token SYSTEM
    fn SYSTEM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SYSTEM, 0)
    }
}

impl<'input> SampleTypeContextAttrs<'input> for SampleTypeContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn sampleType(&mut self) -> Result<Rc<SampleTypeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SampleTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 70, RULE_sampleType);
        let mut _localctx: Rc<SampleTypeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1427);
                _la = recog.base.input.la(1);
                if { !(_la == BERNOULLI || _la == SYSTEM) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- trimsSpecification ----------------
pub type TrimsSpecificationContextAll<'input> = TrimsSpecificationContext<'input>;

pub type TrimsSpecificationContext<'input> =
    BaseParserRuleContext<'input, TrimsSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct TrimsSpecificationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TrimsSpecificationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TrimsSpecificationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_trimsSpecification(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_trimsSpecification(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for TrimsSpecificationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_trimsSpecification
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_trimsSpecification }
}
antlr_rust::tid! {TrimsSpecificationContextExt<'a>}

impl<'input> TrimsSpecificationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TrimsSpecificationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            TrimsSpecificationContextExt { ph: PhantomData },
        ))
    }
}

pub trait TrimsSpecificationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TrimsSpecificationContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token LEADING
    /// Returns `None` if there is no child corresponding to token LEADING
    fn LEADING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LEADING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TRAILING
    /// Returns `None` if there is no child corresponding to token TRAILING
    fn TRAILING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRAILING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BOTH
    /// Returns `None` if there is no child corresponding to token BOTH
    fn BOTH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BOTH, 0)
    }
}

impl<'input> TrimsSpecificationContextAttrs<'input>
    for TrimsSpecificationContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn trimsSpecification(
        &mut self,
    ) -> Result<Rc<TrimsSpecificationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            TrimsSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 72, RULE_trimsSpecification);
        let mut _localctx: Rc<TrimsSpecificationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1429);
                _la = recog.base.input.la(1);
                if { !(_la == BOTH || _la == LEADING || _la == TRAILING) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- listAggOverflowBehavior ----------------
pub type ListAggOverflowBehaviorContextAll<'input> =
    ListAggOverflowBehaviorContext<'input>;

pub type ListAggOverflowBehaviorContext<'input> =
    BaseParserRuleContext<'input, ListAggOverflowBehaviorContextExt<'input>>;

#[derive(Clone)]
pub struct ListAggOverflowBehaviorContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ListAggOverflowBehaviorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ListAggOverflowBehaviorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_listAggOverflowBehavior(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_listAggOverflowBehavior(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ListAggOverflowBehaviorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_listAggOverflowBehavior
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_listAggOverflowBehavior }
}
antlr_rust::tid! {ListAggOverflowBehaviorContextExt<'a>}

impl<'input> ListAggOverflowBehaviorContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ListAggOverflowBehaviorContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ListAggOverflowBehaviorContextExt { ph: PhantomData },
        ))
    }
}

pub trait ListAggOverflowBehaviorContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ListAggOverflowBehaviorContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TRUNCATE
    /// Returns `None` if there is no child corresponding to token TRUNCATE
    fn TRUNCATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRUNCATE, 0)
    }
    fn listaggCountIndication(
        &self,
    ) -> Option<Rc<ListaggCountIndicationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ListAggOverflowBehaviorContextAttrs<'input>
    for ListAggOverflowBehaviorContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn listAggOverflowBehavior(
        &mut self,
    ) -> Result<Rc<ListAggOverflowBehaviorContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ListAggOverflowBehaviorContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 74, RULE_listAggOverflowBehavior);
        let mut _localctx: Rc<ListAggOverflowBehaviorContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1437);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ERROR => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1431);
                        recog.base.match_token(ERROR, &mut recog.err_handler)?;
                    }
                }

                TRUNCATE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1432);
                        recog.base.match_token(TRUNCATE, &mut recog.err_handler)?;

                        recog.base.set_state(1434);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == STRING || _la == UNICODE_STRING {
                            {
                                /*InvokeRule string*/
                                recog.base.set_state(1433);
                                recog.string()?;
                            }
                        }

                        /*InvokeRule listaggCountIndication*/
                        recog.base.set_state(1436);
                        recog.listaggCountIndication()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- listaggCountIndication ----------------
pub type ListaggCountIndicationContextAll<'input> = ListaggCountIndicationContext<'input>;

pub type ListaggCountIndicationContext<'input> =
    BaseParserRuleContext<'input, ListaggCountIndicationContextExt<'input>>;

#[derive(Clone)]
pub struct ListaggCountIndicationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ListaggCountIndicationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ListaggCountIndicationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_listaggCountIndication(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_listaggCountIndication(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ListaggCountIndicationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_listaggCountIndication
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_listaggCountIndication }
}
antlr_rust::tid! {ListaggCountIndicationContextExt<'a>}

impl<'input> ListaggCountIndicationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ListaggCountIndicationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ListaggCountIndicationContextExt { ph: PhantomData },
        ))
    }
}

pub trait ListaggCountIndicationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ListaggCountIndicationContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COUNT
    /// Returns `None` if there is no child corresponding to token COUNT
    fn COUNT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COUNT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITHOUT
    /// Returns `None` if there is no child corresponding to token WITHOUT
    fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITHOUT, 0)
    }
}

impl<'input> ListaggCountIndicationContextAttrs<'input>
    for ListaggCountIndicationContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn listaggCountIndication(
        &mut self,
    ) -> Result<Rc<ListaggCountIndicationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ListaggCountIndicationContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 76, RULE_listaggCountIndication);
        let mut _localctx: Rc<ListaggCountIndicationContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1443);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                WITH => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1439);
                        recog.base.match_token(WITH, &mut recog.err_handler)?;

                        recog.base.set_state(1440);
                        recog.base.match_token(COUNT, &mut recog.err_handler)?;
                    }
                }

                WITHOUT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1441);
                        recog.base.match_token(WITHOUT, &mut recog.err_handler)?;

                        recog.base.set_state(1442);
                        recog.base.match_token(COUNT, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- patternRecognition ----------------
pub type PatternRecognitionContextAll<'input> = PatternRecognitionContext<'input>;

pub type PatternRecognitionContext<'input> =
    BaseParserRuleContext<'input, PatternRecognitionContextExt<'input>>;

#[derive(Clone)]
pub struct PatternRecognitionContextExt<'input> {
    pub expression: Option<Rc<ExpressionContextAll<'input>>>,
    pub partition: Vec<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PatternRecognitionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternRecognitionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_patternRecognition(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_patternRecognition(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for PatternRecognitionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternRecognition
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternRecognition }
}
antlr_rust::tid! {PatternRecognitionContextExt<'a>}

impl<'input> PatternRecognitionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PatternRecognitionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            PatternRecognitionContextExt {
                expression: None,
                partition: Vec::new(),
                ph: PhantomData,
            },
        ))
    }
}

pub trait PatternRecognitionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PatternRecognitionContextExt<'input>>
{
    fn aliasedRelation(&self) -> Option<Rc<AliasedRelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCH_RECOGNIZE
    /// Returns `None` if there is no child corresponding to token MATCH_RECOGNIZE
    fn MATCH_RECOGNIZE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCH_RECOGNIZE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PATTERN
    /// Returns `None` if there is no child corresponding to token PATTERN
    fn PATTERN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PATTERN, 0)
    }
    fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token DEFINE
    /// Returns `None` if there is no child corresponding to token DEFINE
    fn DEFINE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFINE, 0)
    }
    fn variableDefinition_all(&self) -> Vec<Rc<VariableDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn variableDefinition(
        &self,
        i: usize,
    ) -> Option<Rc<VariableDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token PARTITION
    /// Returns `None` if there is no child corresponding to token PARTITION
    fn PARTITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARTITION, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token BY in current rule
    fn BY_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
    /// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
    fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, i)
    }
    /// Retrieves first TerminalNode corresponding to token ORDER
    /// Returns `None` if there is no child corresponding to token ORDER
    fn ORDER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDER, 0)
    }
    fn sortItem_all(&self) -> Vec<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token MEASURES
    /// Returns `None` if there is no child corresponding to token MEASURES
    fn MEASURES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MEASURES, 0)
    }
    fn measureDefinition_all(&self) -> Vec<Rc<MeasureDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn measureDefinition(
        &self,
        i: usize,
    ) -> Option<Rc<MeasureDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn rowsPerMatch(&self) -> Option<Rc<RowsPerMatchContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AFTER
    /// Returns `None` if there is no child corresponding to token AFTER
    fn AFTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AFTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCH
    /// Returns `None` if there is no child corresponding to token MATCH
    fn MATCH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCH, 0)
    }
    fn skipTo(&self) -> Option<Rc<SkipToContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SUBSET
    /// Returns `None` if there is no child corresponding to token SUBSET
    fn SUBSET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SUBSET, 0)
    }
    fn subsetDefinition_all(&self) -> Vec<Rc<SubsetDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn subsetDefinition(&self, i: usize) -> Option<Rc<SubsetDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token INITIAL
    /// Returns `None` if there is no child corresponding to token INITIAL
    fn INITIAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INITIAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SEEK
    /// Returns `None` if there is no child corresponding to token SEEK
    fn SEEK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEEK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> PatternRecognitionContextAttrs<'input>
    for PatternRecognitionContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn patternRecognition(
        &mut self,
    ) -> Result<Rc<PatternRecognitionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PatternRecognitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 78, RULE_patternRecognition);
        let mut _localctx: Rc<PatternRecognitionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule aliasedRelation*/
                recog.base.set_state(1445);
                recog.aliasedRelation()?;

                recog.base.set_state(1528);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(194, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1446);
                            recog
                                .base
                                .match_token(MATCH_RECOGNIZE, &mut recog.err_handler)?;

                            recog.base.set_state(1447);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(1458);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == PARTITION {
                                {
                                    recog.base.set_state(1448);
                                    recog
                                        .base
                                        .match_token(PARTITION, &mut recog.err_handler)?;

                                    recog.base.set_state(1449);
                                    recog.base.match_token(BY, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(1450);
                                    let tmp = recog.expression()?;
                                    cast_mut::<_, PatternRecognitionContext>(
                                        &mut _localctx,
                                    )
                                    .expression = Some(tmp.clone());

                                    let temp = cast_mut::<_, PatternRecognitionContext>(
                                        &mut _localctx,
                                    )
                                    .expression
                                    .clone()
                                    .unwrap();
                                    cast_mut::<_, PatternRecognitionContext>(
                                        &mut _localctx,
                                    )
                                    .partition
                                    .push(temp);

                                    recog.base.set_state(1455);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(1451);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule expression*/
                                                recog.base.set_state(1452);
                                                let tmp = recog.expression()?;
                                                cast_mut::<_,PatternRecognitionContext >(&mut _localctx).expression = Some(tmp.clone());

                                                let temp = cast_mut::<
                                                    _,
                                                    PatternRecognitionContext,
                                                >(
                                                    &mut _localctx
                                                )
                                                .expression
                                                .clone()
                                                .unwrap();
                                                cast_mut::<_, PatternRecognitionContext>(
                                                    &mut _localctx,
                                                )
                                                .partition
                                                .push(temp);
                                            }
                                        }
                                        recog.base.set_state(1457);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(1470);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == ORDER {
                                {
                                    recog.base.set_state(1460);
                                    recog
                                        .base
                                        .match_token(ORDER, &mut recog.err_handler)?;

                                    recog.base.set_state(1461);
                                    recog.base.match_token(BY, &mut recog.err_handler)?;

                                    /*InvokeRule sortItem*/
                                    recog.base.set_state(1462);
                                    recog.sortItem()?;

                                    recog.base.set_state(1467);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(1463);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule sortItem*/
                                                recog.base.set_state(1464);
                                                recog.sortItem()?;
                                            }
                                        }
                                        recog.base.set_state(1469);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(1481);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == MEASURES {
                                {
                                    recog.base.set_state(1472);
                                    recog
                                        .base
                                        .match_token(MEASURES, &mut recog.err_handler)?;

                                    /*InvokeRule measureDefinition*/
                                    recog.base.set_state(1473);
                                    recog.measureDefinition()?;

                                    recog.base.set_state(1478);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(1474);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule measureDefinition*/
                                                recog.base.set_state(1475);
                                                recog.measureDefinition()?;
                                            }
                                        }
                                        recog.base.set_state(1480);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(1484);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == ALL || _la == ONE {
                                {
                                    /*InvokeRule rowsPerMatch*/
                                    recog.base.set_state(1483);
                                    recog.rowsPerMatch()?;
                                }
                            }

                            recog.base.set_state(1489);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == AFTER {
                                {
                                    recog.base.set_state(1486);
                                    recog
                                        .base
                                        .match_token(AFTER, &mut recog.err_handler)?;

                                    recog.base.set_state(1487);
                                    recog
                                        .base
                                        .match_token(MATCH, &mut recog.err_handler)?;

                                    /*InvokeRule skipTo*/
                                    recog.base.set_state(1488);
                                    recog.skipTo()?;
                                }
                            }

                            recog.base.set_state(1492);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == INITIAL || _la == SEEK {
                                {
                                    recog.base.set_state(1491);
                                    _la = recog.base.input.la(1);
                                    if { !(_la == INITIAL || _la == SEEK) } {
                                        recog
                                            .err_handler
                                            .recover_inline(&mut recog.base)?;
                                    } else {
                                        if recog.base.input.la(1) == TOKEN_EOF {
                                            recog.base.matched_eof = true
                                        };
                                        recog.err_handler.report_match(&mut recog.base);
                                        recog.base.consume(&mut recog.err_handler);
                                    }
                                }
                            }

                            recog.base.set_state(1494);
                            recog.base.match_token(PATTERN, &mut recog.err_handler)?;

                            recog.base.set_state(1495);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule rowPattern*/
                            recog.base.set_state(1496);
                            recog.rowPattern_rec(0)?;

                            recog.base.set_state(1497);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;

                            recog.base.set_state(1507);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == SUBSET {
                                {
                                    recog.base.set_state(1498);
                                    recog
                                        .base
                                        .match_token(SUBSET, &mut recog.err_handler)?;

                                    /*InvokeRule subsetDefinition*/
                                    recog.base.set_state(1499);
                                    recog.subsetDefinition()?;

                                    recog.base.set_state(1504);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(1500);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule subsetDefinition*/
                                                recog.base.set_state(1501);
                                                recog.subsetDefinition()?;
                                            }
                                        }
                                        recog.base.set_state(1506);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(1509);
                            recog.base.match_token(DEFINE, &mut recog.err_handler)?;

                            /*InvokeRule variableDefinition*/
                            recog.base.set_state(1510);
                            recog.variableDefinition()?;

                            recog.base.set_state(1515);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            while _la == COMMA {
                                {
                                    {
                                        recog.base.set_state(1511);
                                        recog
                                            .base
                                            .match_token(COMMA, &mut recog.err_handler)?;

                                        /*InvokeRule variableDefinition*/
                                        recog.base.set_state(1512);
                                        recog.variableDefinition()?;
                                    }
                                }
                                recog.base.set_state(1517);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                            }
                            recog.base.set_state(1518);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;

                            recog.base.set_state(1526);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(193, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1520);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == AS {
                                            {
                                                recog.base.set_state(1519);
                                                recog.base.match_token(
                                                    AS,
                                                    &mut recog.err_handler,
                                                )?;
                                            }
                                        }

                                        /*InvokeRule identifier*/
                                        recog.base.set_state(1522);
                                        recog.identifier()?;

                                        recog.base.set_state(1524);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        match recog
                                            .interpreter
                                            .adaptive_predict(192, &mut recog.base)?
                                        {
                                            x if x == 1 => {
                                                {
                                                    /*InvokeRule columnAliases*/
                                                    recog.base.set_state(1523);
                                                    recog.columnAliases()?;
                                                }
                                            }

                                            _ => {}
                                        }
                                    }
                                }

                                _ => {}
                            }
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- measureDefinition ----------------
pub type MeasureDefinitionContextAll<'input> = MeasureDefinitionContext<'input>;

pub type MeasureDefinitionContext<'input> =
    BaseParserRuleContext<'input, MeasureDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct MeasureDefinitionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for MeasureDefinitionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for MeasureDefinitionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_measureDefinition(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_measureDefinition(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for MeasureDefinitionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_measureDefinition
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_measureDefinition }
}
antlr_rust::tid! {MeasureDefinitionContextExt<'a>}

impl<'input> MeasureDefinitionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<MeasureDefinitionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            MeasureDefinitionContextExt { ph: PhantomData },
        ))
    }
}

pub trait MeasureDefinitionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<MeasureDefinitionContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MeasureDefinitionContextAttrs<'input> for MeasureDefinitionContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn measureDefinition(
        &mut self,
    ) -> Result<Rc<MeasureDefinitionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            MeasureDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 80, RULE_measureDefinition);
        let mut _localctx: Rc<MeasureDefinitionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule expression*/
                recog.base.set_state(1530);
                recog.expression()?;

                recog.base.set_state(1531);
                recog.base.match_token(AS, &mut recog.err_handler)?;

                /*InvokeRule identifier*/
                recog.base.set_state(1532);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- rowsPerMatch ----------------
pub type RowsPerMatchContextAll<'input> = RowsPerMatchContext<'input>;

pub type RowsPerMatchContext<'input> =
    BaseParserRuleContext<'input, RowsPerMatchContextExt<'input>>;

#[derive(Clone)]
pub struct RowsPerMatchContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RowsPerMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RowsPerMatchContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rowsPerMatch(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_rowsPerMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for RowsPerMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rowsPerMatch
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rowsPerMatch }
}
antlr_rust::tid! {RowsPerMatchContextExt<'a>}

impl<'input> RowsPerMatchContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RowsPerMatchContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            RowsPerMatchContextExt { ph: PhantomData },
        ))
    }
}

pub trait RowsPerMatchContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RowsPerMatchContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ONE
    /// Returns `None` if there is no child corresponding to token ONE
    fn ONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ONE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROW
    /// Returns `None` if there is no child corresponding to token ROW
    fn ROW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PER
    /// Returns `None` if there is no child corresponding to token PER
    fn PER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCH
    /// Returns `None` if there is no child corresponding to token MATCH
    fn MATCH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROWS
    /// Returns `None` if there is no child corresponding to token ROWS
    fn ROWS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROWS, 0)
    }
    fn emptyMatchHandling(&self) -> Option<Rc<EmptyMatchHandlingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> RowsPerMatchContextAttrs<'input> for RowsPerMatchContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn rowsPerMatch(
        &mut self,
    ) -> Result<Rc<RowsPerMatchContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            RowsPerMatchContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 82, RULE_rowsPerMatch);
        let mut _localctx: Rc<RowsPerMatchContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1545);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ONE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1534);
                        recog.base.match_token(ONE, &mut recog.err_handler)?;

                        recog.base.set_state(1535);
                        recog.base.match_token(ROW, &mut recog.err_handler)?;

                        recog.base.set_state(1536);
                        recog.base.match_token(PER, &mut recog.err_handler)?;

                        recog.base.set_state(1537);
                        recog.base.match_token(MATCH, &mut recog.err_handler)?;
                    }
                }

                ALL => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1538);
                        recog.base.match_token(ALL, &mut recog.err_handler)?;

                        recog.base.set_state(1539);
                        recog.base.match_token(ROWS, &mut recog.err_handler)?;

                        recog.base.set_state(1540);
                        recog.base.match_token(PER, &mut recog.err_handler)?;

                        recog.base.set_state(1541);
                        recog.base.match_token(MATCH, &mut recog.err_handler)?;

                        recog.base.set_state(1543);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OMIT || _la == SHOW || _la == WITH {
                            {
                                /*InvokeRule emptyMatchHandling*/
                                recog.base.set_state(1542);
                                recog.emptyMatchHandling()?;
                            }
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- emptyMatchHandling ----------------
pub type EmptyMatchHandlingContextAll<'input> = EmptyMatchHandlingContext<'input>;

pub type EmptyMatchHandlingContext<'input> =
    BaseParserRuleContext<'input, EmptyMatchHandlingContextExt<'input>>;

#[derive(Clone)]
pub struct EmptyMatchHandlingContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for EmptyMatchHandlingContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for EmptyMatchHandlingContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_emptyMatchHandling(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_emptyMatchHandling(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for EmptyMatchHandlingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_emptyMatchHandling
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_emptyMatchHandling }
}
antlr_rust::tid! {EmptyMatchHandlingContextExt<'a>}

impl<'input> EmptyMatchHandlingContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<EmptyMatchHandlingContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            EmptyMatchHandlingContextExt { ph: PhantomData },
        ))
    }
}

pub trait EmptyMatchHandlingContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<EmptyMatchHandlingContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EMPTY
    /// Returns `None` if there is no child corresponding to token EMPTY
    fn EMPTY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EMPTY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCHES
    /// Returns `None` if there is no child corresponding to token MATCHES
    fn MATCHES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCHES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OMIT
    /// Returns `None` if there is no child corresponding to token OMIT
    fn OMIT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OMIT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNMATCHED
    /// Returns `None` if there is no child corresponding to token UNMATCHED
    fn UNMATCHED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNMATCHED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROWS
    /// Returns `None` if there is no child corresponding to token ROWS
    fn ROWS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROWS, 0)
    }
}

impl<'input> EmptyMatchHandlingContextAttrs<'input>
    for EmptyMatchHandlingContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn emptyMatchHandling(
        &mut self,
    ) -> Result<Rc<EmptyMatchHandlingContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            EmptyMatchHandlingContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 84, RULE_emptyMatchHandling);
        let mut _localctx: Rc<EmptyMatchHandlingContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1556);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                SHOW => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1547);
                        recog.base.match_token(SHOW, &mut recog.err_handler)?;

                        recog.base.set_state(1548);
                        recog.base.match_token(EMPTY, &mut recog.err_handler)?;

                        recog.base.set_state(1549);
                        recog.base.match_token(MATCHES, &mut recog.err_handler)?;
                    }
                }

                OMIT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1550);
                        recog.base.match_token(OMIT, &mut recog.err_handler)?;

                        recog.base.set_state(1551);
                        recog.base.match_token(EMPTY, &mut recog.err_handler)?;

                        recog.base.set_state(1552);
                        recog.base.match_token(MATCHES, &mut recog.err_handler)?;
                    }
                }

                WITH => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1553);
                        recog.base.match_token(WITH, &mut recog.err_handler)?;

                        recog.base.set_state(1554);
                        recog.base.match_token(UNMATCHED, &mut recog.err_handler)?;

                        recog.base.set_state(1555);
                        recog.base.match_token(ROWS, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- skipTo ----------------
pub type SkipToContextAll<'input> = SkipToContext<'input>;

pub type SkipToContext<'input> = BaseParserRuleContext<'input, SkipToContextExt<'input>>;

#[derive(Clone)]
pub struct SkipToContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SkipToContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for SkipToContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_skipTo(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_skipTo(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for SkipToContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_skipTo
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_skipTo }
}
antlr_rust::tid! {SkipToContextExt<'a>}

impl<'input> SkipToContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SkipToContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            SkipToContextExt { ph: PhantomData },
        ))
    }
}

pub trait SkipToContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SkipToContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NEXT
    /// Returns `None` if there is no child corresponding to token NEXT
    fn NEXT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NEXT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROW
    /// Returns `None` if there is no child corresponding to token ROW
    fn ROW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PAST
    /// Returns `None` if there is no child corresponding to token PAST
    fn PAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PAST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LAST
    /// Returns `None` if there is no child corresponding to token LAST
    fn LAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LAST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FIRST
    /// Returns `None` if there is no child corresponding to token FIRST
    fn FIRST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FIRST, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SkipToContextAttrs<'input> for SkipToContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn skipTo(&mut self) -> Result<Rc<SkipToContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SkipToContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_skipTo);
        let mut _localctx: Rc<SkipToContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1577);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(198, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1558);
                        recog.base.match_token(T__3, &mut recog.err_handler)?;

                        recog.base.set_state(1559);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        recog.base.set_state(1560);
                        recog.base.match_token(NEXT, &mut recog.err_handler)?;

                        recog.base.set_state(1561);
                        recog.base.match_token(ROW, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1562);
                        recog.base.match_token(T__3, &mut recog.err_handler)?;

                        recog.base.set_state(1563);
                        recog.base.match_token(PAST, &mut recog.err_handler)?;

                        recog.base.set_state(1564);
                        recog.base.match_token(LAST, &mut recog.err_handler)?;

                        recog.base.set_state(1565);
                        recog.base.match_token(ROW, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1566);
                        recog.base.match_token(T__3, &mut recog.err_handler)?;

                        recog.base.set_state(1567);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        recog.base.set_state(1568);
                        recog.base.match_token(FIRST, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(1569);
                        recog.identifier()?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1570);
                        recog.base.match_token(T__3, &mut recog.err_handler)?;

                        recog.base.set_state(1571);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        recog.base.set_state(1572);
                        recog.base.match_token(LAST, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(1573);
                        recog.identifier()?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1574);
                        recog.base.match_token(T__3, &mut recog.err_handler)?;

                        recog.base.set_state(1575);
                        recog.base.match_token(TO, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(1576);
                        recog.identifier()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- subsetDefinition ----------------
pub type SubsetDefinitionContextAll<'input> = SubsetDefinitionContext<'input>;

pub type SubsetDefinitionContext<'input> =
    BaseParserRuleContext<'input, SubsetDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct SubsetDefinitionContextExt<'input> {
    pub name: Option<Rc<IdentifierContextAll<'input>>>,
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub union: Vec<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for SubsetDefinitionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SubsetDefinitionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_subsetDefinition(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_subsetDefinition(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for SubsetDefinitionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_subsetDefinition
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_subsetDefinition }
}
antlr_rust::tid! {SubsetDefinitionContextExt<'a>}

impl<'input> SubsetDefinitionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<SubsetDefinitionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            SubsetDefinitionContextExt {
                name: None,
                identifier: None,
                union: Vec::new(),
                ph: PhantomData,
            },
        ))
    }
}

pub trait SubsetDefinitionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<SubsetDefinitionContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token EQ
    /// Returns `None` if there is no child corresponding to token EQ
    fn EQ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EQ, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> SubsetDefinitionContextAttrs<'input> for SubsetDefinitionContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn subsetDefinition(
        &mut self,
    ) -> Result<Rc<SubsetDefinitionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            SubsetDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 88, RULE_subsetDefinition);
        let mut _localctx: Rc<SubsetDefinitionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(1579);
                let tmp = recog.identifier()?;
                cast_mut::<_, SubsetDefinitionContext>(&mut _localctx).name =
                    Some(tmp.clone());

                recog.base.set_state(1580);
                recog.base.match_token(EQ, &mut recog.err_handler)?;

                recog.base.set_state(1581);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                /*InvokeRule identifier*/
                recog.base.set_state(1582);
                let tmp = recog.identifier()?;
                cast_mut::<_, SubsetDefinitionContext>(&mut _localctx).identifier =
                    Some(tmp.clone());

                let temp = cast_mut::<_, SubsetDefinitionContext>(&mut _localctx)
                    .identifier
                    .clone()
                    .unwrap();
                cast_mut::<_, SubsetDefinitionContext>(&mut _localctx)
                    .union
                    .push(temp);

                recog.base.set_state(1587);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA {
                    {
                        {
                            recog.base.set_state(1583);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule identifier*/
                            recog.base.set_state(1584);
                            let tmp = recog.identifier()?;
                            cast_mut::<_, SubsetDefinitionContext>(&mut _localctx)
                                .identifier = Some(tmp.clone());

                            let temp =
                                cast_mut::<_, SubsetDefinitionContext>(&mut _localctx)
                                    .identifier
                                    .clone()
                                    .unwrap();
                            cast_mut::<_, SubsetDefinitionContext>(&mut _localctx)
                                .union
                                .push(temp);
                        }
                    }
                    recog.base.set_state(1589);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1590);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- variableDefinition ----------------
pub type VariableDefinitionContextAll<'input> = VariableDefinitionContext<'input>;

pub type VariableDefinitionContext<'input> =
    BaseParserRuleContext<'input, VariableDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDefinitionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for VariableDefinitionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for VariableDefinitionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_variableDefinition(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_variableDefinition(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for VariableDefinitionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_variableDefinition
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_variableDefinition }
}
antlr_rust::tid! {VariableDefinitionContextExt<'a>}

impl<'input> VariableDefinitionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<VariableDefinitionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            VariableDefinitionContextExt { ph: PhantomData },
        ))
    }
}

pub trait VariableDefinitionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<VariableDefinitionContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> VariableDefinitionContextAttrs<'input>
    for VariableDefinitionContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn variableDefinition(
        &mut self,
    ) -> Result<Rc<VariableDefinitionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            VariableDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 90, RULE_variableDefinition);
        let mut _localctx: Rc<VariableDefinitionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(1592);
                recog.identifier()?;

                recog.base.set_state(1593);
                recog.base.match_token(AS, &mut recog.err_handler)?;

                /*InvokeRule expression*/
                recog.base.set_state(1594);
                recog.expression()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- aliasedRelation ----------------
pub type AliasedRelationContextAll<'input> = AliasedRelationContext<'input>;

pub type AliasedRelationContext<'input> =
    BaseParserRuleContext<'input, AliasedRelationContextExt<'input>>;

#[derive(Clone)]
pub struct AliasedRelationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for AliasedRelationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for AliasedRelationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_aliasedRelation(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_aliasedRelation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for AliasedRelationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_aliasedRelation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_aliasedRelation }
}
antlr_rust::tid! {AliasedRelationContextExt<'a>}

impl<'input> AliasedRelationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AliasedRelationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            AliasedRelationContextExt { ph: PhantomData },
        ))
    }
}

pub trait AliasedRelationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<AliasedRelationContextExt<'input>>
{
    fn relationPrimary(&self) -> Option<Rc<RelationPrimaryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AliasedRelationContextAttrs<'input> for AliasedRelationContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn aliasedRelation(
        &mut self,
    ) -> Result<Rc<AliasedRelationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            AliasedRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 92, RULE_aliasedRelation);
        let mut _localctx: Rc<AliasedRelationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule relationPrimary*/
                recog.base.set_state(1596);
                recog.relationPrimary()?;

                recog.base.set_state(1604);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(202, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1598);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == AS {
                                {
                                    recog.base.set_state(1597);
                                    recog.base.match_token(AS, &mut recog.err_handler)?;
                                }
                            }

                            /*InvokeRule identifier*/
                            recog.base.set_state(1600);
                            recog.identifier()?;

                            recog.base.set_state(1602);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(201, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule columnAliases*/
                                        recog.base.set_state(1601);
                                        recog.columnAliases()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- columnAliases ----------------
pub type ColumnAliasesContextAll<'input> = ColumnAliasesContext<'input>;

pub type ColumnAliasesContext<'input> =
    BaseParserRuleContext<'input, ColumnAliasesContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnAliasesContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ColumnAliasesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ColumnAliasesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_columnAliases(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_columnAliases(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ColumnAliasesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_columnAliases
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_columnAliases }
}
antlr_rust::tid! {ColumnAliasesContextExt<'a>}

impl<'input> ColumnAliasesContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ColumnAliasesContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ColumnAliasesContextExt { ph: PhantomData },
        ))
    }
}

pub trait ColumnAliasesContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ColumnAliasesContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> ColumnAliasesContextAttrs<'input> for ColumnAliasesContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn columnAliases(
        &mut self,
    ) -> Result<Rc<ColumnAliasesContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            ColumnAliasesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 94, RULE_columnAliases);
        let mut _localctx: Rc<ColumnAliasesContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1606);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                /*InvokeRule identifier*/
                recog.base.set_state(1607);
                recog.identifier()?;

                recog.base.set_state(1612);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA {
                    {
                        {
                            recog.base.set_state(1608);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule identifier*/
                            recog.base.set_state(1609);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(1614);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1615);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- relationPrimary ----------------
#[derive(Debug)]
pub enum RelationPrimaryContextAll<'input> {
    SubqueryRelationContext(SubqueryRelationContext<'input>),
    ParenthesizedRelationContext(ParenthesizedRelationContext<'input>),
    UnnestContext(UnnestContext<'input>),
    TableFunctionInvocationContext(TableFunctionInvocationContext<'input>),
    LateralContext(LateralContext<'input>),
    TableNameContext(TableNameContext<'input>),
    Error(RelationPrimaryContext<'input>),
}
antlr_rust::tid! {RelationPrimaryContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for RelationPrimaryContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for RelationPrimaryContextAll<'input> {}

impl<'input> Deref for RelationPrimaryContextAll<'input> {
    type Target = dyn RelationPrimaryContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use RelationPrimaryContextAll::*;
        match self {
            SubqueryRelationContext(inner) => inner,
            ParenthesizedRelationContext(inner) => inner,
            UnnestContext(inner) => inner,
            TableFunctionInvocationContext(inner) => inner,
            LateralContext(inner) => inner,
            TableNameContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RelationPrimaryContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type RelationPrimaryContext<'input> =
    BaseParserRuleContext<'input, RelationPrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct RelationPrimaryContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RelationPrimaryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RelationPrimaryContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for RelationPrimaryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relationPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}
antlr_rust::tid! {RelationPrimaryContextExt<'a>}

impl<'input> RelationPrimaryContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RelationPrimaryContextAll<'input>> {
        Rc::new(RelationPrimaryContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                RelationPrimaryContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait RelationPrimaryContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RelationPrimaryContextExt<'input>>
{
}

impl<'input> RelationPrimaryContextAttrs<'input> for RelationPrimaryContext<'input> {}

pub type SubqueryRelationContext<'input> =
    BaseParserRuleContext<'input, SubqueryRelationContextExt<'input>>;

pub trait SubqueryRelationContextAttrs<'input>: PrestoParserContext<'input> {
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SubqueryRelationContextAttrs<'input> for SubqueryRelationContext<'input> {}

pub struct SubqueryRelationContextExt<'input> {
    base: RelationPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SubqueryRelationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SubqueryRelationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SubqueryRelationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_subqueryRelation(self);
    }
}

impl<'input> CustomRuleContext<'input> for SubqueryRelationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relationPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>>
    for SubqueryRelationContext<'input>
{
    fn borrow(&self) -> &RelationPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>>
    for SubqueryRelationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationPrimaryContextAttrs<'input> for SubqueryRelationContext<'input> {}

impl<'input> SubqueryRelationContextExt<'input> {
    fn new(
        ctx: &dyn RelationPrimaryContextAttrs<'input>,
    ) -> Rc<RelationPrimaryContextAll<'input>> {
        Rc::new(RelationPrimaryContextAll::SubqueryRelationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SubqueryRelationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ParenthesizedRelationContext<'input> =
    BaseParserRuleContext<'input, ParenthesizedRelationContextExt<'input>>;

pub trait ParenthesizedRelationContextAttrs<'input>: PrestoParserContext<'input> {
    fn relation(&self) -> Option<Rc<RelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ParenthesizedRelationContextAttrs<'input>
    for ParenthesizedRelationContext<'input>
{
}

pub struct ParenthesizedRelationContextExt<'input> {
    base: RelationPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ParenthesizedRelationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ParenthesizedRelationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ParenthesizedRelationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parenthesizedRelation(self);
    }
}

impl<'input> CustomRuleContext<'input> for ParenthesizedRelationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relationPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>>
    for ParenthesizedRelationContext<'input>
{
    fn borrow(&self) -> &RelationPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>>
    for ParenthesizedRelationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationPrimaryContextAttrs<'input>
    for ParenthesizedRelationContext<'input>
{
}

impl<'input> ParenthesizedRelationContextExt<'input> {
    fn new(
        ctx: &dyn RelationPrimaryContextAttrs<'input>,
    ) -> Rc<RelationPrimaryContextAll<'input>> {
        Rc::new(RelationPrimaryContextAll::ParenthesizedRelationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ParenthesizedRelationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type UnnestContext<'input> = BaseParserRuleContext<'input, UnnestContextExt<'input>>;

pub trait UnnestContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token UNNEST
    /// Returns `None` if there is no child corresponding to token UNNEST
    fn UNNEST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNNEST, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ORDINALITY
    /// Returns `None` if there is no child corresponding to token ORDINALITY
    fn ORDINALITY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDINALITY, 0)
    }
}

impl<'input> UnnestContextAttrs<'input> for UnnestContext<'input> {}

pub struct UnnestContextExt<'input> {
    base: RelationPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UnnestContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UnnestContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for UnnestContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_unnest(self);
    }
}

impl<'input> CustomRuleContext<'input> for UnnestContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relationPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>> for UnnestContext<'input> {
    fn borrow(&self) -> &RelationPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>> for UnnestContext<'input> {
    fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationPrimaryContextAttrs<'input> for UnnestContext<'input> {}

impl<'input> UnnestContextExt<'input> {
    fn new(
        ctx: &dyn RelationPrimaryContextAttrs<'input>,
    ) -> Rc<RelationPrimaryContextAll<'input>> {
        Rc::new(RelationPrimaryContextAll::UnnestContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UnnestContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TableFunctionInvocationContext<'input> =
    BaseParserRuleContext<'input, TableFunctionInvocationContextExt<'input>>;

pub trait TableFunctionInvocationContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn tableFunctionCall(&self) -> Option<Rc<TableFunctionCallContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TableFunctionInvocationContextAttrs<'input>
    for TableFunctionInvocationContext<'input>
{
}

pub struct TableFunctionInvocationContextExt<'input> {
    base: RelationPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TableFunctionInvocationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TableFunctionInvocationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableFunctionInvocationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableFunctionInvocation(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableFunctionInvocationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relationPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>>
    for TableFunctionInvocationContext<'input>
{
    fn borrow(&self) -> &RelationPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>>
    for TableFunctionInvocationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationPrimaryContextAttrs<'input>
    for TableFunctionInvocationContext<'input>
{
}

impl<'input> TableFunctionInvocationContextExt<'input> {
    fn new(
        ctx: &dyn RelationPrimaryContextAttrs<'input>,
    ) -> Rc<RelationPrimaryContextAll<'input>> {
        Rc::new(RelationPrimaryContextAll::TableFunctionInvocationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TableFunctionInvocationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type LateralContext<'input> =
    BaseParserRuleContext<'input, LateralContextExt<'input>>;

pub trait LateralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token LATERAL
    /// Returns `None` if there is no child corresponding to token LATERAL
    fn LATERAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LATERAL, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> LateralContextAttrs<'input> for LateralContext<'input> {}

pub struct LateralContextExt<'input> {
    base: RelationPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {LateralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for LateralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for LateralContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lateral(self);
    }
}

impl<'input> CustomRuleContext<'input> for LateralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relationPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>> for LateralContext<'input> {
    fn borrow(&self) -> &RelationPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>> for LateralContext<'input> {
    fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationPrimaryContextAttrs<'input> for LateralContext<'input> {}

impl<'input> LateralContextExt<'input> {
    fn new(
        ctx: &dyn RelationPrimaryContextAttrs<'input>,
    ) -> Rc<RelationPrimaryContextAll<'input>> {
        Rc::new(RelationPrimaryContextAll::LateralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                LateralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TableNameContext<'input> =
    BaseParserRuleContext<'input, TableNameContextExt<'input>>;

pub trait TableNameContextAttrs<'input>: PrestoParserContext<'input> {
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn queryPeriod(&self) -> Option<Rc<QueryPeriodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TableNameContextAttrs<'input> for TableNameContext<'input> {}

pub struct TableNameContextExt<'input> {
    base: RelationPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TableNameContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TableNameContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableNameContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableName(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableNameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_relationPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>> for TableNameContext<'input> {
    fn borrow(&self) -> &RelationPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>> for TableNameContext<'input> {
    fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RelationPrimaryContextAttrs<'input> for TableNameContext<'input> {}

impl<'input> TableNameContextExt<'input> {
    fn new(
        ctx: &dyn RelationPrimaryContextAttrs<'input>,
    ) -> Rc<RelationPrimaryContextAll<'input>> {
        Rc::new(RelationPrimaryContextAll::TableNameContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TableNameContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn relationPrimary(
        &mut self,
    ) -> Result<Rc<RelationPrimaryContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            RelationPrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 96, RULE_relationPrimary);
        let mut _localctx: Rc<RelationPrimaryContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1654);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(207, &mut recog.base)? {
                1 => {
                    let tmp = TableNameContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(1617);
                        recog.qualifiedName()?;

                        recog.base.set_state(1619);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(204, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /*InvokeRule queryPeriod*/
                                    recog.base.set_state(1618);
                                    recog.queryPeriod()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    let tmp = SubqueryRelationContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1621);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(1622);
                        recog.query()?;

                        recog.base.set_state(1623);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = UnnestContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1625);
                        recog.base.match_token(UNNEST, &mut recog.err_handler)?;

                        recog.base.set_state(1626);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(1627);
                        recog.expression()?;

                        recog.base.set_state(1632);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1628);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(1629);
                                    recog.expression()?;
                                }
                            }
                            recog.base.set_state(1634);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1635);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;

                        recog.base.set_state(1638);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(206, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(1636);
                                recog.base.match_token(WITH, &mut recog.err_handler)?;

                                recog.base.set_state(1637);
                                recog
                                    .base
                                    .match_token(ORDINALITY, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    let tmp = LateralContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1640);
                        recog.base.match_token(LATERAL, &mut recog.err_handler)?;

                        recog.base.set_state(1641);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(1642);
                        recog.query()?;

                        recog.base.set_state(1643);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    let tmp = TableFunctionInvocationContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1645);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(1646);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule tableFunctionCall*/
                        recog.base.set_state(1647);
                        recog.tableFunctionCall()?;

                        recog.base.set_state(1648);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                6 => {
                    let tmp = ParenthesizedRelationContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1650);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule relation*/
                        recog.base.set_state(1651);
                        recog.relation_rec(0)?;

                        recog.base.set_state(1652);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tableFunctionCall ----------------
pub type TableFunctionCallContextAll<'input> = TableFunctionCallContext<'input>;

pub type TableFunctionCallContext<'input> =
    BaseParserRuleContext<'input, TableFunctionCallContextExt<'input>>;

#[derive(Clone)]
pub struct TableFunctionCallContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TableFunctionCallContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableFunctionCallContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableFunctionCall(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_tableFunctionCall(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableFunctionCallContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tableFunctionCall
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionCall }
}
antlr_rust::tid! {TableFunctionCallContextExt<'a>}

impl<'input> TableFunctionCallContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TableFunctionCallContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            TableFunctionCallContextExt { ph: PhantomData },
        ))
    }
}

pub trait TableFunctionCallContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TableFunctionCallContextExt<'input>>
{
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tableFunctionArgument_all(
        &self,
    ) -> Vec<Rc<TableFunctionArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tableFunctionArgument(
        &self,
        i: usize,
    ) -> Option<Rc<TableFunctionArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token COPARTITION
    /// Returns `None` if there is no child corresponding to token COPARTITION
    fn COPARTITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COPARTITION, 0)
    }
    fn copartitionTables_all(&self) -> Vec<Rc<CopartitionTablesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn copartitionTables(
        &self,
        i: usize,
    ) -> Option<Rc<CopartitionTablesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> TableFunctionCallContextAttrs<'input> for TableFunctionCallContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tableFunctionCall(
        &mut self,
    ) -> Result<Rc<TableFunctionCallContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            TableFunctionCallContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 98, RULE_tableFunctionCall);
        let mut _localctx: Rc<TableFunctionCallContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule qualifiedName*/
                recog.base.set_state(1656);
                recog.qualifiedName()?;

                recog.base.set_state(1657);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                recog.base.set_state(1666);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(209, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /*InvokeRule tableFunctionArgument*/
                            recog.base.set_state(1658);
                            recog.tableFunctionArgument()?;

                            recog.base.set_state(1663);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            while _la == COMMA {
                                {
                                    {
                                        recog.base.set_state(1659);
                                        recog
                                            .base
                                            .match_token(COMMA, &mut recog.err_handler)?;

                                        /*InvokeRule tableFunctionArgument*/
                                        recog.base.set_state(1660);
                                        recog.tableFunctionArgument()?;
                                    }
                                }
                                recog.base.set_state(1665);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                            }
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1677);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COPARTITION {
                    {
                        recog.base.set_state(1668);
                        recog
                            .base
                            .match_token(COPARTITION, &mut recog.err_handler)?;

                        /*InvokeRule copartitionTables*/
                        recog.base.set_state(1669);
                        recog.copartitionTables()?;

                        recog.base.set_state(1674);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1670);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule copartitionTables*/
                                    recog.base.set_state(1671);
                                    recog.copartitionTables()?;
                                }
                            }
                            recog.base.set_state(1676);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }

                recog.base.set_state(1679);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tableFunctionArgument ----------------
pub type TableFunctionArgumentContextAll<'input> = TableFunctionArgumentContext<'input>;

pub type TableFunctionArgumentContext<'input> =
    BaseParserRuleContext<'input, TableFunctionArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct TableFunctionArgumentContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TableFunctionArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableFunctionArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableFunctionArgument(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_tableFunctionArgument(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableFunctionArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tableFunctionArgument
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionArgument }
}
antlr_rust::tid! {TableFunctionArgumentContextExt<'a>}

impl<'input> TableFunctionArgumentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TableFunctionArgumentContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            TableFunctionArgumentContextExt { ph: PhantomData },
        ))
    }
}

pub trait TableFunctionArgumentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TableFunctionArgumentContextExt<'input>>
{
    fn tableArgument(&self) -> Option<Rc<TableArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn descriptorArgument(&self) -> Option<Rc<DescriptorArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TableFunctionArgumentContextAttrs<'input>
    for TableFunctionArgumentContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tableFunctionArgument(
        &mut self,
    ) -> Result<Rc<TableFunctionArgumentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = TableFunctionArgumentContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 100, RULE_tableFunctionArgument);
        let mut _localctx: Rc<TableFunctionArgumentContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1684);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(212, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /*InvokeRule identifier*/
                            recog.base.set_state(1681);
                            recog.identifier()?;

                            recog.base.set_state(1682);
                            recog.base.match_token(T__4, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1689);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(213, &mut recog.base)? {
                    1 => {
                        {
                            /*InvokeRule tableArgument*/
                            recog.base.set_state(1686);
                            recog.tableArgument()?;
                        }
                    }
                    2 => {
                        {
                            /*InvokeRule descriptorArgument*/
                            recog.base.set_state(1687);
                            recog.descriptorArgument()?;
                        }
                    }
                    3 => {
                        {
                            /*InvokeRule expression*/
                            recog.base.set_state(1688);
                            recog.expression()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tableArgument ----------------
pub type TableArgumentContextAll<'input> = TableArgumentContext<'input>;

pub type TableArgumentContext<'input> =
    BaseParserRuleContext<'input, TableArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct TableArgumentContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TableArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableArgument(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_tableArgument(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tableArgument
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tableArgument }
}
antlr_rust::tid! {TableArgumentContextExt<'a>}

impl<'input> TableArgumentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TableArgumentContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            TableArgumentContextExt { ph: PhantomData },
        ))
    }
}

pub trait TableArgumentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TableArgumentContextExt<'input>>
{
    fn tableArgumentRelation(&self) -> Option<Rc<TableArgumentRelationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PARTITION
    /// Returns `None` if there is no child corresponding to token PARTITION
    fn PARTITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARTITION, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token BY in current rule
    fn BY_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
    /// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
    fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, i)
    }
    /// Retrieves first TerminalNode corresponding to token PRUNE
    /// Returns `None` if there is no child corresponding to token PRUNE
    fn PRUNE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRUNE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WHEN
    /// Returns `None` if there is no child corresponding to token WHEN
    fn WHEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EMPTY
    /// Returns `None` if there is no child corresponding to token EMPTY
    fn EMPTY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EMPTY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KEEP
    /// Returns `None` if there is no child corresponding to token KEEP
    fn KEEP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KEEP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ORDER
    /// Returns `None` if there is no child corresponding to token ORDER
    fn ORDER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDER, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn sortItem_all(&self) -> Vec<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> TableArgumentContextAttrs<'input> for TableArgumentContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tableArgument(
        &mut self,
    ) -> Result<Rc<TableArgumentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            TableArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 102, RULE_tableArgument);
        let mut _localctx: Rc<TableArgumentContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule tableArgumentRelation*/
                recog.base.set_state(1691);
                recog.tableArgumentRelation()?;

                recog.base.set_state(1709);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARTITION {
                    {
                        recog.base.set_state(1692);
                        recog.base.match_token(PARTITION, &mut recog.err_handler)?;

                        recog.base.set_state(1693);
                        recog.base.match_token(BY, &mut recog.err_handler)?;

                        recog.base.set_state(1707);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(216, &mut recog.base)? {
                            1 => {
                                {
                                    recog.base.set_state(1694);
                                    recog
                                        .base
                                        .match_token(T__1, &mut recog.err_handler)?;

                                    recog.base.set_state(1703);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if (((_la) & !0x3f) == 0
                                        && ((1usize << _la)
                                            & ((1usize << T__1)
                                                | (1usize << ABSENT)
                                                | (1usize << ADD)
                                                | (1usize << ADMIN)
                                                | (1usize << AFTER)
                                                | (1usize << ALL)
                                                | (1usize << ANALYZE)
                                                | (1usize << ANY)
                                                | (1usize << ARRAY)
                                                | (1usize << ASC)
                                                | (1usize << AT)
                                                | (1usize << AUTHORIZATION)
                                                | (1usize << BERNOULLI)))
                                            != 0)
                                        || (((_la - 33) & !0x3f) == 0
                                            && ((1usize << (_la - 33))
                                                & ((1usize << (BOTH - 33))
                                                    | (1usize << (CALL - 33))
                                                    | (1usize << (CASCADE - 33))
                                                    | (1usize << (CASE - 33))
                                                    | (1usize << (CAST - 33))
                                                    | (1usize << (CATALOGS - 33))
                                                    | (1usize << (COLUMN - 33))
                                                    | (1usize << (COLUMNS - 33))
                                                    | (1usize << (COMMENT - 33))
                                                    | (1usize << (COMMIT - 33))
                                                    | (1usize << (COMMITTED - 33))
                                                    | (1usize << (CONDITIONAL - 33))
                                                    | (1usize << (COUNT - 33))
                                                    | (1usize << (COPARTITION - 33))
                                                    | (1usize << (CURRENT - 33))
                                                    | (1usize
                                                        << (CURRENT_CATALOG - 33))
                                                    | (1usize << (CURRENT_DATE - 33))
                                                    | (1usize << (CURRENT_PATH - 33))
                                                    | (1usize << (CURRENT_SCHEMA - 33))
                                                    | (1usize << (CURRENT_TIME - 33))
                                                    | (1usize
                                                        << (CURRENT_TIMESTAMP - 33))
                                                    | (1usize << (CURRENT_USER - 33))
                                                    | (1usize << (DATA - 33))
                                                    | (1usize << (DATE - 33))
                                                    | (1usize << (DAY - 33))))
                                                != 0)
                                        || (((_la - 66) & !0x3f) == 0
                                            && ((1usize << (_la - 66))
                                                & ((1usize << (DEFAULT - 66))
                                                    | (1usize << (DEFINE - 66))
                                                    | (1usize << (DEFINER - 66))
                                                    | (1usize << (DENY - 66))
                                                    | (1usize << (DESC - 66))
                                                    | (1usize << (DESCRIPTOR - 66))
                                                    | (1usize << (DISTRIBUTED - 66))
                                                    | (1usize << (DOUBLE - 66))
                                                    | (1usize << (EMPTY - 66))
                                                    | (1usize << (ENCODING - 66))
                                                    | (1usize << (ERROR - 66))
                                                    | (1usize << (EXCLUDING - 66))
                                                    | (1usize << (EXISTS - 66))
                                                    | (1usize << (EXPLAIN - 66))
                                                    | (1usize << (EXTRACT - 66))
                                                    | (1usize << (FALSE - 66))
                                                    | (1usize << (FETCH - 66))
                                                    | (1usize << (FILTER - 66))
                                                    | (1usize << (FINAL - 66))
                                                    | (1usize << (FIRST - 66))
                                                    | (1usize << (FOLLOWING - 66))
                                                    | (1usize << (FORMAT - 66))))
                                                != 0)
                                        || (((_la - 100) & !0x3f) == 0
                                            && ((1usize << (_la - 100))
                                                & ((1usize << (FUNCTIONS - 100))
                                                    | (1usize << (GRACE - 100))
                                                    | (1usize << (GRANT - 100))
                                                    | (1usize << (GRANTED - 100))
                                                    | (1usize << (GRANTS - 100))
                                                    | (1usize << (GRAPHVIZ - 100))
                                                    | (1usize << (GROUPING - 100))
                                                    | (1usize << (GROUPS - 100))
                                                    | (1usize << (HOUR - 100))
                                                    | (1usize << (IF - 100))
                                                    | (1usize << (IGNORE - 100))
                                                    | (1usize << (INCLUDING - 100))
                                                    | (1usize << (INITIAL - 100))
                                                    | (1usize << (INPUT - 100))
                                                    | (1usize << (INTERVAL - 100))
                                                    | (1usize << (INVOKER - 100))
                                                    | (1usize << (IO - 100))
                                                    | (1usize << (ISOLATION - 100))
                                                    | (1usize << (JSON - 100))
                                                    | (1usize << (JSON_ARRAY - 100))
                                                    | (1usize << (JSON_EXISTS - 100))
                                                    | (1usize << (JSON_OBJECT - 100))
                                                    | (1usize << (JSON_QUERY - 100))))
                                                != 0)
                                        || (((_la - 132) & !0x3f) == 0
                                            && ((1usize << (_la - 132))
                                                & ((1usize << (JSON_VALUE - 132))
                                                    | (1usize << (KEEP - 132))
                                                    | (1usize << (KEY - 132))
                                                    | (1usize << (KEYS - 132))
                                                    | (1usize << (LAST - 132))
                                                    | (1usize << (LATERAL - 132))
                                                    | (1usize << (LEADING - 132))
                                                    | (1usize << (LEVEL - 132))
                                                    | (1usize << (LIMIT - 132))
                                                    | (1usize << (LISTAGG - 132))
                                                    | (1usize << (LOCAL - 132))
                                                    | (1usize << (LOCALTIME - 132))
                                                    | (1usize
                                                        << (LOCALTIMESTAMP - 132))
                                                    | (1usize << (LOGICAL - 132))
                                                    | (1usize << (MAP - 132))
                                                    | (1usize << (MATCH - 132))
                                                    | (1usize << (MATCHED - 132))
                                                    | (1usize << (MATCHES - 132))
                                                    | (1usize
                                                        << (MATCH_RECOGNIZE - 132))
                                                    | (1usize << (MATERIALIZED - 132))
                                                    | (1usize << (MEASURES - 132))
                                                    | (1usize << (MERGE - 132))
                                                    | (1usize << (MINUTE - 132))
                                                    | (1usize << (MONTH - 132))
                                                    | (1usize << (NEXT - 132))
                                                    | (1usize << (NFC - 132))
                                                    | (1usize << (NFD - 132))
                                                    | (1usize << (NFKC - 132))
                                                    | (1usize << (NFKD - 132))))
                                                != 0)
                                        || (((_la - 164) & !0x3f) == 0
                                            && ((1usize << (_la - 164))
                                                & ((1usize << (NO - 164))
                                                    | (1usize << (NONE - 164))
                                                    | (1usize << (NORMALIZE - 164))
                                                    | (1usize << (NOT - 164))
                                                    | (1usize << (NULL - 164))
                                                    | (1usize << (NULLIF - 164))
                                                    | (1usize << (NULLS - 164))
                                                    | (1usize << (OBJECT - 164))
                                                    | (1usize << (OF - 164))
                                                    | (1usize << (OFFSET - 164))
                                                    | (1usize << (OMIT - 164))
                                                    | (1usize << (ONE - 164))
                                                    | (1usize << (ONLY - 164))
                                                    | (1usize << (OPTION - 164))
                                                    | (1usize << (ORDINALITY - 164))
                                                    | (1usize << (OUTPUT - 164))
                                                    | (1usize << (OVER - 164))
                                                    | (1usize << (OVERFLOW - 164))
                                                    | (1usize << (PARTITION - 164))
                                                    | (1usize << (PARTITIONS - 164))
                                                    | (1usize << (PASSING - 164))
                                                    | (1usize << (PAST - 164))
                                                    | (1usize << (PATH - 164))
                                                    | (1usize << (PATTERN - 164))
                                                    | (1usize << (PER - 164))
                                                    | (1usize << (PERIOD - 164))
                                                    | (1usize << (PERMUTE - 164))
                                                    | (1usize << (POSITION - 164))))
                                                != 0)
                                        || (((_la - 196) & !0x3f) == 0
                                            && ((1usize << (_la - 196))
                                                & ((1usize << (PRECEDING - 196))
                                                    | (1usize << (PRECISION - 196))
                                                    | (1usize << (PRIVILEGES - 196))
                                                    | (1usize << (PROPERTIES - 196))
                                                    | (1usize << (PRUNE - 196))
                                                    | (1usize << (QUOTES - 196))
                                                    | (1usize << (RANGE - 196))
                                                    | (1usize << (READ - 196))
                                                    | (1usize << (REFRESH - 196))
                                                    | (1usize << (RENAME - 196))
                                                    | (1usize << (REPEATABLE - 196))
                                                    | (1usize << (REPLACE - 196))
                                                    | (1usize << (RESET - 196))
                                                    | (1usize << (RESPECT - 196))
                                                    | (1usize << (RESTRICT - 196))
                                                    | (1usize << (RETURNING - 196))
                                                    | (1usize << (REVOKE - 196))
                                                    | (1usize << (ROLE - 196))
                                                    | (1usize << (ROLES - 196))
                                                    | (1usize << (ROLLBACK - 196))
                                                    | (1usize << (ROW - 196))
                                                    | (1usize << (ROWS - 196))
                                                    | (1usize << (RUNNING - 196))
                                                    | (1usize << (SCALAR - 196))
                                                    | (1usize << (SCHEMA - 196))
                                                    | (1usize << (SCHEMAS - 196))
                                                    | (1usize << (SECOND - 196))
                                                    | (1usize << (SECURITY - 196))))
                                                != 0)
                                        || (((_la - 228) & !0x3f) == 0
                                            && ((1usize << (_la - 228))
                                                & ((1usize << (SEEK - 228))
                                                    | (1usize << (SERIALIZABLE - 228))
                                                    | (1usize << (SESSION - 228))
                                                    | (1usize << (SET - 228))
                                                    | (1usize << (SETS - 228))
                                                    | (1usize << (SHOW - 228))
                                                    | (1usize << (SOME - 228))
                                                    | (1usize << (START - 228))
                                                    | (1usize << (STATS - 228))
                                                    | (1usize << (SUBSET - 228))
                                                    | (1usize << (SUBSTRING - 228))
                                                    | (1usize << (SYSTEM - 228))
                                                    | (1usize << (TABLES - 228))
                                                    | (1usize << (TABLESAMPLE - 228))
                                                    | (1usize << (TEXT - 228))
                                                    | (1usize << (TEXT_STRING - 228))
                                                    | (1usize << (TIES - 228))
                                                    | (1usize << (TIME - 228))
                                                    | (1usize << (TIMESTAMP - 228))
                                                    | (1usize << (TO - 228))
                                                    | (1usize << (TRAILING - 228))
                                                    | (1usize << (TRANSACTION - 228))
                                                    | (1usize << (TRIM - 228))
                                                    | (1usize << (TRUE - 228))
                                                    | (1usize << (TRUNCATE - 228))
                                                    | (1usize << (TRY_CAST - 228))
                                                    | (1usize << (TYPE - 228))
                                                    | (1usize << (UNBOUNDED - 228))))
                                                != 0)
                                        || (((_la - 260) & !0x3f) == 0
                                            && ((1usize << (_la - 260))
                                                & ((1usize << (UNCOMMITTED - 260))
                                                    | (1usize << (UNCONDITIONAL - 260))
                                                    | (1usize << (UNIQUE - 260))
                                                    | (1usize << (UNKNOWN - 260))
                                                    | (1usize << (UNMATCHED - 260))
                                                    | (1usize << (UPDATE - 260))
                                                    | (1usize << (USE - 260))
                                                    | (1usize << (USER - 260))
                                                    | (1usize << (UTF16 - 260))
                                                    | (1usize << (UTF32 - 260))
                                                    | (1usize << (UTF8 - 260))
                                                    | (1usize << (VALIDATE - 260))
                                                    | (1usize << (VALUE - 260))
                                                    | (1usize << (VERBOSE - 260))
                                                    | (1usize << (VERSION - 260))
                                                    | (1usize << (VIEW - 260))
                                                    | (1usize << (WINDOW - 260))
                                                    | (1usize << (WITHIN - 260))
                                                    | (1usize << (WITHOUT - 260))
                                                    | (1usize << (WORK - 260))
                                                    | (1usize << (WRAPPER - 260))
                                                    | (1usize << (WRITE - 260))
                                                    | (1usize << (YEAR - 260))
                                                    | (1usize << (ZONE - 260))))
                                                != 0)
                                        || (((_la - 297) & !0x3f) == 0
                                            && ((1usize << (_la - 297))
                                                & ((1usize << (PLUS - 297))
                                                    | (1usize << (MINUS - 297))
                                                    | (1usize << (QUESTION_MARK - 297))
                                                    | (1usize << (STRING - 297))
                                                    | (1usize
                                                        << (UNICODE_STRING - 297))
                                                    | (1usize
                                                        << (BINARY_LITERAL - 297))
                                                    | (1usize << (INTEGER_VALUE - 297))
                                                    | (1usize << (DECIMAL_VALUE - 297))
                                                    | (1usize << (DOUBLE_VALUE - 297))
                                                    | (1usize << (IDENTIFIER - 297))
                                                    | (1usize
                                                        << (DIGIT_IDENTIFIER - 297))
                                                    | (1usize
                                                        << (QUOTED_IDENTIFIER - 297))
                                                    | (1usize
                                                        << (BACKQUOTED_IDENTIFIER
                                                            - 297))))
                                                != 0)
                                    {
                                        {
                                            /*InvokeRule expression*/
                                            recog.base.set_state(1695);
                                            recog.expression()?;

                                            recog.base.set_state(1700);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _la = recog.base.input.la(1);
                                            while _la == COMMA {
                                                {
                                                    {
                                                        recog.base.set_state(1696);
                                                        recog.base.match_token(
                                                            COMMA,
                                                            &mut recog.err_handler,
                                                        )?;

                                                        /*InvokeRule expression*/
                                                        recog.base.set_state(1697);
                                                        recog.expression()?;
                                                    }
                                                }
                                                recog.base.set_state(1702);
                                                recog
                                                    .err_handler
                                                    .sync(&mut recog.base)?;
                                                _la = recog.base.input.la(1);
                                            }
                                        }
                                    }

                                    recog.base.set_state(1705);
                                    recog
                                        .base
                                        .match_token(T__2, &mut recog.err_handler)?;
                                }
                            }
                            2 => {
                                {
                                    /*InvokeRule expression*/
                                    recog.base.set_state(1706);
                                    recog.expression()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                recog.base.set_state(1717);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    PRUNE => {
                        recog.base.set_state(1711);
                        recog.base.match_token(PRUNE, &mut recog.err_handler)?;

                        recog.base.set_state(1712);
                        recog.base.match_token(WHEN, &mut recog.err_handler)?;

                        recog.base.set_state(1713);
                        recog.base.match_token(EMPTY, &mut recog.err_handler)?;
                    }

                    KEEP => {
                        recog.base.set_state(1714);
                        recog.base.match_token(KEEP, &mut recog.err_handler)?;

                        recog.base.set_state(1715);
                        recog.base.match_token(WHEN, &mut recog.err_handler)?;

                        recog.base.set_state(1716);
                        recog.base.match_token(EMPTY, &mut recog.err_handler)?;
                    }

                    T__2 | COMMA | COPARTITION | ORDER => {}

                    _ => {}
                }
                recog.base.set_state(1735);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == ORDER {
                    {
                        recog.base.set_state(1719);
                        recog.base.match_token(ORDER, &mut recog.err_handler)?;

                        recog.base.set_state(1720);
                        recog.base.match_token(BY, &mut recog.err_handler)?;

                        recog.base.set_state(1733);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(220, &mut recog.base)? {
                            1 => {
                                {
                                    recog.base.set_state(1721);
                                    recog
                                        .base
                                        .match_token(T__1, &mut recog.err_handler)?;

                                    /*InvokeRule sortItem*/
                                    recog.base.set_state(1722);
                                    recog.sortItem()?;

                                    recog.base.set_state(1727);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(1723);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule sortItem*/
                                                recog.base.set_state(1724);
                                                recog.sortItem()?;
                                            }
                                        }
                                        recog.base.set_state(1729);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                    recog.base.set_state(1730);
                                    recog
                                        .base
                                        .match_token(T__2, &mut recog.err_handler)?;
                                }
                            }
                            2 => {
                                {
                                    /*InvokeRule sortItem*/
                                    recog.base.set_state(1732);
                                    recog.sortItem()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tableArgumentRelation ----------------
#[derive(Debug)]
pub enum TableArgumentRelationContextAll<'input> {
    TableArgumentQueryContext(TableArgumentQueryContext<'input>),
    TableArgumentTableContext(TableArgumentTableContext<'input>),
    Error(TableArgumentRelationContext<'input>),
}
antlr_rust::tid! {TableArgumentRelationContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for TableArgumentRelationContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for TableArgumentRelationContextAll<'input> {}

impl<'input> Deref for TableArgumentRelationContextAll<'input> {
    type Target = dyn TableArgumentRelationContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use TableArgumentRelationContextAll::*;
        match self {
            TableArgumentQueryContext(inner) => inner,
            TableArgumentTableContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableArgumentRelationContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type TableArgumentRelationContext<'input> =
    BaseParserRuleContext<'input, TableArgumentRelationContextExt<'input>>;

#[derive(Clone)]
pub struct TableArgumentRelationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TableArgumentRelationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableArgumentRelationContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for TableArgumentRelationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tableArgumentRelation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tableArgumentRelation }
}
antlr_rust::tid! {TableArgumentRelationContextExt<'a>}

impl<'input> TableArgumentRelationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TableArgumentRelationContextAll<'input>> {
        Rc::new(TableArgumentRelationContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                TableArgumentRelationContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait TableArgumentRelationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TableArgumentRelationContextExt<'input>>
{
}

impl<'input> TableArgumentRelationContextAttrs<'input>
    for TableArgumentRelationContext<'input>
{
}

pub type TableArgumentQueryContext<'input> =
    BaseParserRuleContext<'input, TableArgumentQueryContextExt<'input>>;

pub trait TableArgumentQueryContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TableArgumentQueryContextAttrs<'input>
    for TableArgumentQueryContext<'input>
{
}

pub struct TableArgumentQueryContextExt<'input> {
    base: TableArgumentRelationContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TableArgumentQueryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TableArgumentQueryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableArgumentQueryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableArgumentQuery(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableArgumentQueryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tableArgumentRelation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tableArgumentRelation }
}

impl<'input> Borrow<TableArgumentRelationContextExt<'input>>
    for TableArgumentQueryContext<'input>
{
    fn borrow(&self) -> &TableArgumentRelationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<TableArgumentRelationContextExt<'input>>
    for TableArgumentQueryContext<'input>
{
    fn borrow_mut(&mut self) -> &mut TableArgumentRelationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> TableArgumentRelationContextAttrs<'input>
    for TableArgumentQueryContext<'input>
{
}

impl<'input> TableArgumentQueryContextExt<'input> {
    fn new(
        ctx: &dyn TableArgumentRelationContextAttrs<'input>,
    ) -> Rc<TableArgumentRelationContextAll<'input>> {
        Rc::new(TableArgumentRelationContextAll::TableArgumentQueryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TableArgumentQueryContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TableArgumentTableContext<'input> =
    BaseParserRuleContext<'input, TableArgumentTableContextExt<'input>>;

pub trait TableArgumentTableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TABLE
    /// Returns `None` if there is no child corresponding to token TABLE
    fn TABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLE, 0)
    }
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TableArgumentTableContextAttrs<'input>
    for TableArgumentTableContext<'input>
{
}

pub struct TableArgumentTableContextExt<'input> {
    base: TableArgumentRelationContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TableArgumentTableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TableArgumentTableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TableArgumentTableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tableArgumentTable(self);
    }
}

impl<'input> CustomRuleContext<'input> for TableArgumentTableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tableArgumentRelation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tableArgumentRelation }
}

impl<'input> Borrow<TableArgumentRelationContextExt<'input>>
    for TableArgumentTableContext<'input>
{
    fn borrow(&self) -> &TableArgumentRelationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<TableArgumentRelationContextExt<'input>>
    for TableArgumentTableContext<'input>
{
    fn borrow_mut(&mut self) -> &mut TableArgumentRelationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> TableArgumentRelationContextAttrs<'input>
    for TableArgumentTableContext<'input>
{
}

impl<'input> TableArgumentTableContextExt<'input> {
    fn new(
        ctx: &dyn TableArgumentRelationContextAttrs<'input>,
    ) -> Rc<TableArgumentRelationContextAll<'input>> {
        Rc::new(TableArgumentRelationContextAll::TableArgumentTableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TableArgumentTableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tableArgumentRelation(
        &mut self,
    ) -> Result<Rc<TableArgumentRelationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = TableArgumentRelationContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 104, RULE_tableArgumentRelation);
        let mut _localctx: Rc<TableArgumentRelationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1763);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(228, &mut recog.base)? {
                1 => {
                    let tmp = TableArgumentTableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1737);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(1738);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule qualifiedName*/
                        recog.base.set_state(1739);
                        recog.qualifiedName()?;

                        recog.base.set_state(1740);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;

                        recog.base.set_state(1748);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(224, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1742);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == AS {
                                        {
                                            recog.base.set_state(1741);
                                            recog.base.match_token(
                                                AS,
                                                &mut recog.err_handler,
                                            )?;
                                        }
                                    }

                                    /*InvokeRule identifier*/
                                    recog.base.set_state(1744);
                                    recog.identifier()?;

                                    recog.base.set_state(1746);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == T__1 {
                                        {
                                            /*InvokeRule columnAliases*/
                                            recog.base.set_state(1745);
                                            recog.columnAliases()?;
                                        }
                                    }
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    let tmp = TableArgumentQueryContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1750);
                        recog.base.match_token(TABLE, &mut recog.err_handler)?;

                        recog.base.set_state(1751);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(1752);
                        recog.query()?;

                        recog.base.set_state(1753);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;

                        recog.base.set_state(1761);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(227, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1755);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == AS {
                                        {
                                            recog.base.set_state(1754);
                                            recog.base.match_token(
                                                AS,
                                                &mut recog.err_handler,
                                            )?;
                                        }
                                    }

                                    /*InvokeRule identifier*/
                                    recog.base.set_state(1757);
                                    recog.identifier()?;

                                    recog.base.set_state(1759);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == T__1 {
                                        {
                                            /*InvokeRule columnAliases*/
                                            recog.base.set_state(1758);
                                            recog.columnAliases()?;
                                        }
                                    }
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- descriptorArgument ----------------
pub type DescriptorArgumentContextAll<'input> = DescriptorArgumentContext<'input>;

pub type DescriptorArgumentContext<'input> =
    BaseParserRuleContext<'input, DescriptorArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct DescriptorArgumentContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for DescriptorArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DescriptorArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_descriptorArgument(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_descriptorArgument(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for DescriptorArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_descriptorArgument
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_descriptorArgument }
}
antlr_rust::tid! {DescriptorArgumentContextExt<'a>}

impl<'input> DescriptorArgumentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<DescriptorArgumentContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            DescriptorArgumentContextExt { ph: PhantomData },
        ))
    }
}

pub trait DescriptorArgumentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<DescriptorArgumentContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token DESCRIPTOR
    /// Returns `None` if there is no child corresponding to token DESCRIPTOR
    fn DESCRIPTOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESCRIPTOR, 0)
    }
    fn descriptorField_all(&self) -> Vec<Rc<DescriptorFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn descriptorField(&self, i: usize) -> Option<Rc<DescriptorFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token CAST
    /// Returns `None` if there is no child corresponding to token CAST
    fn CAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CAST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
}

impl<'input> DescriptorArgumentContextAttrs<'input>
    for DescriptorArgumentContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn descriptorArgument(
        &mut self,
    ) -> Result<Rc<DescriptorArgumentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            DescriptorArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 106, RULE_descriptorArgument);
        let mut _localctx: Rc<DescriptorArgumentContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1783);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                DESCRIPTOR => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1765);
                        recog.base.match_token(DESCRIPTOR, &mut recog.err_handler)?;

                        recog.base.set_state(1766);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule descriptorField*/
                        recog.base.set_state(1767);
                        recog.descriptorField()?;

                        recog.base.set_state(1772);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1768);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule descriptorField*/
                                    recog.base.set_state(1769);
                                    recog.descriptorField()?;
                                }
                            }
                            recog.base.set_state(1774);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1775);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                CAST => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1777);
                        recog.base.match_token(CAST, &mut recog.err_handler)?;

                        recog.base.set_state(1778);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        recog.base.set_state(1779);
                        recog.base.match_token(NULL, &mut recog.err_handler)?;

                        recog.base.set_state(1780);
                        recog.base.match_token(AS, &mut recog.err_handler)?;

                        recog.base.set_state(1781);
                        recog.base.match_token(DESCRIPTOR, &mut recog.err_handler)?;

                        recog.base.set_state(1782);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- descriptorField ----------------
pub type DescriptorFieldContextAll<'input> = DescriptorFieldContext<'input>;

pub type DescriptorFieldContext<'input> =
    BaseParserRuleContext<'input, DescriptorFieldContextExt<'input>>;

#[derive(Clone)]
pub struct DescriptorFieldContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for DescriptorFieldContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DescriptorFieldContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_descriptorField(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_descriptorField(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for DescriptorFieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_descriptorField
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_descriptorField }
}
antlr_rust::tid! {DescriptorFieldContextExt<'a>}

impl<'input> DescriptorFieldContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<DescriptorFieldContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            DescriptorFieldContextExt { ph: PhantomData },
        ))
    }
}

pub trait DescriptorFieldContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<DescriptorFieldContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> DescriptorFieldContextAttrs<'input> for DescriptorFieldContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn descriptorField(
        &mut self,
    ) -> Result<Rc<DescriptorFieldContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            DescriptorFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 108, RULE_descriptorField);
        let mut _localctx: Rc<DescriptorFieldContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(1785);
                recog.identifier()?;

                recog.base.set_state(1787);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << ABSENT)
                            | (1usize << ADD)
                            | (1usize << ADMIN)
                            | (1usize << AFTER)
                            | (1usize << ALL)
                            | (1usize << ANALYZE)
                            | (1usize << ANY)
                            | (1usize << ARRAY)
                            | (1usize << ASC)
                            | (1usize << AT)
                            | (1usize << AUTHORIZATION)
                            | (1usize << BERNOULLI)))
                        != 0)
                    || (((_la - 33) & !0x3f) == 0
                        && ((1usize << (_la - 33))
                            & ((1usize << (BOTH - 33))
                                | (1usize << (CALL - 33))
                                | (1usize << (CASCADE - 33))
                                | (1usize << (CATALOGS - 33))
                                | (1usize << (COLUMN - 33))
                                | (1usize << (COLUMNS - 33))
                                | (1usize << (COMMENT - 33))
                                | (1usize << (COMMIT - 33))
                                | (1usize << (COMMITTED - 33))
                                | (1usize << (CONDITIONAL - 33))
                                | (1usize << (COUNT - 33))
                                | (1usize << (COPARTITION - 33))
                                | (1usize << (CURRENT - 33))
                                | (1usize << (DATA - 33))
                                | (1usize << (DATE - 33))
                                | (1usize << (DAY - 33))))
                            != 0)
                    || (((_la - 66) & !0x3f) == 0
                        && ((1usize << (_la - 66))
                            & ((1usize << (DEFAULT - 66))
                                | (1usize << (DEFINE - 66))
                                | (1usize << (DEFINER - 66))
                                | (1usize << (DENY - 66))
                                | (1usize << (DESC - 66))
                                | (1usize << (DESCRIPTOR - 66))
                                | (1usize << (DISTRIBUTED - 66))
                                | (1usize << (DOUBLE - 66))
                                | (1usize << (EMPTY - 66))
                                | (1usize << (ENCODING - 66))
                                | (1usize << (ERROR - 66))
                                | (1usize << (EXCLUDING - 66))
                                | (1usize << (EXPLAIN - 66))
                                | (1usize << (FETCH - 66))
                                | (1usize << (FILTER - 66))
                                | (1usize << (FINAL - 66))
                                | (1usize << (FIRST - 66))
                                | (1usize << (FOLLOWING - 66))
                                | (1usize << (FORMAT - 66))))
                            != 0)
                    || (((_la - 100) & !0x3f) == 0
                        && ((1usize << (_la - 100))
                            & ((1usize << (FUNCTIONS - 100))
                                | (1usize << (GRACE - 100))
                                | (1usize << (GRANT - 100))
                                | (1usize << (GRANTED - 100))
                                | (1usize << (GRANTS - 100))
                                | (1usize << (GRAPHVIZ - 100))
                                | (1usize << (GROUPS - 100))
                                | (1usize << (HOUR - 100))
                                | (1usize << (IF - 100))
                                | (1usize << (IGNORE - 100))
                                | (1usize << (INCLUDING - 100))
                                | (1usize << (INITIAL - 100))
                                | (1usize << (INPUT - 100))
                                | (1usize << (INTERVAL - 100))
                                | (1usize << (INVOKER - 100))
                                | (1usize << (IO - 100))
                                | (1usize << (ISOLATION - 100))
                                | (1usize << (JSON - 100))))
                            != 0)
                    || (((_la - 133) & !0x3f) == 0
                        && ((1usize << (_la - 133))
                            & ((1usize << (KEEP - 133))
                                | (1usize << (KEY - 133))
                                | (1usize << (KEYS - 133))
                                | (1usize << (LAST - 133))
                                | (1usize << (LATERAL - 133))
                                | (1usize << (LEADING - 133))
                                | (1usize << (LEVEL - 133))
                                | (1usize << (LIMIT - 133))
                                | (1usize << (LOCAL - 133))
                                | (1usize << (LOGICAL - 133))
                                | (1usize << (MAP - 133))
                                | (1usize << (MATCH - 133))
                                | (1usize << (MATCHED - 133))
                                | (1usize << (MATCHES - 133))
                                | (1usize << (MATCH_RECOGNIZE - 133))
                                | (1usize << (MATERIALIZED - 133))
                                | (1usize << (MEASURES - 133))
                                | (1usize << (MERGE - 133))
                                | (1usize << (MINUTE - 133))
                                | (1usize << (MONTH - 133))
                                | (1usize << (NEXT - 133))
                                | (1usize << (NFC - 133))
                                | (1usize << (NFD - 133))
                                | (1usize << (NFKC - 133))
                                | (1usize << (NFKD - 133))
                                | (1usize << (NO - 133))))
                            != 0)
                    || (((_la - 165) & !0x3f) == 0
                        && ((1usize << (_la - 165))
                            & ((1usize << (NONE - 165))
                                | (1usize << (NULLIF - 165))
                                | (1usize << (NULLS - 165))
                                | (1usize << (OBJECT - 165))
                                | (1usize << (OF - 165))
                                | (1usize << (OFFSET - 165))
                                | (1usize << (OMIT - 165))
                                | (1usize << (ONE - 165))
                                | (1usize << (ONLY - 165))
                                | (1usize << (OPTION - 165))
                                | (1usize << (ORDINALITY - 165))
                                | (1usize << (OUTPUT - 165))
                                | (1usize << (OVER - 165))
                                | (1usize << (OVERFLOW - 165))
                                | (1usize << (PARTITION - 165))
                                | (1usize << (PARTITIONS - 165))
                                | (1usize << (PASSING - 165))
                                | (1usize << (PAST - 165))
                                | (1usize << (PATH - 165))
                                | (1usize << (PATTERN - 165))
                                | (1usize << (PER - 165))
                                | (1usize << (PERIOD - 165))
                                | (1usize << (PERMUTE - 165))
                                | (1usize << (POSITION - 165))
                                | (1usize << (PRECEDING - 165))))
                            != 0)
                    || (((_la - 197) & !0x3f) == 0
                        && ((1usize << (_la - 197))
                            & ((1usize << (PRECISION - 197))
                                | (1usize << (PRIVILEGES - 197))
                                | (1usize << (PROPERTIES - 197))
                                | (1usize << (PRUNE - 197))
                                | (1usize << (QUOTES - 197))
                                | (1usize << (RANGE - 197))
                                | (1usize << (READ - 197))
                                | (1usize << (REFRESH - 197))
                                | (1usize << (RENAME - 197))
                                | (1usize << (REPEATABLE - 197))
                                | (1usize << (REPLACE - 197))
                                | (1usize << (RESET - 197))
                                | (1usize << (RESPECT - 197))
                                | (1usize << (RESTRICT - 197))
                                | (1usize << (RETURNING - 197))
                                | (1usize << (REVOKE - 197))
                                | (1usize << (ROLE - 197))
                                | (1usize << (ROLES - 197))
                                | (1usize << (ROLLBACK - 197))
                                | (1usize << (ROW - 197))
                                | (1usize << (ROWS - 197))
                                | (1usize << (RUNNING - 197))
                                | (1usize << (SCALAR - 197))
                                | (1usize << (SCHEMA - 197))
                                | (1usize << (SCHEMAS - 197))
                                | (1usize << (SECOND - 197))
                                | (1usize << (SECURITY - 197))
                                | (1usize << (SEEK - 197))))
                            != 0)
                    || (((_la - 230) & !0x3f) == 0
                        && ((1usize << (_la - 230))
                            & ((1usize << (SERIALIZABLE - 230))
                                | (1usize << (SESSION - 230))
                                | (1usize << (SET - 230))
                                | (1usize << (SETS - 230))
                                | (1usize << (SHOW - 230))
                                | (1usize << (SOME - 230))
                                | (1usize << (START - 230))
                                | (1usize << (STATS - 230))
                                | (1usize << (SUBSET - 230))
                                | (1usize << (SUBSTRING - 230))
                                | (1usize << (SYSTEM - 230))
                                | (1usize << (TABLES - 230))
                                | (1usize << (TABLESAMPLE - 230))
                                | (1usize << (TEXT - 230))
                                | (1usize << (TEXT_STRING - 230))
                                | (1usize << (TIES - 230))
                                | (1usize << (TIME - 230))
                                | (1usize << (TIMESTAMP - 230))
                                | (1usize << (TO - 230))
                                | (1usize << (TRAILING - 230))
                                | (1usize << (TRANSACTION - 230))
                                | (1usize << (TRUNCATE - 230))
                                | (1usize << (TRY_CAST - 230))
                                | (1usize << (TYPE - 230))
                                | (1usize << (UNBOUNDED - 230))
                                | (1usize << (UNCOMMITTED - 230))
                                | (1usize << (UNCONDITIONAL - 230))))
                            != 0)
                    || (((_la - 263) & !0x3f) == 0
                        && ((1usize << (_la - 263))
                            & ((1usize << (UNIQUE - 263))
                                | (1usize << (UNKNOWN - 263))
                                | (1usize << (UNMATCHED - 263))
                                | (1usize << (UPDATE - 263))
                                | (1usize << (USE - 263))
                                | (1usize << (USER - 263))
                                | (1usize << (UTF16 - 263))
                                | (1usize << (UTF32 - 263))
                                | (1usize << (UTF8 - 263))
                                | (1usize << (VALIDATE - 263))
                                | (1usize << (VALUE - 263))
                                | (1usize << (VERBOSE - 263))
                                | (1usize << (VERSION - 263))
                                | (1usize << (VIEW - 263))
                                | (1usize << (WINDOW - 263))
                                | (1usize << (WITHIN - 263))
                                | (1usize << (WITHOUT - 263))
                                | (1usize << (WORK - 263))
                                | (1usize << (WRAPPER - 263))
                                | (1usize << (WRITE - 263))
                                | (1usize << (YEAR - 263))
                                | (1usize << (ZONE - 263))))
                            != 0)
                    || (((_la - 310) & !0x3f) == 0
                        && ((1usize << (_la - 310))
                            & ((1usize << (IDENTIFIER - 310))
                                | (1usize << (DIGIT_IDENTIFIER - 310))
                                | (1usize << (QUOTED_IDENTIFIER - 310))
                                | (1usize << (BACKQUOTED_IDENTIFIER - 310))))
                            != 0)
                {
                    {
                        /*InvokeRule type_*/
                        recog.base.set_state(1786);
                        recog.type__rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- copartitionTables ----------------
pub type CopartitionTablesContextAll<'input> = CopartitionTablesContext<'input>;

pub type CopartitionTablesContext<'input> =
    BaseParserRuleContext<'input, CopartitionTablesContextExt<'input>>;

#[derive(Clone)]
pub struct CopartitionTablesContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for CopartitionTablesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CopartitionTablesContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_copartitionTables(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_copartitionTables(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for CopartitionTablesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_copartitionTables
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_copartitionTables }
}
antlr_rust::tid! {CopartitionTablesContextExt<'a>}

impl<'input> CopartitionTablesContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<CopartitionTablesContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            CopartitionTablesContextExt { ph: PhantomData },
        ))
    }
}

pub trait CopartitionTablesContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<CopartitionTablesContextExt<'input>>
{
    fn qualifiedName_all(&self) -> Vec<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> CopartitionTablesContextAttrs<'input> for CopartitionTablesContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn copartitionTables(
        &mut self,
    ) -> Result<Rc<CopartitionTablesContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            CopartitionTablesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 110, RULE_copartitionTables);
        let mut _localctx: Rc<CopartitionTablesContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1789);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                /*InvokeRule qualifiedName*/
                recog.base.set_state(1790);
                recog.qualifiedName()?;

                recog.base.set_state(1791);
                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                /*InvokeRule qualifiedName*/
                recog.base.set_state(1792);
                recog.qualifiedName()?;

                recog.base.set_state(1797);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA {
                    {
                        {
                            recog.base.set_state(1793);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule qualifiedName*/
                            recog.base.set_state(1794);
                            recog.qualifiedName()?;
                        }
                    }
                    recog.base.set_state(1799);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1800);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;

pub type ExpressionContext<'input> =
    BaseParserRuleContext<'input, ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ExpressionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_expression(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_expression(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid! {ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ExpressionContextExt { ph: PhantomData },
        ))
    }
}

pub trait ExpressionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>
{
    fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression(&mut self) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 112, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule booleanExpression*/
                recog.base.set_state(1802);
                recog.booleanExpression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- booleanExpression ----------------
#[derive(Debug)]
pub enum BooleanExpressionContextAll<'input> {
    LogicalNotContext(LogicalNotContext<'input>),
    PredicatedContext(PredicatedContext<'input>),
    OrContext(OrContext<'input>),
    AndContext(AndContext<'input>),
    Error(BooleanExpressionContext<'input>),
}
antlr_rust::tid! {BooleanExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for BooleanExpressionContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for BooleanExpressionContextAll<'input> {}

impl<'input> Deref for BooleanExpressionContextAll<'input> {
    type Target = dyn BooleanExpressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use BooleanExpressionContextAll::*;
        match self {
            LogicalNotContext(inner) => inner,
            PredicatedContext(inner) => inner,
            OrContext(inner) => inner,
            AndContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BooleanExpressionContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type BooleanExpressionContext<'input> =
    BaseParserRuleContext<'input, BooleanExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct BooleanExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for BooleanExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BooleanExpressionContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for BooleanExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_booleanExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}
antlr_rust::tid! {BooleanExpressionContextExt<'a>}

impl<'input> BooleanExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<BooleanExpressionContextAll<'input>> {
        Rc::new(BooleanExpressionContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                BooleanExpressionContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait BooleanExpressionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<BooleanExpressionContextExt<'input>>
{
}

impl<'input> BooleanExpressionContextAttrs<'input> for BooleanExpressionContext<'input> {}

pub type LogicalNotContext<'input> =
    BaseParserRuleContext<'input, LogicalNotContextExt<'input>>;

pub trait LogicalNotContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> LogicalNotContextAttrs<'input> for LogicalNotContext<'input> {}

pub struct LogicalNotContextExt<'input> {
    base: BooleanExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {LogicalNotContextExt<'a>}

impl<'input> PrestoParserContext<'input> for LogicalNotContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for LogicalNotContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_logicalNot(self);
    }
}

impl<'input> CustomRuleContext<'input> for LogicalNotContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_booleanExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for LogicalNotContext<'input> {
    fn borrow(&self) -> &BooleanExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>>
    for LogicalNotContext<'input>
{
    fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> BooleanExpressionContextAttrs<'input> for LogicalNotContext<'input> {}

impl<'input> LogicalNotContextExt<'input> {
    fn new(
        ctx: &dyn BooleanExpressionContextAttrs<'input>,
    ) -> Rc<BooleanExpressionContextAll<'input>> {
        Rc::new(BooleanExpressionContextAll::LogicalNotContext(
            BaseParserRuleContext::copy_from(
                ctx,
                LogicalNotContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PredicatedContext<'input> =
    BaseParserRuleContext<'input, PredicatedContextExt<'input>>;

pub trait PredicatedContextAttrs<'input>: PrestoParserContext<'input> {
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn predicate(&self) -> Option<Rc<PredicateContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> PredicatedContextAttrs<'input> for PredicatedContext<'input> {}

pub struct PredicatedContextExt<'input> {
    base: BooleanExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PredicatedContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PredicatedContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PredicatedContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_predicated(self);
    }
}

impl<'input> CustomRuleContext<'input> for PredicatedContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_booleanExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for PredicatedContext<'input> {
    fn borrow(&self) -> &BooleanExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>>
    for PredicatedContext<'input>
{
    fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> BooleanExpressionContextAttrs<'input> for PredicatedContext<'input> {}

impl<'input> PredicatedContextExt<'input> {
    fn new(
        ctx: &dyn BooleanExpressionContextAttrs<'input>,
    ) -> Rc<BooleanExpressionContextAll<'input>> {
        Rc::new(BooleanExpressionContextAll::PredicatedContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PredicatedContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type OrContext<'input> = BaseParserRuleContext<'input, OrContextExt<'input>>;

pub trait OrContextAttrs<'input>: PrestoParserContext<'input> {
    fn booleanExpression_all(&self) -> Vec<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn booleanExpression(
        &self,
        i: usize,
    ) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OR
    /// Returns `None` if there is no child corresponding to token OR
    fn OR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OR, 0)
    }
}

impl<'input> OrContextAttrs<'input> for OrContext<'input> {}

pub struct OrContextExt<'input> {
    base: BooleanExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OrContextExt<'a>}

impl<'input> PrestoParserContext<'input> for OrContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for OrContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_or(self);
    }
}

impl<'input> CustomRuleContext<'input> for OrContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_booleanExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for OrContext<'input> {
    fn borrow(&self) -> &BooleanExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>> for OrContext<'input> {
    fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> BooleanExpressionContextAttrs<'input> for OrContext<'input> {}

impl<'input> OrContextExt<'input> {
    fn new(
        ctx: &dyn BooleanExpressionContextAttrs<'input>,
    ) -> Rc<BooleanExpressionContextAll<'input>> {
        Rc::new(BooleanExpressionContextAll::OrContext(
            BaseParserRuleContext::copy_from(
                ctx,
                OrContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type AndContext<'input> = BaseParserRuleContext<'input, AndContextExt<'input>>;

pub trait AndContextAttrs<'input>: PrestoParserContext<'input> {
    fn booleanExpression_all(&self) -> Vec<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn booleanExpression(
        &self,
        i: usize,
    ) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token AND
    /// Returns `None` if there is no child corresponding to token AND
    fn AND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AND, 0)
    }
}

impl<'input> AndContextAttrs<'input> for AndContext<'input> {}

pub struct AndContextExt<'input> {
    base: BooleanExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AndContextExt<'a>}

impl<'input> PrestoParserContext<'input> for AndContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for AndContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_and(self);
    }
}

impl<'input> CustomRuleContext<'input> for AndContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_booleanExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for AndContext<'input> {
    fn borrow(&self) -> &BooleanExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>> for AndContext<'input> {
    fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> BooleanExpressionContextAttrs<'input> for AndContext<'input> {}

impl<'input> AndContextExt<'input> {
    fn new(
        ctx: &dyn BooleanExpressionContextAttrs<'input>,
    ) -> Rc<BooleanExpressionContextAll<'input>> {
        Rc::new(BooleanExpressionContextAll::AndContext(
            BaseParserRuleContext::copy_from(
                ctx,
                AndContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn booleanExpression(
        &mut self,
    ) -> Result<Rc<BooleanExpressionContextAll<'input>>, ANTLRError> {
        self.booleanExpression_rec(0)
    }

    fn booleanExpression_rec(
        &mut self,
        _p: isize,
    ) -> Result<Rc<BooleanExpressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx =
            BooleanExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(
            _localctx.clone(),
            114,
            RULE_booleanExpression,
            _p,
        );
        let mut _localctx: Rc<BooleanExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 114;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1811);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    T__1
                    | ABSENT
                    | ADD
                    | ADMIN
                    | AFTER
                    | ALL
                    | ANALYZE
                    | ANY
                    | ARRAY
                    | ASC
                    | AT
                    | AUTHORIZATION
                    | BERNOULLI
                    | BOTH
                    | CALL
                    | CASCADE
                    | CASE
                    | CAST
                    | CATALOGS
                    | COLUMN
                    | COLUMNS
                    | COMMENT
                    | COMMIT
                    | COMMITTED
                    | CONDITIONAL
                    | COUNT
                    | COPARTITION
                    | CURRENT
                    | CURRENT_CATALOG
                    | CURRENT_DATE
                    | CURRENT_PATH
                    | CURRENT_SCHEMA
                    | CURRENT_TIME
                    | CURRENT_TIMESTAMP
                    | CURRENT_USER
                    | DATA
                    | DATE
                    | DAY
                    | DEFAULT
                    | DEFINE
                    | DEFINER
                    | DENY
                    | DESC
                    | DESCRIPTOR
                    | DISTRIBUTED
                    | DOUBLE
                    | EMPTY
                    | ENCODING
                    | ERROR
                    | EXCLUDING
                    | EXISTS
                    | EXPLAIN
                    | EXTRACT
                    | FALSE
                    | FETCH
                    | FILTER
                    | FINAL
                    | FIRST
                    | FOLLOWING
                    | FORMAT
                    | FUNCTIONS
                    | GRACE
                    | GRANT
                    | GRANTED
                    | GRANTS
                    | GRAPHVIZ
                    | GROUPING
                    | GROUPS
                    | HOUR
                    | IF
                    | IGNORE
                    | INCLUDING
                    | INITIAL
                    | INPUT
                    | INTERVAL
                    | INVOKER
                    | IO
                    | ISOLATION
                    | JSON
                    | JSON_ARRAY
                    | JSON_EXISTS
                    | JSON_OBJECT
                    | JSON_QUERY
                    | JSON_VALUE
                    | KEEP
                    | KEY
                    | KEYS
                    | LAST
                    | LATERAL
                    | LEADING
                    | LEVEL
                    | LIMIT
                    | LISTAGG
                    | LOCAL
                    | LOCALTIME
                    | LOCALTIMESTAMP
                    | LOGICAL
                    | MAP
                    | MATCH
                    | MATCHED
                    | MATCHES
                    | MATCH_RECOGNIZE
                    | MATERIALIZED
                    | MEASURES
                    | MERGE
                    | MINUTE
                    | MONTH
                    | NEXT
                    | NFC
                    | NFD
                    | NFKC
                    | NFKD
                    | NO
                    | NONE
                    | NORMALIZE
                    | NULL
                    | NULLIF
                    | NULLS
                    | OBJECT
                    | OF
                    | OFFSET
                    | OMIT
                    | ONE
                    | ONLY
                    | OPTION
                    | ORDINALITY
                    | OUTPUT
                    | OVER
                    | OVERFLOW
                    | PARTITION
                    | PARTITIONS
                    | PASSING
                    | PAST
                    | PATH
                    | PATTERN
                    | PER
                    | PERIOD
                    | PERMUTE
                    | POSITION
                    | PRECEDING
                    | PRECISION
                    | PRIVILEGES
                    | PROPERTIES
                    | PRUNE
                    | QUOTES
                    | RANGE
                    | READ
                    | REFRESH
                    | RENAME
                    | REPEATABLE
                    | REPLACE
                    | RESET
                    | RESPECT
                    | RESTRICT
                    | RETURNING
                    | REVOKE
                    | ROLE
                    | ROLES
                    | ROLLBACK
                    | ROW
                    | ROWS
                    | RUNNING
                    | SCALAR
                    | SCHEMA
                    | SCHEMAS
                    | SECOND
                    | SECURITY
                    | SEEK
                    | SERIALIZABLE
                    | SESSION
                    | SET
                    | SETS
                    | SHOW
                    | SOME
                    | START
                    | STATS
                    | SUBSET
                    | SUBSTRING
                    | SYSTEM
                    | TABLES
                    | TABLESAMPLE
                    | TEXT
                    | TEXT_STRING
                    | TIES
                    | TIME
                    | TIMESTAMP
                    | TO
                    | TRAILING
                    | TRANSACTION
                    | TRIM
                    | TRUE
                    | TRUNCATE
                    | TRY_CAST
                    | TYPE
                    | UNBOUNDED
                    | UNCOMMITTED
                    | UNCONDITIONAL
                    | UNIQUE
                    | UNKNOWN
                    | UNMATCHED
                    | UPDATE
                    | USE
                    | USER
                    | UTF16
                    | UTF32
                    | UTF8
                    | VALIDATE
                    | VALUE
                    | VERBOSE
                    | VERSION
                    | VIEW
                    | WINDOW
                    | WITHIN
                    | WITHOUT
                    | WORK
                    | WRAPPER
                    | WRITE
                    | YEAR
                    | ZONE
                    | PLUS
                    | MINUS
                    | QUESTION_MARK
                    | STRING
                    | UNICODE_STRING
                    | BINARY_LITERAL
                    | INTEGER_VALUE
                    | DECIMAL_VALUE
                    | DOUBLE_VALUE
                    | IDENTIFIER
                    | DIGIT_IDENTIFIER
                    | QUOTED_IDENTIFIER
                    | BACKQUOTED_IDENTIFIER => {
                        {
                            let mut tmp = PredicatedContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(1805);
                            recog.valueExpression_rec(0)?;

                            recog.base.set_state(1807);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(233, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule predicate*/
                                        recog.base.set_state(1806);
                                        recog.predicate()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }

                    NOT => {
                        {
                            let mut tmp = LogicalNotContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1809);
                            recog.base.match_token(NOT, &mut recog.err_handler)?;

                            /*InvokeRule booleanExpression*/
                            recog.base.set_state(1810);
                            recog.booleanExpression_rec(3)?;
                        }
                    }

                    _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                        &mut recog.base,
                    )))?,
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1821);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(236, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1819);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(235, &mut recog.base)?
                            {
                                1 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = AndContextExt::new(
                                            &**BooleanExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_booleanExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1813);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 2)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1814);
                                        recog
                                            .base
                                            .match_token(AND, &mut recog.err_handler)?;

                                        /*InvokeRule booleanExpression*/
                                        recog.base.set_state(1815);
                                        recog.booleanExpression_rec(3)?;
                                    }
                                }
                                2 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = OrContextExt::new(
                                            &**BooleanExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_booleanExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1816);
                                        if !({ recog.precpred(None, 1) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 1)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1817);
                                        recog
                                            .base
                                            .match_token(OR, &mut recog.err_handler)?;

                                        /*InvokeRule booleanExpression*/
                                        recog.base.set_state(1818);
                                        recog.booleanExpression_rec(2)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1823);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(236, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- predicate ----------------
#[derive(Debug)]
pub enum PredicateContextAll<'input> {
    ComparisonContext(ComparisonContext<'input>),
    LikeContext(LikeContext<'input>),
    InSubqueryContext(InSubqueryContext<'input>),
    DistinctFromContext(DistinctFromContext<'input>),
    InListContext(InListContext<'input>),
    NullPredicateContext(NullPredicateContext<'input>),
    BetweenContext(BetweenContext<'input>),
    QuantifiedComparisonContext(QuantifiedComparisonContext<'input>),
    Error(PredicateContext<'input>),
}
antlr_rust::tid! {PredicateContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PredicateContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for PredicateContextAll<'input> {}

impl<'input> Deref for PredicateContextAll<'input> {
    type Target = dyn PredicateContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use PredicateContextAll::*;
        match self {
            ComparisonContext(inner) => inner,
            LikeContext(inner) => inner,
            InSubqueryContext(inner) => inner,
            DistinctFromContext(inner) => inner,
            InListContext(inner) => inner,
            NullPredicateContext(inner) => inner,
            BetweenContext(inner) => inner,
            QuantifiedComparisonContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PredicateContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type PredicateContext<'input> =
    BaseParserRuleContext<'input, PredicateContextExt<'input>>;

#[derive(Clone)]
pub struct PredicateContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PredicateContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PredicateContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for PredicateContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}
antlr_rust::tid! {PredicateContextExt<'a>}

impl<'input> PredicateContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                PredicateContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait PredicateContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PredicateContextExt<'input>>
{
}

impl<'input> PredicateContextAttrs<'input> for PredicateContext<'input> {}

pub type ComparisonContext<'input> =
    BaseParserRuleContext<'input, ComparisonContextExt<'input>>;

pub trait ComparisonContextAttrs<'input>: PrestoParserContext<'input> {
    fn comparisonOperator(&self) -> Option<Rc<ComparisonOperatorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ComparisonContextAttrs<'input> for ComparisonContext<'input> {}

pub struct ComparisonContextExt<'input> {
    base: PredicateContextExt<'input>,
    pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ComparisonContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ComparisonContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ComparisonContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_comparison(self);
    }
}

impl<'input> CustomRuleContext<'input> for ComparisonContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for ComparisonContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for ComparisonContext<'input> {
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for ComparisonContext<'input> {}

impl<'input> ComparisonContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::ComparisonContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ComparisonContextExt {
                    right: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type LikeContext<'input> = BaseParserRuleContext<'input, LikeContextExt<'input>>;

pub trait LikeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token LIKE
    /// Returns `None` if there is no child corresponding to token LIKE
    fn LIKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIKE, 0)
    }
    fn valueExpression_all(&self) -> Vec<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ESCAPE
    /// Returns `None` if there is no child corresponding to token ESCAPE
    fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ESCAPE, 0)
    }
}

impl<'input> LikeContextAttrs<'input> for LikeContext<'input> {}

pub struct LikeContextExt<'input> {
    base: PredicateContextExt<'input>,
    pub pattern: Option<Rc<ValueExpressionContextAll<'input>>>,
    pub escape: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {LikeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for LikeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for LikeContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_like(self);
    }
}

impl<'input> CustomRuleContext<'input> for LikeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for LikeContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for LikeContext<'input> {
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for LikeContext<'input> {}

impl<'input> LikeContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::LikeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                LikeContextExt {
                    pattern: None,
                    escape: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type InSubqueryContext<'input> =
    BaseParserRuleContext<'input, InSubqueryContextExt<'input>>;

pub trait InSubqueryContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
}

impl<'input> InSubqueryContextAttrs<'input> for InSubqueryContext<'input> {}

pub struct InSubqueryContextExt<'input> {
    base: PredicateContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {InSubqueryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for InSubqueryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for InSubqueryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_inSubquery(self);
    }
}

impl<'input> CustomRuleContext<'input> for InSubqueryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for InSubqueryContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for InSubqueryContext<'input> {
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for InSubqueryContext<'input> {}

impl<'input> InSubqueryContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::InSubqueryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                InSubqueryContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DistinctFromContext<'input> =
    BaseParserRuleContext<'input, DistinctFromContextExt<'input>>;

pub trait DistinctFromContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token IS
    /// Returns `None` if there is no child corresponding to token IS
    fn IS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DISTINCT
    /// Returns `None` if there is no child corresponding to token DISTINCT
    fn DISTINCT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DISTINCT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
}

impl<'input> DistinctFromContextAttrs<'input> for DistinctFromContext<'input> {}

pub struct DistinctFromContextExt<'input> {
    base: PredicateContextExt<'input>,
    pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DistinctFromContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DistinctFromContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DistinctFromContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_distinctFrom(self);
    }
}

impl<'input> CustomRuleContext<'input> for DistinctFromContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for DistinctFromContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for DistinctFromContext<'input> {
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for DistinctFromContext<'input> {}

impl<'input> DistinctFromContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::DistinctFromContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DistinctFromContextExt {
                    right: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type InListContext<'input> = BaseParserRuleContext<'input, InListContextExt<'input>>;

pub trait InListContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> InListContextAttrs<'input> for InListContext<'input> {}

pub struct InListContextExt<'input> {
    base: PredicateContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {InListContextExt<'a>}

impl<'input> PrestoParserContext<'input> for InListContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for InListContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_inList(self);
    }
}

impl<'input> CustomRuleContext<'input> for InListContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for InListContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for InListContext<'input> {
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for InListContext<'input> {}

impl<'input> InListContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::InListContext(
            BaseParserRuleContext::copy_from(
                ctx,
                InListContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type NullPredicateContext<'input> =
    BaseParserRuleContext<'input, NullPredicateContextExt<'input>>;

pub trait NullPredicateContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token IS
    /// Returns `None` if there is no child corresponding to token IS
    fn IS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
}

impl<'input> NullPredicateContextAttrs<'input> for NullPredicateContext<'input> {}

pub struct NullPredicateContextExt<'input> {
    base: PredicateContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NullPredicateContextExt<'a>}

impl<'input> PrestoParserContext<'input> for NullPredicateContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NullPredicateContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_nullPredicate(self);
    }
}

impl<'input> CustomRuleContext<'input> for NullPredicateContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for NullPredicateContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for NullPredicateContext<'input> {
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for NullPredicateContext<'input> {}

impl<'input> NullPredicateContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::NullPredicateContext(
            BaseParserRuleContext::copy_from(
                ctx,
                NullPredicateContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type BetweenContext<'input> =
    BaseParserRuleContext<'input, BetweenContextExt<'input>>;

pub trait BetweenContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BETWEEN
    /// Returns `None` if there is no child corresponding to token BETWEEN
    fn BETWEEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BETWEEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AND
    /// Returns `None` if there is no child corresponding to token AND
    fn AND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AND, 0)
    }
    fn valueExpression_all(&self) -> Vec<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
}

impl<'input> BetweenContextAttrs<'input> for BetweenContext<'input> {}

pub struct BetweenContextExt<'input> {
    base: PredicateContextExt<'input>,
    pub lower: Option<Rc<ValueExpressionContextAll<'input>>>,
    pub upper: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {BetweenContextExt<'a>}

impl<'input> PrestoParserContext<'input> for BetweenContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for BetweenContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_between(self);
    }
}

impl<'input> CustomRuleContext<'input> for BetweenContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for BetweenContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for BetweenContext<'input> {
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for BetweenContext<'input> {}

impl<'input> BetweenContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::BetweenContext(
            BaseParserRuleContext::copy_from(
                ctx,
                BetweenContextExt {
                    lower: None,
                    upper: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type QuantifiedComparisonContext<'input> =
    BaseParserRuleContext<'input, QuantifiedComparisonContextExt<'input>>;

pub trait QuantifiedComparisonContextAttrs<'input>: PrestoParserContext<'input> {
    fn comparisonOperator(&self) -> Option<Rc<ComparisonOperatorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn comparisonQuantifier(&self) -> Option<Rc<ComparisonQuantifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> QuantifiedComparisonContextAttrs<'input>
    for QuantifiedComparisonContext<'input>
{
}

pub struct QuantifiedComparisonContextExt<'input> {
    base: PredicateContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {QuantifiedComparisonContextExt<'a>}

impl<'input> PrestoParserContext<'input> for QuantifiedComparisonContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QuantifiedComparisonContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_quantifiedComparison(self);
    }
}

impl<'input> CustomRuleContext<'input> for QuantifiedComparisonContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_predicate
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for QuantifiedComparisonContext<'input> {
    fn borrow(&self) -> &PredicateContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PredicateContextExt<'input>>
    for QuantifiedComparisonContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PredicateContextAttrs<'input> for QuantifiedComparisonContext<'input> {}

impl<'input> QuantifiedComparisonContextExt<'input> {
    fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>> {
        Rc::new(PredicateContextAll::QuantifiedComparisonContext(
            BaseParserRuleContext::copy_from(
                ctx,
                QuantifiedComparisonContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn predicate(&mut self) -> Result<Rc<PredicateContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PredicateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 116, RULE_predicate);
        let mut _localctx: Rc<PredicateContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1885);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(245, &mut recog.base)? {
                1 => {
                    let tmp = ComparisonContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule comparisonOperator*/
                        recog.base.set_state(1824);
                        recog.comparisonOperator()?;

                        /*InvokeRule valueExpression*/
                        recog.base.set_state(1825);
                        let tmp = recog.valueExpression_rec(0)?;
                        if let PredicateContextAll::ComparisonContext(ctx) =
                            cast_mut::<_, PredicateContextAll>(&mut _localctx)
                        {
                            ctx.right = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                2 => {
                    let tmp = QuantifiedComparisonContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /*InvokeRule comparisonOperator*/
                        recog.base.set_state(1827);
                        recog.comparisonOperator()?;

                        /*InvokeRule comparisonQuantifier*/
                        recog.base.set_state(1828);
                        recog.comparisonQuantifier()?;

                        recog.base.set_state(1829);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(1830);
                        recog.query()?;

                        recog.base.set_state(1831);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = BetweenContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1834);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == NOT {
                            {
                                recog.base.set_state(1833);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1836);
                        recog.base.match_token(BETWEEN, &mut recog.err_handler)?;

                        /*InvokeRule valueExpression*/
                        recog.base.set_state(1837);
                        let tmp = recog.valueExpression_rec(0)?;
                        if let PredicateContextAll::BetweenContext(ctx) =
                            cast_mut::<_, PredicateContextAll>(&mut _localctx)
                        {
                            ctx.lower = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(1838);
                        recog.base.match_token(AND, &mut recog.err_handler)?;

                        /*InvokeRule valueExpression*/
                        recog.base.set_state(1839);
                        let tmp = recog.valueExpression_rec(0)?;
                        if let PredicateContextAll::BetweenContext(ctx) =
                            cast_mut::<_, PredicateContextAll>(&mut _localctx)
                        {
                            ctx.upper = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                4 => {
                    let tmp = InListContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1842);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == NOT {
                            {
                                recog.base.set_state(1841);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1844);
                        recog.base.match_token(IN, &mut recog.err_handler)?;

                        recog.base.set_state(1845);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(1846);
                        recog.expression()?;

                        recog.base.set_state(1851);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1847);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(1848);
                                    recog.expression()?;
                                }
                            }
                            recog.base.set_state(1853);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1854);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    let tmp = InSubqueryContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1857);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == NOT {
                            {
                                recog.base.set_state(1856);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1859);
                        recog.base.match_token(IN, &mut recog.err_handler)?;

                        recog.base.set_state(1860);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule query*/
                        recog.base.set_state(1861);
                        recog.query()?;

                        recog.base.set_state(1862);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                6 => {
                    let tmp = LikeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1865);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == NOT {
                            {
                                recog.base.set_state(1864);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1867);
                        recog.base.match_token(LIKE, &mut recog.err_handler)?;

                        /*InvokeRule valueExpression*/
                        recog.base.set_state(1868);
                        let tmp = recog.valueExpression_rec(0)?;
                        if let PredicateContextAll::LikeContext(ctx) =
                            cast_mut::<_, PredicateContextAll>(&mut _localctx)
                        {
                            ctx.pattern = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(1871);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(242, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1869);
                                    recog
                                        .base
                                        .match_token(ESCAPE, &mut recog.err_handler)?;

                                    /*InvokeRule valueExpression*/
                                    recog.base.set_state(1870);
                                    let tmp = recog.valueExpression_rec(0)?;
                                    if let PredicateContextAll::LikeContext(ctx) =
                                        cast_mut::<_, PredicateContextAll>(&mut _localctx)
                                    {
                                        ctx.escape = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }
                                }
                            }

                            _ => {}
                        }
                    }
                }
                7 => {
                    let tmp = NullPredicateContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1873);
                        recog.base.match_token(IS, &mut recog.err_handler)?;

                        recog.base.set_state(1875);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == NOT {
                            {
                                recog.base.set_state(1874);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1877);
                        recog.base.match_token(NULL, &mut recog.err_handler)?;
                    }
                }
                8 => {
                    let tmp = DistinctFromContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 8);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1878);
                        recog.base.match_token(IS, &mut recog.err_handler)?;

                        recog.base.set_state(1880);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == NOT {
                            {
                                recog.base.set_state(1879);
                                recog.base.match_token(NOT, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1882);
                        recog.base.match_token(DISTINCT, &mut recog.err_handler)?;

                        recog.base.set_state(1883);
                        recog.base.match_token(FROM, &mut recog.err_handler)?;

                        /*InvokeRule valueExpression*/
                        recog.base.set_state(1884);
                        let tmp = recog.valueExpression_rec(0)?;
                        if let PredicateContextAll::DistinctFromContext(ctx) =
                            cast_mut::<_, PredicateContextAll>(&mut _localctx)
                        {
                            ctx.right = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- valueExpression ----------------
#[derive(Debug)]
pub enum ValueExpressionContextAll<'input> {
    ValueExpressionDefaultContext(ValueExpressionDefaultContext<'input>),
    ConcatenationContext(ConcatenationContext<'input>),
    ArithmeticBinaryContext(ArithmeticBinaryContext<'input>),
    ArithmeticUnaryContext(ArithmeticUnaryContext<'input>),
    AtTimeZoneContext(AtTimeZoneContext<'input>),
    Error(ValueExpressionContext<'input>),
}
antlr_rust::tid! {ValueExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for ValueExpressionContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for ValueExpressionContextAll<'input> {}

impl<'input> Deref for ValueExpressionContextAll<'input> {
    type Target = dyn ValueExpressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use ValueExpressionContextAll::*;
        match self {
            ValueExpressionDefaultContext(inner) => inner,
            ConcatenationContext(inner) => inner,
            ArithmeticBinaryContext(inner) => inner,
            ArithmeticUnaryContext(inner) => inner,
            AtTimeZoneContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ValueExpressionContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type ValueExpressionContext<'input> =
    BaseParserRuleContext<'input, ValueExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ValueExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ValueExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ValueExpressionContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for ValueExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_valueExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}
antlr_rust::tid! {ValueExpressionContextExt<'a>}

impl<'input> ValueExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ValueExpressionContextAll<'input>> {
        Rc::new(ValueExpressionContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                ValueExpressionContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait ValueExpressionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ValueExpressionContextExt<'input>>
{
}

impl<'input> ValueExpressionContextAttrs<'input> for ValueExpressionContext<'input> {}

pub type ValueExpressionDefaultContext<'input> =
    BaseParserRuleContext<'input, ValueExpressionDefaultContextExt<'input>>;

pub trait ValueExpressionDefaultContextAttrs<'input>:
    PrestoParserContext<'input>
{
    fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ValueExpressionDefaultContextAttrs<'input>
    for ValueExpressionDefaultContext<'input>
{
}

pub struct ValueExpressionDefaultContextExt<'input> {
    base: ValueExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ValueExpressionDefaultContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ValueExpressionDefaultContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ValueExpressionDefaultContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_valueExpressionDefault(self);
    }
}

impl<'input> CustomRuleContext<'input> for ValueExpressionDefaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_valueExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>>
    for ValueExpressionDefaultContext<'input>
{
    fn borrow(&self) -> &ValueExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>>
    for ValueExpressionDefaultContext<'input>
{
    fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ValueExpressionContextAttrs<'input>
    for ValueExpressionDefaultContext<'input>
{
}

impl<'input> ValueExpressionDefaultContextExt<'input> {
    fn new(
        ctx: &dyn ValueExpressionContextAttrs<'input>,
    ) -> Rc<ValueExpressionContextAll<'input>> {
        Rc::new(ValueExpressionContextAll::ValueExpressionDefaultContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ValueExpressionDefaultContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ConcatenationContext<'input> =
    BaseParserRuleContext<'input, ConcatenationContextExt<'input>>;

pub trait ConcatenationContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CONCAT
    /// Returns `None` if there is no child corresponding to token CONCAT
    fn CONCAT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CONCAT, 0)
    }
    fn valueExpression_all(&self) -> Vec<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ConcatenationContextAttrs<'input> for ConcatenationContext<'input> {}

pub struct ConcatenationContextExt<'input> {
    base: ValueExpressionContextExt<'input>,
    pub left: Option<Rc<ValueExpressionContextAll<'input>>>,
    pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ConcatenationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ConcatenationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ConcatenationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_concatenation(self);
    }
}

impl<'input> CustomRuleContext<'input> for ConcatenationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_valueExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>> for ConcatenationContext<'input> {
    fn borrow(&self) -> &ValueExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>>
    for ConcatenationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ValueExpressionContextAttrs<'input> for ConcatenationContext<'input> {}

impl<'input> ConcatenationContextExt<'input> {
    fn new(
        ctx: &dyn ValueExpressionContextAttrs<'input>,
    ) -> Rc<ValueExpressionContextAll<'input>> {
        Rc::new(ValueExpressionContextAll::ConcatenationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ConcatenationContextExt {
                    left: None,
                    right: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ArithmeticBinaryContext<'input> =
    BaseParserRuleContext<'input, ArithmeticBinaryContextExt<'input>>;

pub trait ArithmeticBinaryContextAttrs<'input>: PrestoParserContext<'input> {
    fn valueExpression_all(&self) -> Vec<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ASTERISK
    /// Returns `None` if there is no child corresponding to token ASTERISK
    fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ASTERISK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SLASH
    /// Returns `None` if there is no child corresponding to token SLASH
    fn SLASH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SLASH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PERCENT
    /// Returns `None` if there is no child corresponding to token PERCENT
    fn PERCENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PERCENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PLUS
    /// Returns `None` if there is no child corresponding to token PLUS
    fn PLUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PLUS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUS
    /// Returns `None` if there is no child corresponding to token MINUS
    fn MINUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUS, 0)
    }
}

impl<'input> ArithmeticBinaryContextAttrs<'input> for ArithmeticBinaryContext<'input> {}

pub struct ArithmeticBinaryContextExt<'input> {
    base: ValueExpressionContextExt<'input>,
    pub left: Option<Rc<ValueExpressionContextAll<'input>>>,
    pub operator: Option<TokenType<'input>>,
    pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ArithmeticBinaryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ArithmeticBinaryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ArithmeticBinaryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_arithmeticBinary(self);
    }
}

impl<'input> CustomRuleContext<'input> for ArithmeticBinaryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_valueExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>>
    for ArithmeticBinaryContext<'input>
{
    fn borrow(&self) -> &ValueExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>>
    for ArithmeticBinaryContext<'input>
{
    fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ValueExpressionContextAttrs<'input> for ArithmeticBinaryContext<'input> {}

impl<'input> ArithmeticBinaryContextExt<'input> {
    fn new(
        ctx: &dyn ValueExpressionContextAttrs<'input>,
    ) -> Rc<ValueExpressionContextAll<'input>> {
        Rc::new(ValueExpressionContextAll::ArithmeticBinaryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ArithmeticBinaryContextExt {
                    operator: None,
                    left: None,
                    right: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ArithmeticUnaryContext<'input> =
    BaseParserRuleContext<'input, ArithmeticUnaryContextExt<'input>>;

pub trait ArithmeticUnaryContextAttrs<'input>: PrestoParserContext<'input> {
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUS
    /// Returns `None` if there is no child corresponding to token MINUS
    fn MINUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PLUS
    /// Returns `None` if there is no child corresponding to token PLUS
    fn PLUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PLUS, 0)
    }
}

impl<'input> ArithmeticUnaryContextAttrs<'input> for ArithmeticUnaryContext<'input> {}

pub struct ArithmeticUnaryContextExt<'input> {
    base: ValueExpressionContextExt<'input>,
    pub operator: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ArithmeticUnaryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ArithmeticUnaryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ArithmeticUnaryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_arithmeticUnary(self);
    }
}

impl<'input> CustomRuleContext<'input> for ArithmeticUnaryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_valueExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>>
    for ArithmeticUnaryContext<'input>
{
    fn borrow(&self) -> &ValueExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>>
    for ArithmeticUnaryContext<'input>
{
    fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ValueExpressionContextAttrs<'input> for ArithmeticUnaryContext<'input> {}

impl<'input> ArithmeticUnaryContextExt<'input> {
    fn new(
        ctx: &dyn ValueExpressionContextAttrs<'input>,
    ) -> Rc<ValueExpressionContextAll<'input>> {
        Rc::new(ValueExpressionContextAll::ArithmeticUnaryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ArithmeticUnaryContextExt {
                    operator: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type AtTimeZoneContext<'input> =
    BaseParserRuleContext<'input, AtTimeZoneContextExt<'input>>;

pub trait AtTimeZoneContextAttrs<'input>: PrestoParserContext<'input> {
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AT
    /// Returns `None` if there is no child corresponding to token AT
    fn AT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AT, 0)
    }
    fn timeZoneSpecifier(&self) -> Option<Rc<TimeZoneSpecifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AtTimeZoneContextAttrs<'input> for AtTimeZoneContext<'input> {}

pub struct AtTimeZoneContextExt<'input> {
    base: ValueExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AtTimeZoneContextExt<'a>}

impl<'input> PrestoParserContext<'input> for AtTimeZoneContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for AtTimeZoneContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_atTimeZone(self);
    }
}

impl<'input> CustomRuleContext<'input> for AtTimeZoneContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_valueExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>> for AtTimeZoneContext<'input> {
    fn borrow(&self) -> &ValueExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>> for AtTimeZoneContext<'input> {
    fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ValueExpressionContextAttrs<'input> for AtTimeZoneContext<'input> {}

impl<'input> AtTimeZoneContextExt<'input> {
    fn new(
        ctx: &dyn ValueExpressionContextAttrs<'input>,
    ) -> Rc<ValueExpressionContextAll<'input>> {
        Rc::new(ValueExpressionContextAll::AtTimeZoneContext(
            BaseParserRuleContext::copy_from(
                ctx,
                AtTimeZoneContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn valueExpression(
        &mut self,
    ) -> Result<Rc<ValueExpressionContextAll<'input>>, ANTLRError> {
        self.valueExpression_rec(0)
    }

    fn valueExpression_rec(
        &mut self,
        _p: isize,
    ) -> Result<Rc<ValueExpressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx =
            ValueExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_recursion_rule(_localctx.clone(), 118, RULE_valueExpression, _p);
        let mut _localctx: Rc<ValueExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 118;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1891);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(246, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp =
                                ValueExpressionDefaultContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /*InvokeRule primaryExpression*/
                            recog.base.set_state(1888);
                            recog.primaryExpression_rec(0)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = ArithmeticUnaryContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1889);
                            if let ValueExpressionContextAll::ArithmeticUnaryContext(
                                ctx,
                            ) =
                                cast_mut::<_, ValueExpressionContextAll>(&mut _localctx)
                            {
                                ctx.operator = recog.base.input.lt(1).cloned();
                            } else {
                                unreachable!("cant cast");
                            }
                            _la = recog.base.input.la(1);
                            if { !(_la == PLUS || _la == MINUS) } {
                                let tmp =
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                if let ValueExpressionContextAll::ArithmeticUnaryContext(
                                    ctx,
                                ) = cast_mut::<_, ValueExpressionContextAll>(
                                    &mut _localctx,
                                ) {
                                    ctx.operator = Some(&tmp);
                                } else {
                                    unreachable!("cant cast");
                                }
                            } else {
                                if recog.base.input.la(1) == TOKEN_EOF {
                                    recog.base.matched_eof = true
                                };
                                recog.err_handler.report_match(&mut recog.base);
                                recog.base.consume(&mut recog.err_handler);
                            }
                            /*InvokeRule valueExpression*/
                            recog.base.set_state(1890);
                            recog.valueExpression_rec(4)?;
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1907);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(248, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1905);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(247, &mut recog.base)?
                            {
                                1 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = ArithmeticBinaryContextExt::new(
                                            &**ValueExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_valueExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1893);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 3)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1894);
                                        if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.operator = recog.base.input.lt(1).cloned(); } else {unreachable!("cant cast");}
                                        _la = recog.base.input.la(1);
                                        if {
                                            !(((_la - 299) & !0x3f) == 0
                                                && ((1usize << (_la - 299))
                                                    & ((1usize << (ASTERISK - 299))
                                                        | (1usize << (SLASH - 299))
                                                        | (1usize << (PERCENT - 299))))
                                                    != 0)
                                        } {
                                            let tmp = recog
                                                .err_handler
                                                .recover_inline(&mut recog.base)?;
                                            if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
								ctx.operator = Some(&tmp); } else {unreachable!("cant cast");}
                                        } else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog
                                                .err_handler
                                                .report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        /*InvokeRule valueExpression*/
                                        recog.base.set_state(1895);
                                        let tmp = recog.valueExpression_rec(4)?;
                                        if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                    }
                                }
                                2 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = ArithmeticBinaryContextExt::new(
                                            &**ValueExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_valueExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1896);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 2)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1897);
                                        if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.operator = recog.base.input.lt(1).cloned(); } else {unreachable!("cant cast");}
                                        _la = recog.base.input.la(1);
                                        if { !(_la == PLUS || _la == MINUS) } {
                                            let tmp = recog
                                                .err_handler
                                                .recover_inline(&mut recog.base)?;
                                            if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
								ctx.operator = Some(&tmp); } else {unreachable!("cant cast");}
                                        } else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog
                                                .err_handler
                                                .report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        /*InvokeRule valueExpression*/
                                        recog.base.set_state(1898);
                                        let tmp = recog.valueExpression_rec(3)?;
                                        if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                    }
                                }
                                3 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = ConcatenationContextExt::new(
                                            &**ValueExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        if let ValueExpressionContextAll::ConcatenationContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_valueExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1899);
                                        if !({ recog.precpred(None, 1) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 1)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1900);
                                        recog.base.match_token(
                                            CONCAT,
                                            &mut recog.err_handler,
                                        )?;

                                        /*InvokeRule valueExpression*/
                                        recog.base.set_state(1901);
                                        let tmp = recog.valueExpression_rec(2)?;
                                        if let ValueExpressionContextAll::ConcatenationContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                    }
                                }
                                4 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = AtTimeZoneContextExt::new(
                                            &**ValueExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_valueExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(1902);
                                        if !({ recog.precpred(None, 5) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 5)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1903);
                                        recog
                                            .base
                                            .match_token(AT, &mut recog.err_handler)?;

                                        /*InvokeRule timeZoneSpecifier*/
                                        recog.base.set_state(1904);
                                        recog.timeZoneSpecifier()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1909);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(248, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- primaryExpression ----------------
#[derive(Debug)]
pub enum PrimaryExpressionContextAll<'input> {
    DereferenceContext(DereferenceContext<'input>),
    TypeConstructorContext(TypeConstructorContext<'input>),
    JsonValueContext(JsonValueContext<'input>),
    SpecialDateTimeFunctionContext(SpecialDateTimeFunctionContext<'input>),
    SubstringContext(SubstringContext<'input>),
    CastContext(CastContext<'input>),
    LambdaContext(LambdaContext<'input>),
    ParenthesizedExpressionContext(ParenthesizedExpressionContext<'input>),
    TrimContext(TrimContext<'input>),
    ParameterContext(ParameterContext<'input>),
    NormalizeContext(NormalizeContext<'input>),
    JsonObjectContext(JsonObjectContext<'input>),
    IntervalLiteralContext(IntervalLiteralContext<'input>),
    NumericLiteralContext(NumericLiteralContext<'input>),
    BooleanLiteralContext(BooleanLiteralContext<'input>),
    JsonArrayContext(JsonArrayContext<'input>),
    SimpleCaseContext(SimpleCaseContext<'input>),
    ColumnReferenceContext(ColumnReferenceContext<'input>),
    NullLiteralContext(NullLiteralContext<'input>),
    RowConstructorContext(RowConstructorContext<'input>),
    SubscriptContext(SubscriptContext<'input>),
    JsonExistsContext(JsonExistsContext<'input>),
    CurrentPathContext(CurrentPathContext<'input>),
    SubqueryExpressionContext(SubqueryExpressionContext<'input>),
    BinaryLiteralContext(BinaryLiteralContext<'input>),
    CurrentUserContext(CurrentUserContext<'input>),
    JsonQueryContext(JsonQueryContext<'input>),
    MeasureContext(MeasureContext<'input>),
    ExtractContext(ExtractContext<'input>),
    StringLiteralContext(StringLiteralContext<'input>),
    ArrayConstructorContext(ArrayConstructorContext<'input>),
    FunctionCallContext(FunctionCallContext<'input>),
    CurrentSchemaContext(CurrentSchemaContext<'input>),
    ExistsContext(ExistsContext<'input>),
    PositionContext(PositionContext<'input>),
    ListaggContext(ListaggContext<'input>),
    SearchedCaseContext(SearchedCaseContext<'input>),
    CurrentCatalogContext(CurrentCatalogContext<'input>),
    GroupingOperationContext(GroupingOperationContext<'input>),
    Error(PrimaryExpressionContext<'input>),
}
antlr_rust::tid! {PrimaryExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for PrimaryExpressionContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for PrimaryExpressionContextAll<'input> {}

impl<'input> Deref for PrimaryExpressionContextAll<'input> {
    type Target = dyn PrimaryExpressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use PrimaryExpressionContextAll::*;
        match self {
            DereferenceContext(inner) => inner,
            TypeConstructorContext(inner) => inner,
            JsonValueContext(inner) => inner,
            SpecialDateTimeFunctionContext(inner) => inner,
            SubstringContext(inner) => inner,
            CastContext(inner) => inner,
            LambdaContext(inner) => inner,
            ParenthesizedExpressionContext(inner) => inner,
            TrimContext(inner) => inner,
            ParameterContext(inner) => inner,
            NormalizeContext(inner) => inner,
            JsonObjectContext(inner) => inner,
            IntervalLiteralContext(inner) => inner,
            NumericLiteralContext(inner) => inner,
            BooleanLiteralContext(inner) => inner,
            JsonArrayContext(inner) => inner,
            SimpleCaseContext(inner) => inner,
            ColumnReferenceContext(inner) => inner,
            NullLiteralContext(inner) => inner,
            RowConstructorContext(inner) => inner,
            SubscriptContext(inner) => inner,
            JsonExistsContext(inner) => inner,
            CurrentPathContext(inner) => inner,
            SubqueryExpressionContext(inner) => inner,
            BinaryLiteralContext(inner) => inner,
            CurrentUserContext(inner) => inner,
            JsonQueryContext(inner) => inner,
            MeasureContext(inner) => inner,
            ExtractContext(inner) => inner,
            StringLiteralContext(inner) => inner,
            ArrayConstructorContext(inner) => inner,
            FunctionCallContext(inner) => inner,
            CurrentSchemaContext(inner) => inner,
            ExistsContext(inner) => inner,
            PositionContext(inner) => inner,
            ListaggContext(inner) => inner,
            SearchedCaseContext(inner) => inner,
            CurrentCatalogContext(inner) => inner,
            GroupingOperationContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PrimaryExpressionContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type PrimaryExpressionContext<'input> =
    BaseParserRuleContext<'input, PrimaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PrimaryExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PrimaryExpressionContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for PrimaryExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}
antlr_rust::tid! {PrimaryExpressionContextExt<'a>}

impl<'input> PrimaryExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                PrimaryExpressionContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait PrimaryExpressionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PrimaryExpressionContextExt<'input>>
{
}

impl<'input> PrimaryExpressionContextAttrs<'input> for PrimaryExpressionContext<'input> {}

pub type DereferenceContext<'input> =
    BaseParserRuleContext<'input, DereferenceContextExt<'input>>;

pub trait DereferenceContextAttrs<'input>: PrestoParserContext<'input> {
    fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> DereferenceContextAttrs<'input> for DereferenceContext<'input> {}

pub struct DereferenceContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub base_: Option<Rc<PrimaryExpressionContextAll<'input>>>,
    pub fieldName: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DereferenceContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DereferenceContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DereferenceContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dereference(self);
    }
}

impl<'input> CustomRuleContext<'input> for DereferenceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for DereferenceContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for DereferenceContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for DereferenceContext<'input> {}

impl<'input> DereferenceContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::DereferenceContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DereferenceContextExt {
                    base_: None,
                    fieldName: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TypeConstructorContext<'input> =
    BaseParserRuleContext<'input, TypeConstructorContextExt<'input>>;

pub trait TypeConstructorContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token DOUBLE
    /// Returns `None` if there is no child corresponding to token DOUBLE
    fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOUBLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRECISION
    /// Returns `None` if there is no child corresponding to token PRECISION
    fn PRECISION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRECISION, 0)
    }
}

impl<'input> TypeConstructorContextAttrs<'input> for TypeConstructorContext<'input> {}

pub struct TypeConstructorContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TypeConstructorContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TypeConstructorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TypeConstructorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_typeConstructor(self);
    }
}

impl<'input> CustomRuleContext<'input> for TypeConstructorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for TypeConstructorContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for TypeConstructorContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for TypeConstructorContext<'input> {}

impl<'input> TypeConstructorContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::TypeConstructorContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TypeConstructorContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type JsonValueContext<'input> =
    BaseParserRuleContext<'input, JsonValueContextExt<'input>>;

pub trait JsonValueContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token JSON_VALUE
    /// Returns `None` if there is no child corresponding to token JSON_VALUE
    fn JSON_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON_VALUE, 0)
    }
    fn jsonPathInvocation(&self) -> Option<Rc<JsonPathInvocationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token RETURNING
    /// Returns `None` if there is no child corresponding to token RETURNING
    fn RETURNING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURNING, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token ON in current rule
    fn ON_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token ON, starting from 0.
    /// Returns `None` if number of children corresponding to token ON is less or equal than `i`.
    fn ON(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, i)
    }
    /// Retrieves first TerminalNode corresponding to token EMPTY
    /// Returns `None` if there is no child corresponding to token EMPTY
    fn EMPTY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EMPTY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
    fn jsonValueBehavior_all(&self) -> Vec<Rc<JsonValueBehaviorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn jsonValueBehavior(
        &self,
        i: usize,
    ) -> Option<Rc<JsonValueBehaviorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> JsonValueContextAttrs<'input> for JsonValueContext<'input> {}

pub struct JsonValueContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub emptyBehavior: Option<Rc<JsonValueBehaviorContextAll<'input>>>,
    pub errorBehavior: Option<Rc<JsonValueBehaviorContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {JsonValueContextExt<'a>}

impl<'input> PrestoParserContext<'input> for JsonValueContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonValueContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonValue(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonValueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for JsonValueContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for JsonValueContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for JsonValueContext<'input> {}

impl<'input> JsonValueContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::JsonValueContext(
            BaseParserRuleContext::copy_from(
                ctx,
                JsonValueContextExt {
                    emptyBehavior: None,
                    errorBehavior: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SpecialDateTimeFunctionContext<'input> =
    BaseParserRuleContext<'input, SpecialDateTimeFunctionContextExt<'input>>;

pub trait SpecialDateTimeFunctionContextAttrs<'input>:
    PrestoParserContext<'input>
{
    /// Retrieves first TerminalNode corresponding to token CURRENT_DATE
    /// Returns `None` if there is no child corresponding to token CURRENT_DATE
    fn CURRENT_DATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_DATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CURRENT_TIME
    /// Returns `None` if there is no child corresponding to token CURRENT_TIME
    fn CURRENT_TIME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_TIME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
    /// Returns `None` if there is no child corresponding to token INTEGER_VALUE
    fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER_VALUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CURRENT_TIMESTAMP
    /// Returns `None` if there is no child corresponding to token CURRENT_TIMESTAMP
    fn CURRENT_TIMESTAMP(
        &self,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_TIMESTAMP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOCALTIME
    /// Returns `None` if there is no child corresponding to token LOCALTIME
    fn LOCALTIME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOCALTIME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOCALTIMESTAMP
    /// Returns `None` if there is no child corresponding to token LOCALTIMESTAMP
    fn LOCALTIMESTAMP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOCALTIMESTAMP, 0)
    }
}

impl<'input> SpecialDateTimeFunctionContextAttrs<'input>
    for SpecialDateTimeFunctionContext<'input>
{
}

pub struct SpecialDateTimeFunctionContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub name: Option<TokenType<'input>>,
    pub precision: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SpecialDateTimeFunctionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SpecialDateTimeFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SpecialDateTimeFunctionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_specialDateTimeFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for SpecialDateTimeFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for SpecialDateTimeFunctionContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for SpecialDateTimeFunctionContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input>
    for SpecialDateTimeFunctionContext<'input>
{
}

impl<'input> SpecialDateTimeFunctionContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SpecialDateTimeFunctionContextExt {
                    name: None,
                    precision: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SubstringContext<'input> =
    BaseParserRuleContext<'input, SubstringContextExt<'input>>;

pub trait SubstringContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SUBSTRING
    /// Returns `None` if there is no child corresponding to token SUBSTRING
    fn SUBSTRING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SUBSTRING, 0)
    }
    fn valueExpression_all(&self) -> Vec<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOR
    /// Returns `None` if there is no child corresponding to token FOR
    fn FOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOR, 0)
    }
}

impl<'input> SubstringContextAttrs<'input> for SubstringContext<'input> {}

pub struct SubstringContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SubstringContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SubstringContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SubstringContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_substring(self);
    }
}

impl<'input> CustomRuleContext<'input> for SubstringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for SubstringContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for SubstringContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SubstringContext<'input> {}

impl<'input> SubstringContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::SubstringContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SubstringContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CastContext<'input> = BaseParserRuleContext<'input, CastContextExt<'input>>;

pub trait CastContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CAST
    /// Returns `None` if there is no child corresponding to token CAST
    fn CAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CAST, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token TRY_CAST
    /// Returns `None` if there is no child corresponding to token TRY_CAST
    fn TRY_CAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRY_CAST, 0)
    }
}

impl<'input> CastContextAttrs<'input> for CastContext<'input> {}

pub struct CastContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CastContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CastContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for CastContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_cast(self);
    }
}

impl<'input> CustomRuleContext<'input> for CastContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for CastContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for CastContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CastContext<'input> {}

impl<'input> CastContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::CastContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CastContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type LambdaContext<'input> = BaseParserRuleContext<'input, LambdaContextExt<'input>>;

pub trait LambdaContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> LambdaContextAttrs<'input> for LambdaContext<'input> {}

pub struct LambdaContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {LambdaContextExt<'a>}

impl<'input> PrestoParserContext<'input> for LambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for LambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for LambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for LambdaContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for LambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for LambdaContext<'input> {}

impl<'input> LambdaContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::LambdaContext(
            BaseParserRuleContext::copy_from(
                ctx,
                LambdaContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ParenthesizedExpressionContext<'input> =
    BaseParserRuleContext<'input, ParenthesizedExpressionContextExt<'input>>;

pub trait ParenthesizedExpressionContextAttrs<'input>:
    PrestoParserContext<'input>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ParenthesizedExpressionContextAttrs<'input>
    for ParenthesizedExpressionContext<'input>
{
}

pub struct ParenthesizedExpressionContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ParenthesizedExpressionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ParenthesizedExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ParenthesizedExpressionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parenthesizedExpression(self);
    }
}

impl<'input> CustomRuleContext<'input> for ParenthesizedExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for ParenthesizedExpressionContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for ParenthesizedExpressionContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input>
    for ParenthesizedExpressionContext<'input>
{
}

impl<'input> ParenthesizedExpressionContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::ParenthesizedExpressionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ParenthesizedExpressionContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TrimContext<'input> = BaseParserRuleContext<'input, TrimContextExt<'input>>;

pub trait TrimContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TRIM
    /// Returns `None` if there is no child corresponding to token TRIM
    fn TRIM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRIM, 0)
    }
    fn valueExpression_all(&self) -> Vec<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn trimsSpecification(&self) -> Option<Rc<TrimsSpecificationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
}

impl<'input> TrimContextAttrs<'input> for TrimContext<'input> {}

pub struct TrimContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub trimChar: Option<Rc<ValueExpressionContextAll<'input>>>,
    pub trimSource: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TrimContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TrimContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for TrimContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_trim(self);
    }
}

impl<'input> CustomRuleContext<'input> for TrimContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for TrimContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for TrimContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for TrimContext<'input> {}

impl<'input> TrimContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::TrimContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TrimContextExt {
                    trimChar: None,
                    trimSource: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ParameterContext<'input> =
    BaseParserRuleContext<'input, ParameterContextExt<'input>>;

pub trait ParameterContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token QUESTION_MARK
    /// Returns `None` if there is no child corresponding to token QUESTION_MARK
    fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUESTION_MARK, 0)
    }
}

impl<'input> ParameterContextAttrs<'input> for ParameterContext<'input> {}

pub struct ParameterContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ParameterContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ParameterContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ParameterContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter(self);
    }
}

impl<'input> CustomRuleContext<'input> for ParameterContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ParameterContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ParameterContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ParameterContext<'input> {}

impl<'input> ParameterContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::ParameterContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ParameterContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type NormalizeContext<'input> =
    BaseParserRuleContext<'input, NormalizeContextExt<'input>>;

pub trait NormalizeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token NORMALIZE
    /// Returns `None` if there is no child corresponding to token NORMALIZE
    fn NORMALIZE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NORMALIZE, 0)
    }
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
    fn normalForm(&self) -> Option<Rc<NormalFormContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> NormalizeContextAttrs<'input> for NormalizeContext<'input> {}

pub struct NormalizeContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NormalizeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for NormalizeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NormalizeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_normalize(self);
    }
}

impl<'input> CustomRuleContext<'input> for NormalizeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for NormalizeContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for NormalizeContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for NormalizeContext<'input> {}

impl<'input> NormalizeContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::NormalizeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                NormalizeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type JsonObjectContext<'input> =
    BaseParserRuleContext<'input, JsonObjectContextExt<'input>>;

pub trait JsonObjectContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token JSON_OBJECT
    /// Returns `None` if there is no child corresponding to token JSON_OBJECT
    fn JSON_OBJECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON_OBJECT, 0)
    }
    fn jsonObjectMember_all(&self) -> Vec<Rc<JsonObjectMemberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn jsonObjectMember(&self, i: usize) -> Option<Rc<JsonObjectMemberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token RETURNING
    /// Returns `None` if there is no child corresponding to token RETURNING
    fn RETURNING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURNING, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
    fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
    /// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
    fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, i)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ABSENT
    /// Returns `None` if there is no child corresponding to token ABSENT
    fn ABSENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ABSENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNIQUE
    /// Returns `None` if there is no child corresponding to token UNIQUE
    fn UNIQUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNIQUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITHOUT
    /// Returns `None` if there is no child corresponding to token WITHOUT
    fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITHOUT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FORMAT
    /// Returns `None` if there is no child corresponding to token FORMAT
    fn FORMAT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FORMAT, 0)
    }
    fn jsonRepresentation(&self) -> Option<Rc<JsonRepresentationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KEYS
    /// Returns `None` if there is no child corresponding to token KEYS
    fn KEYS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KEYS, 0)
    }
}

impl<'input> JsonObjectContextAttrs<'input> for JsonObjectContext<'input> {}

pub struct JsonObjectContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {JsonObjectContextExt<'a>}

impl<'input> PrestoParserContext<'input> for JsonObjectContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonObjectContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonObject(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonObjectContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for JsonObjectContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for JsonObjectContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for JsonObjectContext<'input> {}

impl<'input> JsonObjectContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::JsonObjectContext(
            BaseParserRuleContext::copy_from(
                ctx,
                JsonObjectContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type IntervalLiteralContext<'input> =
    BaseParserRuleContext<'input, IntervalLiteralContextExt<'input>>;

pub trait IntervalLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    fn interval(&self) -> Option<Rc<IntervalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IntervalLiteralContextAttrs<'input> for IntervalLiteralContext<'input> {}

pub struct IntervalLiteralContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IntervalLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for IntervalLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for IntervalLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_intervalLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for IntervalLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for IntervalLiteralContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for IntervalLiteralContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for IntervalLiteralContext<'input> {}

impl<'input> IntervalLiteralContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::IntervalLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                IntervalLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type NumericLiteralContext<'input> =
    BaseParserRuleContext<'input, NumericLiteralContextExt<'input>>;

pub trait NumericLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> NumericLiteralContextAttrs<'input> for NumericLiteralContext<'input> {}

pub struct NumericLiteralContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NumericLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for NumericLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NumericLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_numericLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for NumericLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for NumericLiteralContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for NumericLiteralContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for NumericLiteralContext<'input> {}

impl<'input> NumericLiteralContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::NumericLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                NumericLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type BooleanLiteralContext<'input> =
    BaseParserRuleContext<'input, BooleanLiteralContextExt<'input>>;

pub trait BooleanLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    fn booleanValue(&self) -> Option<Rc<BooleanValueContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> BooleanLiteralContextAttrs<'input> for BooleanLiteralContext<'input> {}

pub struct BooleanLiteralContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {BooleanLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for BooleanLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BooleanLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_booleanLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for BooleanLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for BooleanLiteralContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for BooleanLiteralContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for BooleanLiteralContext<'input> {}

impl<'input> BooleanLiteralContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::BooleanLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                BooleanLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type JsonArrayContext<'input> =
    BaseParserRuleContext<'input, JsonArrayContextExt<'input>>;

pub trait JsonArrayContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token JSON_ARRAY
    /// Returns `None` if there is no child corresponding to token JSON_ARRAY
    fn JSON_ARRAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON_ARRAY, 0)
    }
    fn jsonValueExpression_all(&self) -> Vec<Rc<JsonValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn jsonValueExpression(
        &self,
        i: usize,
    ) -> Option<Rc<JsonValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token RETURNING
    /// Returns `None` if there is no child corresponding to token RETURNING
    fn RETURNING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURNING, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
    fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
    /// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
    fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, i)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ABSENT
    /// Returns `None` if there is no child corresponding to token ABSENT
    fn ABSENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ABSENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FORMAT
    /// Returns `None` if there is no child corresponding to token FORMAT
    fn FORMAT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FORMAT, 0)
    }
    fn jsonRepresentation(&self) -> Option<Rc<JsonRepresentationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> JsonArrayContextAttrs<'input> for JsonArrayContext<'input> {}

pub struct JsonArrayContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {JsonArrayContextExt<'a>}

impl<'input> PrestoParserContext<'input> for JsonArrayContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonArrayContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonArray(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonArrayContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for JsonArrayContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for JsonArrayContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for JsonArrayContext<'input> {}

impl<'input> JsonArrayContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::JsonArrayContext(
            BaseParserRuleContext::copy_from(
                ctx,
                JsonArrayContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SimpleCaseContext<'input> =
    BaseParserRuleContext<'input, SimpleCaseContextExt<'input>>;

pub trait SimpleCaseContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CASE
    /// Returns `None` if there is no child corresponding to token CASE
    fn CASE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CASE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token END
    /// Returns `None` if there is no child corresponding to token END
    fn END(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(END, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn whenClause_all(&self) -> Vec<Rc<WhenClauseContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn whenClause(&self, i: usize) -> Option<Rc<WhenClauseContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ELSE
    /// Returns `None` if there is no child corresponding to token ELSE
    fn ELSE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ELSE, 0)
    }
}

impl<'input> SimpleCaseContextAttrs<'input> for SimpleCaseContext<'input> {}

pub struct SimpleCaseContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub operand: Option<Rc<ExpressionContextAll<'input>>>,
    pub elseExpression: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SimpleCaseContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SimpleCaseContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SimpleCaseContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_simpleCase(self);
    }
}

impl<'input> CustomRuleContext<'input> for SimpleCaseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for SimpleCaseContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for SimpleCaseContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SimpleCaseContext<'input> {}

impl<'input> SimpleCaseContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::SimpleCaseContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SimpleCaseContextExt {
                    operand: None,
                    elseExpression: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ColumnReferenceContext<'input> =
    BaseParserRuleContext<'input, ColumnReferenceContextExt<'input>>;

pub trait ColumnReferenceContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ColumnReferenceContextAttrs<'input> for ColumnReferenceContext<'input> {}

pub struct ColumnReferenceContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ColumnReferenceContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ColumnReferenceContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ColumnReferenceContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_columnReference(self);
    }
}

impl<'input> CustomRuleContext<'input> for ColumnReferenceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for ColumnReferenceContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for ColumnReferenceContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ColumnReferenceContext<'input> {}

impl<'input> ColumnReferenceContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::ColumnReferenceContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ColumnReferenceContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type NullLiteralContext<'input> =
    BaseParserRuleContext<'input, NullLiteralContextExt<'input>>;

pub trait NullLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
}

impl<'input> NullLiteralContextAttrs<'input> for NullLiteralContext<'input> {}

pub struct NullLiteralContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NullLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for NullLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NullLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_nullLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for NullLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for NullLiteralContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for NullLiteralContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for NullLiteralContext<'input> {}

impl<'input> NullLiteralContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::NullLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                NullLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RowConstructorContext<'input> =
    BaseParserRuleContext<'input, RowConstructorContextExt<'input>>;

pub trait RowConstructorContextAttrs<'input>: PrestoParserContext<'input> {
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token ROW
    /// Returns `None` if there is no child corresponding to token ROW
    fn ROW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROW, 0)
    }
}

impl<'input> RowConstructorContextAttrs<'input> for RowConstructorContext<'input> {}

pub struct RowConstructorContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RowConstructorContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RowConstructorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RowConstructorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rowConstructor(self);
    }
}

impl<'input> CustomRuleContext<'input> for RowConstructorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for RowConstructorContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for RowConstructorContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for RowConstructorContext<'input> {}

impl<'input> RowConstructorContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::RowConstructorContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RowConstructorContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SubscriptContext<'input> =
    BaseParserRuleContext<'input, SubscriptContextExt<'input>>;

pub trait SubscriptContextAttrs<'input>: PrestoParserContext<'input> {
    fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SubscriptContextAttrs<'input> for SubscriptContext<'input> {}

pub struct SubscriptContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub value: Option<Rc<PrimaryExpressionContextAll<'input>>>,
    pub index: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SubscriptContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SubscriptContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SubscriptContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_subscript(self);
    }
}

impl<'input> CustomRuleContext<'input> for SubscriptContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for SubscriptContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for SubscriptContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SubscriptContext<'input> {}

impl<'input> SubscriptContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::SubscriptContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SubscriptContextExt {
                    value: None,
                    index: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type JsonExistsContext<'input> =
    BaseParserRuleContext<'input, JsonExistsContextExt<'input>>;

pub trait JsonExistsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token JSON_EXISTS
    /// Returns `None` if there is no child corresponding to token JSON_EXISTS
    fn JSON_EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON_EXISTS, 0)
    }
    fn jsonPathInvocation(&self) -> Option<Rc<JsonPathInvocationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn jsonExistsErrorBehavior(
        &self,
    ) -> Option<Rc<JsonExistsErrorBehaviorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
}

impl<'input> JsonExistsContextAttrs<'input> for JsonExistsContext<'input> {}

pub struct JsonExistsContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {JsonExistsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for JsonExistsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonExistsContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonExists(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonExistsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for JsonExistsContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for JsonExistsContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for JsonExistsContext<'input> {}

impl<'input> JsonExistsContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::JsonExistsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                JsonExistsContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CurrentPathContext<'input> =
    BaseParserRuleContext<'input, CurrentPathContextExt<'input>>;

pub trait CurrentPathContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CURRENT_PATH
    /// Returns `None` if there is no child corresponding to token CURRENT_PATH
    fn CURRENT_PATH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_PATH, 0)
    }
}

impl<'input> CurrentPathContextAttrs<'input> for CurrentPathContext<'input> {}

pub struct CurrentPathContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub name: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CurrentPathContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CurrentPathContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CurrentPathContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_currentPath(self);
    }
}

impl<'input> CustomRuleContext<'input> for CurrentPathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for CurrentPathContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for CurrentPathContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CurrentPathContext<'input> {}

impl<'input> CurrentPathContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::CurrentPathContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CurrentPathContextExt {
                    name: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SubqueryExpressionContext<'input> =
    BaseParserRuleContext<'input, SubqueryExpressionContextExt<'input>>;

pub trait SubqueryExpressionContextAttrs<'input>: PrestoParserContext<'input> {
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SubqueryExpressionContextAttrs<'input>
    for SubqueryExpressionContext<'input>
{
}

pub struct SubqueryExpressionContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SubqueryExpressionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SubqueryExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SubqueryExpressionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_subqueryExpression(self);
    }
}

impl<'input> CustomRuleContext<'input> for SubqueryExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for SubqueryExpressionContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for SubqueryExpressionContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SubqueryExpressionContext<'input> {}

impl<'input> SubqueryExpressionContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::SubqueryExpressionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SubqueryExpressionContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type BinaryLiteralContext<'input> =
    BaseParserRuleContext<'input, BinaryLiteralContextExt<'input>>;

pub trait BinaryLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BINARY_LITERAL
    /// Returns `None` if there is no child corresponding to token BINARY_LITERAL
    fn BINARY_LITERAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BINARY_LITERAL, 0)
    }
}

impl<'input> BinaryLiteralContextAttrs<'input> for BinaryLiteralContext<'input> {}

pub struct BinaryLiteralContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {BinaryLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for BinaryLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BinaryLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_binaryLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for BinaryLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for BinaryLiteralContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for BinaryLiteralContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for BinaryLiteralContext<'input> {}

impl<'input> BinaryLiteralContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::BinaryLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                BinaryLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CurrentUserContext<'input> =
    BaseParserRuleContext<'input, CurrentUserContextExt<'input>>;

pub trait CurrentUserContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CURRENT_USER
    /// Returns `None` if there is no child corresponding to token CURRENT_USER
    fn CURRENT_USER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_USER, 0)
    }
}

impl<'input> CurrentUserContextAttrs<'input> for CurrentUserContext<'input> {}

pub struct CurrentUserContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub name: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CurrentUserContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CurrentUserContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CurrentUserContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_currentUser(self);
    }
}

impl<'input> CustomRuleContext<'input> for CurrentUserContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for CurrentUserContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for CurrentUserContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CurrentUserContext<'input> {}

impl<'input> CurrentUserContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::CurrentUserContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CurrentUserContextExt {
                    name: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type JsonQueryContext<'input> =
    BaseParserRuleContext<'input, JsonQueryContextExt<'input>>;

pub trait JsonQueryContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token JSON_QUERY
    /// Returns `None` if there is no child corresponding to token JSON_QUERY
    fn JSON_QUERY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON_QUERY, 0)
    }
    fn jsonPathInvocation(&self) -> Option<Rc<JsonPathInvocationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token RETURNING
    /// Returns `None` if there is no child corresponding to token RETURNING
    fn RETURNING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURNING, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn jsonQueryWrapperBehavior(
        &self,
    ) -> Option<Rc<JsonQueryWrapperBehaviorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WRAPPER
    /// Returns `None` if there is no child corresponding to token WRAPPER
    fn WRAPPER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WRAPPER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token QUOTES
    /// Returns `None` if there is no child corresponding to token QUOTES
    fn QUOTES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUOTES, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token ON in current rule
    fn ON_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token ON, starting from 0.
    /// Returns `None` if number of children corresponding to token ON is less or equal than `i`.
    fn ON(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, i)
    }
    /// Retrieves first TerminalNode corresponding to token EMPTY
    /// Returns `None` if there is no child corresponding to token EMPTY
    fn EMPTY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EMPTY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KEEP
    /// Returns `None` if there is no child corresponding to token KEEP
    fn KEEP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KEEP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OMIT
    /// Returns `None` if there is no child corresponding to token OMIT
    fn OMIT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OMIT, 0)
    }
    fn jsonQueryBehavior_all(&self) -> Vec<Rc<JsonQueryBehaviorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn jsonQueryBehavior(
        &self,
        i: usize,
    ) -> Option<Rc<JsonQueryBehaviorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token FORMAT
    /// Returns `None` if there is no child corresponding to token FORMAT
    fn FORMAT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FORMAT, 0)
    }
    fn jsonRepresentation(&self) -> Option<Rc<JsonRepresentationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SCALAR
    /// Returns `None` if there is no child corresponding to token SCALAR
    fn SCALAR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCALAR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TEXT_STRING
    /// Returns `None` if there is no child corresponding to token TEXT_STRING
    fn TEXT_STRING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TEXT_STRING, 0)
    }
}

impl<'input> JsonQueryContextAttrs<'input> for JsonQueryContext<'input> {}

pub struct JsonQueryContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub emptyBehavior: Option<Rc<JsonQueryBehaviorContextAll<'input>>>,
    pub errorBehavior: Option<Rc<JsonQueryBehaviorContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {JsonQueryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for JsonQueryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonQueryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonQuery(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonQueryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for JsonQueryContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for JsonQueryContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for JsonQueryContext<'input> {}

impl<'input> JsonQueryContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::JsonQueryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                JsonQueryContextExt {
                    emptyBehavior: None,
                    errorBehavior: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type MeasureContext<'input> =
    BaseParserRuleContext<'input, MeasureContextExt<'input>>;

pub trait MeasureContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn over(&self) -> Option<Rc<OverContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MeasureContextAttrs<'input> for MeasureContext<'input> {}

pub struct MeasureContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MeasureContextExt<'a>}

impl<'input> PrestoParserContext<'input> for MeasureContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for MeasureContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_measure(self);
    }
}

impl<'input> CustomRuleContext<'input> for MeasureContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for MeasureContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for MeasureContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for MeasureContext<'input> {}

impl<'input> MeasureContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::MeasureContext(
            BaseParserRuleContext::copy_from(
                ctx,
                MeasureContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ExtractContext<'input> =
    BaseParserRuleContext<'input, ExtractContextExt<'input>>;

pub trait ExtractContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token EXTRACT
    /// Returns `None` if there is no child corresponding to token EXTRACT
    fn EXTRACT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXTRACT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FROM
    /// Returns `None` if there is no child corresponding to token FROM
    fn FROM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FROM, 0)
    }
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ExtractContextAttrs<'input> for ExtractContext<'input> {}

pub struct ExtractContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExtractContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExtractContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for ExtractContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_extract(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExtractContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ExtractContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ExtractContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ExtractContext<'input> {}

impl<'input> ExtractContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::ExtractContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExtractContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type StringLiteralContext<'input> =
    BaseParserRuleContext<'input, StringLiteralContextExt<'input>>;

pub trait StringLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> StringLiteralContextAttrs<'input> for StringLiteralContext<'input> {}

pub struct StringLiteralContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {StringLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for StringLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StringLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_stringLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for StringLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for StringLiteralContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for StringLiteralContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for StringLiteralContext<'input> {}

impl<'input> StringLiteralContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::StringLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                StringLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ArrayConstructorContext<'input> =
    BaseParserRuleContext<'input, ArrayConstructorContextExt<'input>>;

pub trait ArrayConstructorContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ARRAY
    /// Returns `None` if there is no child corresponding to token ARRAY
    fn ARRAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ARRAY, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> ArrayConstructorContextAttrs<'input> for ArrayConstructorContext<'input> {}

pub struct ArrayConstructorContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ArrayConstructorContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ArrayConstructorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ArrayConstructorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_arrayConstructor(self);
    }
}

impl<'input> CustomRuleContext<'input> for ArrayConstructorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for ArrayConstructorContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for ArrayConstructorContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ArrayConstructorContext<'input> {}

impl<'input> ArrayConstructorContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::ArrayConstructorContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ArrayConstructorContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type FunctionCallContext<'input> =
    BaseParserRuleContext<'input, FunctionCallContextExt<'input>>;

pub trait FunctionCallContextAttrs<'input>: PrestoParserContext<'input> {
    fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token ASTERISK
    /// Returns `None` if there is no child corresponding to token ASTERISK
    fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ASTERISK, 0)
    }
    fn processingMode(&self) -> Option<Rc<ProcessingModeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn filter(&self) -> Option<Rc<FilterContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn over(&self) -> Option<Rc<OverContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ORDER
    /// Returns `None` if there is no child corresponding to token ORDER
    fn ORDER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BY
    /// Returns `None` if there is no child corresponding to token BY
    fn BY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, 0)
    }
    fn sortItem_all(&self) -> Vec<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn nullTreatment(&self) -> Option<Rc<NullTreatmentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> FunctionCallContextAttrs<'input> for FunctionCallContext<'input> {}

pub struct FunctionCallContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub label: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {FunctionCallContextExt<'a>}

impl<'input> PrestoParserContext<'input> for FunctionCallContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for FunctionCallContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_functionCall(self);
    }
}

impl<'input> CustomRuleContext<'input> for FunctionCallContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for FunctionCallContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for FunctionCallContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for FunctionCallContext<'input> {}

impl<'input> FunctionCallContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::FunctionCallContext(
            BaseParserRuleContext::copy_from(
                ctx,
                FunctionCallContextExt {
                    label: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CurrentSchemaContext<'input> =
    BaseParserRuleContext<'input, CurrentSchemaContextExt<'input>>;

pub trait CurrentSchemaContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CURRENT_SCHEMA
    /// Returns `None` if there is no child corresponding to token CURRENT_SCHEMA
    fn CURRENT_SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_SCHEMA, 0)
    }
}

impl<'input> CurrentSchemaContextAttrs<'input> for CurrentSchemaContext<'input> {}

pub struct CurrentSchemaContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub name: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CurrentSchemaContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CurrentSchemaContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CurrentSchemaContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_currentSchema(self);
    }
}

impl<'input> CustomRuleContext<'input> for CurrentSchemaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for CurrentSchemaContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for CurrentSchemaContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CurrentSchemaContext<'input> {}

impl<'input> CurrentSchemaContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::CurrentSchemaContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CurrentSchemaContextExt {
                    name: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ExistsContext<'input> = BaseParserRuleContext<'input, ExistsContextExt<'input>>;

pub trait ExistsContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token EXISTS
    /// Returns `None` if there is no child corresponding to token EXISTS
    fn EXISTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXISTS, 0)
    }
    fn query(&self) -> Option<Rc<QueryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ExistsContextAttrs<'input> for ExistsContext<'input> {}

pub struct ExistsContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExistsContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExistsContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for ExistsContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_exists(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExistsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ExistsContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ExistsContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ExistsContext<'input> {}

impl<'input> ExistsContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::ExistsContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExistsContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PositionContext<'input> =
    BaseParserRuleContext<'input, PositionContextExt<'input>>;

pub trait PositionContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token POSITION
    /// Returns `None` if there is no child corresponding to token POSITION
    fn POSITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(POSITION, 0)
    }
    fn valueExpression_all(&self) -> Vec<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token IN
    /// Returns `None` if there is no child corresponding to token IN
    fn IN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IN, 0)
    }
}

impl<'input> PositionContextAttrs<'input> for PositionContext<'input> {}

pub struct PositionContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PositionContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PositionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for PositionContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_position(self);
    }
}

impl<'input> CustomRuleContext<'input> for PositionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for PositionContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for PositionContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for PositionContext<'input> {}

impl<'input> PositionContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::PositionContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PositionContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ListaggContext<'input> =
    BaseParserRuleContext<'input, ListaggContextExt<'input>>;

pub trait ListaggContextAttrs<'input>: PrestoParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token LISTAGG
    /// Returns `None` if there is no child corresponding to token LISTAGG
    fn LISTAGG(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LISTAGG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITHIN
    /// Returns `None` if there is no child corresponding to token WITHIN
    fn WITHIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITHIN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GROUP
    /// Returns `None` if there is no child corresponding to token GROUP
    fn GROUP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GROUP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ORDER
    /// Returns `None` if there is no child corresponding to token ORDER
    fn ORDER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BY
    /// Returns `None` if there is no child corresponding to token BY
    fn BY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BY, 0)
    }
    fn sortItem_all(&self) -> Vec<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token ON
    /// Returns `None` if there is no child corresponding to token ON
    fn ON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OVERFLOW
    /// Returns `None` if there is no child corresponding to token OVERFLOW
    fn OVERFLOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OVERFLOW, 0)
    }
    fn listAggOverflowBehavior(
        &self,
    ) -> Option<Rc<ListAggOverflowBehaviorContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ListaggContextAttrs<'input> for ListaggContext<'input> {}

pub struct ListaggContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub name: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ListaggContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ListaggContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for ListaggContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_listagg(self);
    }
}

impl<'input> CustomRuleContext<'input> for ListaggContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ListaggContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ListaggContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ListaggContext<'input> {}

impl<'input> ListaggContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::ListaggContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ListaggContextExt {
                    name: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SearchedCaseContext<'input> =
    BaseParserRuleContext<'input, SearchedCaseContextExt<'input>>;

pub trait SearchedCaseContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CASE
    /// Returns `None` if there is no child corresponding to token CASE
    fn CASE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CASE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token END
    /// Returns `None` if there is no child corresponding to token END
    fn END(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(END, 0)
    }
    fn whenClause_all(&self) -> Vec<Rc<WhenClauseContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn whenClause(&self, i: usize) -> Option<Rc<WhenClauseContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ELSE
    /// Returns `None` if there is no child corresponding to token ELSE
    fn ELSE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ELSE, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SearchedCaseContextAttrs<'input> for SearchedCaseContext<'input> {}

pub struct SearchedCaseContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub elseExpression: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SearchedCaseContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SearchedCaseContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SearchedCaseContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_searchedCase(self);
    }
}

impl<'input> CustomRuleContext<'input> for SearchedCaseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for SearchedCaseContext<'input> {
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for SearchedCaseContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SearchedCaseContext<'input> {}

impl<'input> SearchedCaseContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::SearchedCaseContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SearchedCaseContextExt {
                    elseExpression: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CurrentCatalogContext<'input> =
    BaseParserRuleContext<'input, CurrentCatalogContextExt<'input>>;

pub trait CurrentCatalogContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CURRENT_CATALOG
    /// Returns `None` if there is no child corresponding to token CURRENT_CATALOG
    fn CURRENT_CATALOG(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_CATALOG, 0)
    }
}

impl<'input> CurrentCatalogContextAttrs<'input> for CurrentCatalogContext<'input> {}

pub struct CurrentCatalogContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    pub name: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CurrentCatalogContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CurrentCatalogContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CurrentCatalogContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_currentCatalog(self);
    }
}

impl<'input> CustomRuleContext<'input> for CurrentCatalogContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for CurrentCatalogContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for CurrentCatalogContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CurrentCatalogContext<'input> {}

impl<'input> CurrentCatalogContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::CurrentCatalogContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CurrentCatalogContextExt {
                    name: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type GroupingOperationContext<'input> =
    BaseParserRuleContext<'input, GroupingOperationContextExt<'input>>;

pub trait GroupingOperationContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token GROUPING
    /// Returns `None` if there is no child corresponding to token GROUPING
    fn GROUPING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GROUPING, 0)
    }
    fn qualifiedName_all(&self) -> Vec<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> GroupingOperationContextAttrs<'input> for GroupingOperationContext<'input> {}

pub struct GroupingOperationContextExt<'input> {
    base: PrimaryExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {GroupingOperationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for GroupingOperationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GroupingOperationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_groupingOperation(self);
    }
}

impl<'input> CustomRuleContext<'input> for GroupingOperationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_primaryExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>>
    for GroupingOperationContext<'input>
{
    fn borrow(&self) -> &PrimaryExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>>
    for GroupingOperationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for GroupingOperationContext<'input> {}

impl<'input> GroupingOperationContextExt<'input> {
    fn new(
        ctx: &dyn PrimaryExpressionContextAttrs<'input>,
    ) -> Rc<PrimaryExpressionContextAll<'input>> {
        Rc::new(PrimaryExpressionContextAll::GroupingOperationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                GroupingOperationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn primaryExpression(
        &mut self,
    ) -> Result<Rc<PrimaryExpressionContextAll<'input>>, ANTLRError> {
        self.primaryExpression_rec(0)
    }

    fn primaryExpression_rec(
        &mut self,
        _p: isize,
    ) -> Result<Rc<PrimaryExpressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx =
            PrimaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(
            _localctx.clone(),
            120,
            RULE_primaryExpression,
            _p,
        );
        let mut _localctx: Rc<PrimaryExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 120;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2360);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(311, &mut recog.base)? {
                    1 => {
                        let mut tmp = NullLiteralContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();

                        recog.base.set_state(1911);
                        recog.base.match_token(NULL, &mut recog.err_handler)?;
                    }
                    2 => {
                        {
                            let mut tmp = IntervalLiteralContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule interval*/
                            recog.base.set_state(1912);
                            recog.interval()?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = TypeConstructorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule identifier*/
                            recog.base.set_state(1913);
                            recog.identifier()?;

                            /*InvokeRule string*/
                            recog.base.set_state(1914);
                            recog.string()?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = TypeConstructorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1916);
                            recog.base.match_token(DOUBLE, &mut recog.err_handler)?;

                            recog.base.set_state(1917);
                            recog.base.match_token(PRECISION, &mut recog.err_handler)?;

                            /*InvokeRule string*/
                            recog.base.set_state(1918);
                            recog.string()?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = NumericLiteralContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule number*/
                            recog.base.set_state(1919);
                            recog.number()?;
                        }
                    }
                    6 => {
                        {
                            let mut tmp = BooleanLiteralContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule booleanValue*/
                            recog.base.set_state(1920);
                            recog.booleanValue()?;
                        }
                    }
                    7 => {
                        {
                            let mut tmp = StringLiteralContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule string*/
                            recog.base.set_state(1921);
                            recog.string()?;
                        }
                    }
                    8 => {
                        let mut tmp = BinaryLiteralContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(1922);
                        recog
                            .base
                            .match_token(BINARY_LITERAL, &mut recog.err_handler)?;
                    }
                    9 => {
                        let mut tmp = ParameterContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(1923);
                        recog
                            .base
                            .match_token(QUESTION_MARK, &mut recog.err_handler)?;
                    }
                    10 => {
                        {
                            let mut tmp = PositionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1924);
                            recog.base.match_token(POSITION, &mut recog.err_handler)?;

                            recog.base.set_state(1925);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(1926);
                            recog.valueExpression_rec(0)?;

                            recog.base.set_state(1927);
                            recog.base.match_token(IN, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(1928);
                            recog.valueExpression_rec(0)?;

                            recog.base.set_state(1929);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    11 => {
                        {
                            let mut tmp = RowConstructorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1931);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(1932);
                            recog.expression()?;

                            recog.base.set_state(1935);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            loop {
                                {
                                    {
                                        recog.base.set_state(1933);
                                        recog
                                            .base
                                            .match_token(COMMA, &mut recog.err_handler)?;

                                        /*InvokeRule expression*/
                                        recog.base.set_state(1934);
                                        recog.expression()?;
                                    }
                                }
                                recog.base.set_state(1937);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if !(_la == COMMA) {
                                    break;
                                }
                            }
                            recog.base.set_state(1939);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    12 => {
                        {
                            let mut tmp = RowConstructorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1941);
                            recog.base.match_token(ROW, &mut recog.err_handler)?;

                            recog.base.set_state(1942);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(1943);
                            recog.expression()?;

                            recog.base.set_state(1948);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            while _la == COMMA {
                                {
                                    {
                                        recog.base.set_state(1944);
                                        recog
                                            .base
                                            .match_token(COMMA, &mut recog.err_handler)?;

                                        /*InvokeRule expression*/
                                        recog.base.set_state(1945);
                                        recog.expression()?;
                                    }
                                }
                                recog.base.set_state(1950);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                            }
                            recog.base.set_state(1951);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    13 => {
                        {
                            let mut tmp = ListaggContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1953);
                            let tmp = recog
                                .base
                                .match_token(LISTAGG, &mut recog.err_handler)?;
                            if let PrimaryExpressionContextAll::ListaggContext(ctx) =
                                cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                            {
                                ctx.name = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(1954);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(1956);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(251, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule setQuantifier*/
                                        recog.base.set_state(1955);
                                        recog.setQuantifier()?;
                                    }
                                }

                                _ => {}
                            }
                            /*InvokeRule expression*/
                            recog.base.set_state(1958);
                            recog.expression()?;

                            recog.base.set_state(1961);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == COMMA {
                                {
                                    recog.base.set_state(1959);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule string*/
                                    recog.base.set_state(1960);
                                    recog.string()?;
                                }
                            }

                            recog.base.set_state(1966);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == ON {
                                {
                                    recog.base.set_state(1963);
                                    recog.base.match_token(ON, &mut recog.err_handler)?;

                                    recog.base.set_state(1964);
                                    recog
                                        .base
                                        .match_token(OVERFLOW, &mut recog.err_handler)?;

                                    /*InvokeRule listAggOverflowBehavior*/
                                    recog.base.set_state(1965);
                                    recog.listAggOverflowBehavior()?;
                                }
                            }

                            recog.base.set_state(1968);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;

                            {
                                recog.base.set_state(1969);
                                recog.base.match_token(WITHIN, &mut recog.err_handler)?;

                                recog.base.set_state(1970);
                                recog.base.match_token(GROUP, &mut recog.err_handler)?;

                                recog.base.set_state(1971);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                recog.base.set_state(1972);
                                recog.base.match_token(ORDER, &mut recog.err_handler)?;

                                recog.base.set_state(1973);
                                recog.base.match_token(BY, &mut recog.err_handler)?;

                                /*InvokeRule sortItem*/
                                recog.base.set_state(1974);
                                recog.sortItem()?;

                                recog.base.set_state(1979);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(1975);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule sortItem*/
                                            recog.base.set_state(1976);
                                            recog.sortItem()?;
                                        }
                                    }
                                    recog.base.set_state(1981);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                                recog.base.set_state(1982);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }
                        }
                    }
                    14 => {
                        {
                            let mut tmp = FunctionCallContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1985);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(255, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule processingMode*/
                                        recog.base.set_state(1984);
                                        recog.processingMode()?;
                                    }
                                }

                                _ => {}
                            }
                            /*InvokeRule qualifiedName*/
                            recog.base.set_state(1987);
                            recog.qualifiedName()?;

                            recog.base.set_state(1988);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(1992);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if (((_la) & !0x3f) == 0
                                && ((1usize << _la)
                                    & ((1usize << ABSENT)
                                        | (1usize << ADD)
                                        | (1usize << ADMIN)
                                        | (1usize << AFTER)
                                        | (1usize << ALL)
                                        | (1usize << ANALYZE)
                                        | (1usize << ANY)
                                        | (1usize << ARRAY)
                                        | (1usize << ASC)
                                        | (1usize << AT)
                                        | (1usize << AUTHORIZATION)
                                        | (1usize << BERNOULLI)))
                                    != 0)
                                || (((_la - 33) & !0x3f) == 0
                                    && ((1usize << (_la - 33))
                                        & ((1usize << (BOTH - 33))
                                            | (1usize << (CALL - 33))
                                            | (1usize << (CASCADE - 33))
                                            | (1usize << (CATALOGS - 33))
                                            | (1usize << (COLUMN - 33))
                                            | (1usize << (COLUMNS - 33))
                                            | (1usize << (COMMENT - 33))
                                            | (1usize << (COMMIT - 33))
                                            | (1usize << (COMMITTED - 33))
                                            | (1usize << (CONDITIONAL - 33))
                                            | (1usize << (COUNT - 33))
                                            | (1usize << (COPARTITION - 33))
                                            | (1usize << (CURRENT - 33))
                                            | (1usize << (DATA - 33))
                                            | (1usize << (DATE - 33))
                                            | (1usize << (DAY - 33))))
                                        != 0)
                                || (((_la - 66) & !0x3f) == 0
                                    && ((1usize << (_la - 66))
                                        & ((1usize << (DEFAULT - 66))
                                            | (1usize << (DEFINE - 66))
                                            | (1usize << (DEFINER - 66))
                                            | (1usize << (DENY - 66))
                                            | (1usize << (DESC - 66))
                                            | (1usize << (DESCRIPTOR - 66))
                                            | (1usize << (DISTRIBUTED - 66))
                                            | (1usize << (DOUBLE - 66))
                                            | (1usize << (EMPTY - 66))
                                            | (1usize << (ENCODING - 66))
                                            | (1usize << (ERROR - 66))
                                            | (1usize << (EXCLUDING - 66))
                                            | (1usize << (EXPLAIN - 66))
                                            | (1usize << (FETCH - 66))
                                            | (1usize << (FILTER - 66))
                                            | (1usize << (FINAL - 66))
                                            | (1usize << (FIRST - 66))
                                            | (1usize << (FOLLOWING - 66))
                                            | (1usize << (FORMAT - 66))))
                                        != 0)
                                || (((_la - 100) & !0x3f) == 0
                                    && ((1usize << (_la - 100))
                                        & ((1usize << (FUNCTIONS - 100))
                                            | (1usize << (GRACE - 100))
                                            | (1usize << (GRANT - 100))
                                            | (1usize << (GRANTED - 100))
                                            | (1usize << (GRANTS - 100))
                                            | (1usize << (GRAPHVIZ - 100))
                                            | (1usize << (GROUPS - 100))
                                            | (1usize << (HOUR - 100))
                                            | (1usize << (IF - 100))
                                            | (1usize << (IGNORE - 100))
                                            | (1usize << (INCLUDING - 100))
                                            | (1usize << (INITIAL - 100))
                                            | (1usize << (INPUT - 100))
                                            | (1usize << (INTERVAL - 100))
                                            | (1usize << (INVOKER - 100))
                                            | (1usize << (IO - 100))
                                            | (1usize << (ISOLATION - 100))
                                            | (1usize << (JSON - 100))))
                                        != 0)
                                || (((_la - 133) & !0x3f) == 0
                                    && ((1usize << (_la - 133))
                                        & ((1usize << (KEEP - 133))
                                            | (1usize << (KEY - 133))
                                            | (1usize << (KEYS - 133))
                                            | (1usize << (LAST - 133))
                                            | (1usize << (LATERAL - 133))
                                            | (1usize << (LEADING - 133))
                                            | (1usize << (LEVEL - 133))
                                            | (1usize << (LIMIT - 133))
                                            | (1usize << (LOCAL - 133))
                                            | (1usize << (LOGICAL - 133))
                                            | (1usize << (MAP - 133))
                                            | (1usize << (MATCH - 133))
                                            | (1usize << (MATCHED - 133))
                                            | (1usize << (MATCHES - 133))
                                            | (1usize << (MATCH_RECOGNIZE - 133))
                                            | (1usize << (MATERIALIZED - 133))
                                            | (1usize << (MEASURES - 133))
                                            | (1usize << (MERGE - 133))
                                            | (1usize << (MINUTE - 133))
                                            | (1usize << (MONTH - 133))
                                            | (1usize << (NEXT - 133))
                                            | (1usize << (NFC - 133))
                                            | (1usize << (NFD - 133))
                                            | (1usize << (NFKC - 133))
                                            | (1usize << (NFKD - 133))
                                            | (1usize << (NO - 133))))
                                        != 0)
                                || (((_la - 165) & !0x3f) == 0
                                    && ((1usize << (_la - 165))
                                        & ((1usize << (NONE - 165))
                                            | (1usize << (NULLIF - 165))
                                            | (1usize << (NULLS - 165))
                                            | (1usize << (OBJECT - 165))
                                            | (1usize << (OF - 165))
                                            | (1usize << (OFFSET - 165))
                                            | (1usize << (OMIT - 165))
                                            | (1usize << (ONE - 165))
                                            | (1usize << (ONLY - 165))
                                            | (1usize << (OPTION - 165))
                                            | (1usize << (ORDINALITY - 165))
                                            | (1usize << (OUTPUT - 165))
                                            | (1usize << (OVER - 165))
                                            | (1usize << (OVERFLOW - 165))
                                            | (1usize << (PARTITION - 165))
                                            | (1usize << (PARTITIONS - 165))
                                            | (1usize << (PASSING - 165))
                                            | (1usize << (PAST - 165))
                                            | (1usize << (PATH - 165))
                                            | (1usize << (PATTERN - 165))
                                            | (1usize << (PER - 165))
                                            | (1usize << (PERIOD - 165))
                                            | (1usize << (PERMUTE - 165))
                                            | (1usize << (POSITION - 165))
                                            | (1usize << (PRECEDING - 165))))
                                        != 0)
                                || (((_la - 197) & !0x3f) == 0
                                    && ((1usize << (_la - 197))
                                        & ((1usize << (PRECISION - 197))
                                            | (1usize << (PRIVILEGES - 197))
                                            | (1usize << (PROPERTIES - 197))
                                            | (1usize << (PRUNE - 197))
                                            | (1usize << (QUOTES - 197))
                                            | (1usize << (RANGE - 197))
                                            | (1usize << (READ - 197))
                                            | (1usize << (REFRESH - 197))
                                            | (1usize << (RENAME - 197))
                                            | (1usize << (REPEATABLE - 197))
                                            | (1usize << (REPLACE - 197))
                                            | (1usize << (RESET - 197))
                                            | (1usize << (RESPECT - 197))
                                            | (1usize << (RESTRICT - 197))
                                            | (1usize << (RETURNING - 197))
                                            | (1usize << (REVOKE - 197))
                                            | (1usize << (ROLE - 197))
                                            | (1usize << (ROLES - 197))
                                            | (1usize << (ROLLBACK - 197))
                                            | (1usize << (ROW - 197))
                                            | (1usize << (ROWS - 197))
                                            | (1usize << (RUNNING - 197))
                                            | (1usize << (SCALAR - 197))
                                            | (1usize << (SCHEMA - 197))
                                            | (1usize << (SCHEMAS - 197))
                                            | (1usize << (SECOND - 197))
                                            | (1usize << (SECURITY - 197))
                                            | (1usize << (SEEK - 197))))
                                        != 0)
                                || (((_la - 230) & !0x3f) == 0
                                    && ((1usize << (_la - 230))
                                        & ((1usize << (SERIALIZABLE - 230))
                                            | (1usize << (SESSION - 230))
                                            | (1usize << (SET - 230))
                                            | (1usize << (SETS - 230))
                                            | (1usize << (SHOW - 230))
                                            | (1usize << (SOME - 230))
                                            | (1usize << (START - 230))
                                            | (1usize << (STATS - 230))
                                            | (1usize << (SUBSET - 230))
                                            | (1usize << (SUBSTRING - 230))
                                            | (1usize << (SYSTEM - 230))
                                            | (1usize << (TABLES - 230))
                                            | (1usize << (TABLESAMPLE - 230))
                                            | (1usize << (TEXT - 230))
                                            | (1usize << (TEXT_STRING - 230))
                                            | (1usize << (TIES - 230))
                                            | (1usize << (TIME - 230))
                                            | (1usize << (TIMESTAMP - 230))
                                            | (1usize << (TO - 230))
                                            | (1usize << (TRAILING - 230))
                                            | (1usize << (TRANSACTION - 230))
                                            | (1usize << (TRUNCATE - 230))
                                            | (1usize << (TRY_CAST - 230))
                                            | (1usize << (TYPE - 230))
                                            | (1usize << (UNBOUNDED - 230))
                                            | (1usize << (UNCOMMITTED - 230))
                                            | (1usize << (UNCONDITIONAL - 230))))
                                        != 0)
                                || (((_la - 263) & !0x3f) == 0
                                    && ((1usize << (_la - 263))
                                        & ((1usize << (UNIQUE - 263))
                                            | (1usize << (UNKNOWN - 263))
                                            | (1usize << (UNMATCHED - 263))
                                            | (1usize << (UPDATE - 263))
                                            | (1usize << (USE - 263))
                                            | (1usize << (USER - 263))
                                            | (1usize << (UTF16 - 263))
                                            | (1usize << (UTF32 - 263))
                                            | (1usize << (UTF8 - 263))
                                            | (1usize << (VALIDATE - 263))
                                            | (1usize << (VALUE - 263))
                                            | (1usize << (VERBOSE - 263))
                                            | (1usize << (VERSION - 263))
                                            | (1usize << (VIEW - 263))
                                            | (1usize << (WINDOW - 263))
                                            | (1usize << (WITHIN - 263))
                                            | (1usize << (WITHOUT - 263))
                                            | (1usize << (WORK - 263))
                                            | (1usize << (WRAPPER - 263))
                                            | (1usize << (WRITE - 263))
                                            | (1usize << (YEAR - 263))
                                            | (1usize << (ZONE - 263))))
                                        != 0)
                                || (((_la - 310) & !0x3f) == 0
                                    && ((1usize << (_la - 310))
                                        & ((1usize << (IDENTIFIER - 310))
                                            | (1usize << (DIGIT_IDENTIFIER - 310))
                                            | (1usize << (QUOTED_IDENTIFIER - 310))
                                            | (1usize << (BACKQUOTED_IDENTIFIER - 310))))
                                        != 0)
                            {
                                {
                                    /*InvokeRule identifier*/
                                    recog.base.set_state(1989);
                                    let tmp = recog.identifier()?;
                                    if let PrimaryExpressionContextAll::FunctionCallContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.label = Some(tmp.clone()); } else {unreachable!("cant cast");}

                                    recog.base.set_state(1990);
                                    recog
                                        .base
                                        .match_token(T__0, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(1994);
                            recog.base.match_token(ASTERISK, &mut recog.err_handler)?;

                            recog.base.set_state(1995);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;

                            recog.base.set_state(1997);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(257, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule filter*/
                                        recog.base.set_state(1996);
                                        recog.filter()?;
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2000);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(258, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule over*/
                                        recog.base.set_state(1999);
                                        recog.over()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    15 => {
                        {
                            let mut tmp = FunctionCallContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2003);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(259, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule processingMode*/
                                        recog.base.set_state(2002);
                                        recog.processingMode()?;
                                    }
                                }

                                _ => {}
                            }
                            /*InvokeRule qualifiedName*/
                            recog.base.set_state(2005);
                            recog.qualifiedName()?;

                            recog.base.set_state(2006);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(2018);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if (((_la) & !0x3f) == 0
                                && ((1usize << _la)
                                    & ((1usize << T__1)
                                        | (1usize << ABSENT)
                                        | (1usize << ADD)
                                        | (1usize << ADMIN)
                                        | (1usize << AFTER)
                                        | (1usize << ALL)
                                        | (1usize << ANALYZE)
                                        | (1usize << ANY)
                                        | (1usize << ARRAY)
                                        | (1usize << ASC)
                                        | (1usize << AT)
                                        | (1usize << AUTHORIZATION)
                                        | (1usize << BERNOULLI)))
                                    != 0)
                                || (((_la - 33) & !0x3f) == 0
                                    && ((1usize << (_la - 33))
                                        & ((1usize << (BOTH - 33))
                                            | (1usize << (CALL - 33))
                                            | (1usize << (CASCADE - 33))
                                            | (1usize << (CASE - 33))
                                            | (1usize << (CAST - 33))
                                            | (1usize << (CATALOGS - 33))
                                            | (1usize << (COLUMN - 33))
                                            | (1usize << (COLUMNS - 33))
                                            | (1usize << (COMMENT - 33))
                                            | (1usize << (COMMIT - 33))
                                            | (1usize << (COMMITTED - 33))
                                            | (1usize << (CONDITIONAL - 33))
                                            | (1usize << (COUNT - 33))
                                            | (1usize << (COPARTITION - 33))
                                            | (1usize << (CURRENT - 33))
                                            | (1usize << (CURRENT_CATALOG - 33))
                                            | (1usize << (CURRENT_DATE - 33))
                                            | (1usize << (CURRENT_PATH - 33))
                                            | (1usize << (CURRENT_SCHEMA - 33))
                                            | (1usize << (CURRENT_TIME - 33))
                                            | (1usize << (CURRENT_TIMESTAMP - 33))
                                            | (1usize << (CURRENT_USER - 33))
                                            | (1usize << (DATA - 33))
                                            | (1usize << (DATE - 33))
                                            | (1usize << (DAY - 33))))
                                        != 0)
                                || (((_la - 66) & !0x3f) == 0
                                    && ((1usize << (_la - 66))
                                        & ((1usize << (DEFAULT - 66))
                                            | (1usize << (DEFINE - 66))
                                            | (1usize << (DEFINER - 66))
                                            | (1usize << (DENY - 66))
                                            | (1usize << (DESC - 66))
                                            | (1usize << (DESCRIPTOR - 66))
                                            | (1usize << (DISTINCT - 66))
                                            | (1usize << (DISTRIBUTED - 66))
                                            | (1usize << (DOUBLE - 66))
                                            | (1usize << (EMPTY - 66))
                                            | (1usize << (ENCODING - 66))
                                            | (1usize << (ERROR - 66))
                                            | (1usize << (EXCLUDING - 66))
                                            | (1usize << (EXISTS - 66))
                                            | (1usize << (EXPLAIN - 66))
                                            | (1usize << (EXTRACT - 66))
                                            | (1usize << (FALSE - 66))
                                            | (1usize << (FETCH - 66))
                                            | (1usize << (FILTER - 66))
                                            | (1usize << (FINAL - 66))
                                            | (1usize << (FIRST - 66))
                                            | (1usize << (FOLLOWING - 66))
                                            | (1usize << (FORMAT - 66))))
                                        != 0)
                                || (((_la - 100) & !0x3f) == 0
                                    && ((1usize << (_la - 100))
                                        & ((1usize << (FUNCTIONS - 100))
                                            | (1usize << (GRACE - 100))
                                            | (1usize << (GRANT - 100))
                                            | (1usize << (GRANTED - 100))
                                            | (1usize << (GRANTS - 100))
                                            | (1usize << (GRAPHVIZ - 100))
                                            | (1usize << (GROUPING - 100))
                                            | (1usize << (GROUPS - 100))
                                            | (1usize << (HOUR - 100))
                                            | (1usize << (IF - 100))
                                            | (1usize << (IGNORE - 100))
                                            | (1usize << (INCLUDING - 100))
                                            | (1usize << (INITIAL - 100))
                                            | (1usize << (INPUT - 100))
                                            | (1usize << (INTERVAL - 100))
                                            | (1usize << (INVOKER - 100))
                                            | (1usize << (IO - 100))
                                            | (1usize << (ISOLATION - 100))
                                            | (1usize << (JSON - 100))
                                            | (1usize << (JSON_ARRAY - 100))
                                            | (1usize << (JSON_EXISTS - 100))
                                            | (1usize << (JSON_OBJECT - 100))
                                            | (1usize << (JSON_QUERY - 100))))
                                        != 0)
                                || (((_la - 132) & !0x3f) == 0
                                    && ((1usize << (_la - 132))
                                        & ((1usize << (JSON_VALUE - 132))
                                            | (1usize << (KEEP - 132))
                                            | (1usize << (KEY - 132))
                                            | (1usize << (KEYS - 132))
                                            | (1usize << (LAST - 132))
                                            | (1usize << (LATERAL - 132))
                                            | (1usize << (LEADING - 132))
                                            | (1usize << (LEVEL - 132))
                                            | (1usize << (LIMIT - 132))
                                            | (1usize << (LISTAGG - 132))
                                            | (1usize << (LOCAL - 132))
                                            | (1usize << (LOCALTIME - 132))
                                            | (1usize << (LOCALTIMESTAMP - 132))
                                            | (1usize << (LOGICAL - 132))
                                            | (1usize << (MAP - 132))
                                            | (1usize << (MATCH - 132))
                                            | (1usize << (MATCHED - 132))
                                            | (1usize << (MATCHES - 132))
                                            | (1usize << (MATCH_RECOGNIZE - 132))
                                            | (1usize << (MATERIALIZED - 132))
                                            | (1usize << (MEASURES - 132))
                                            | (1usize << (MERGE - 132))
                                            | (1usize << (MINUTE - 132))
                                            | (1usize << (MONTH - 132))
                                            | (1usize << (NEXT - 132))
                                            | (1usize << (NFC - 132))
                                            | (1usize << (NFD - 132))
                                            | (1usize << (NFKC - 132))
                                            | (1usize << (NFKD - 132))))
                                        != 0)
                                || (((_la - 164) & !0x3f) == 0
                                    && ((1usize << (_la - 164))
                                        & ((1usize << (NO - 164))
                                            | (1usize << (NONE - 164))
                                            | (1usize << (NORMALIZE - 164))
                                            | (1usize << (NOT - 164))
                                            | (1usize << (NULL - 164))
                                            | (1usize << (NULLIF - 164))
                                            | (1usize << (NULLS - 164))
                                            | (1usize << (OBJECT - 164))
                                            | (1usize << (OF - 164))
                                            | (1usize << (OFFSET - 164))
                                            | (1usize << (OMIT - 164))
                                            | (1usize << (ONE - 164))
                                            | (1usize << (ONLY - 164))
                                            | (1usize << (OPTION - 164))
                                            | (1usize << (ORDINALITY - 164))
                                            | (1usize << (OUTPUT - 164))
                                            | (1usize << (OVER - 164))
                                            | (1usize << (OVERFLOW - 164))
                                            | (1usize << (PARTITION - 164))
                                            | (1usize << (PARTITIONS - 164))
                                            | (1usize << (PASSING - 164))
                                            | (1usize << (PAST - 164))
                                            | (1usize << (PATH - 164))
                                            | (1usize << (PATTERN - 164))
                                            | (1usize << (PER - 164))
                                            | (1usize << (PERIOD - 164))
                                            | (1usize << (PERMUTE - 164))
                                            | (1usize << (POSITION - 164))))
                                        != 0)
                                || (((_la - 196) & !0x3f) == 0
                                    && ((1usize << (_la - 196))
                                        & ((1usize << (PRECEDING - 196))
                                            | (1usize << (PRECISION - 196))
                                            | (1usize << (PRIVILEGES - 196))
                                            | (1usize << (PROPERTIES - 196))
                                            | (1usize << (PRUNE - 196))
                                            | (1usize << (QUOTES - 196))
                                            | (1usize << (RANGE - 196))
                                            | (1usize << (READ - 196))
                                            | (1usize << (REFRESH - 196))
                                            | (1usize << (RENAME - 196))
                                            | (1usize << (REPEATABLE - 196))
                                            | (1usize << (REPLACE - 196))
                                            | (1usize << (RESET - 196))
                                            | (1usize << (RESPECT - 196))
                                            | (1usize << (RESTRICT - 196))
                                            | (1usize << (RETURNING - 196))
                                            | (1usize << (REVOKE - 196))
                                            | (1usize << (ROLE - 196))
                                            | (1usize << (ROLES - 196))
                                            | (1usize << (ROLLBACK - 196))
                                            | (1usize << (ROW - 196))
                                            | (1usize << (ROWS - 196))
                                            | (1usize << (RUNNING - 196))
                                            | (1usize << (SCALAR - 196))
                                            | (1usize << (SCHEMA - 196))
                                            | (1usize << (SCHEMAS - 196))
                                            | (1usize << (SECOND - 196))
                                            | (1usize << (SECURITY - 196))))
                                        != 0)
                                || (((_la - 228) & !0x3f) == 0
                                    && ((1usize << (_la - 228))
                                        & ((1usize << (SEEK - 228))
                                            | (1usize << (SERIALIZABLE - 228))
                                            | (1usize << (SESSION - 228))
                                            | (1usize << (SET - 228))
                                            | (1usize << (SETS - 228))
                                            | (1usize << (SHOW - 228))
                                            | (1usize << (SOME - 228))
                                            | (1usize << (START - 228))
                                            | (1usize << (STATS - 228))
                                            | (1usize << (SUBSET - 228))
                                            | (1usize << (SUBSTRING - 228))
                                            | (1usize << (SYSTEM - 228))
                                            | (1usize << (TABLES - 228))
                                            | (1usize << (TABLESAMPLE - 228))
                                            | (1usize << (TEXT - 228))
                                            | (1usize << (TEXT_STRING - 228))
                                            | (1usize << (TIES - 228))
                                            | (1usize << (TIME - 228))
                                            | (1usize << (TIMESTAMP - 228))
                                            | (1usize << (TO - 228))
                                            | (1usize << (TRAILING - 228))
                                            | (1usize << (TRANSACTION - 228))
                                            | (1usize << (TRIM - 228))
                                            | (1usize << (TRUE - 228))
                                            | (1usize << (TRUNCATE - 228))
                                            | (1usize << (TRY_CAST - 228))
                                            | (1usize << (TYPE - 228))
                                            | (1usize << (UNBOUNDED - 228))))
                                        != 0)
                                || (((_la - 260) & !0x3f) == 0
                                    && ((1usize << (_la - 260))
                                        & ((1usize << (UNCOMMITTED - 260))
                                            | (1usize << (UNCONDITIONAL - 260))
                                            | (1usize << (UNIQUE - 260))
                                            | (1usize << (UNKNOWN - 260))
                                            | (1usize << (UNMATCHED - 260))
                                            | (1usize << (UPDATE - 260))
                                            | (1usize << (USE - 260))
                                            | (1usize << (USER - 260))
                                            | (1usize << (UTF16 - 260))
                                            | (1usize << (UTF32 - 260))
                                            | (1usize << (UTF8 - 260))
                                            | (1usize << (VALIDATE - 260))
                                            | (1usize << (VALUE - 260))
                                            | (1usize << (VERBOSE - 260))
                                            | (1usize << (VERSION - 260))
                                            | (1usize << (VIEW - 260))
                                            | (1usize << (WINDOW - 260))
                                            | (1usize << (WITHIN - 260))
                                            | (1usize << (WITHOUT - 260))
                                            | (1usize << (WORK - 260))
                                            | (1usize << (WRAPPER - 260))
                                            | (1usize << (WRITE - 260))
                                            | (1usize << (YEAR - 260))
                                            | (1usize << (ZONE - 260))))
                                        != 0)
                                || (((_la - 297) & !0x3f) == 0
                                    && ((1usize << (_la - 297))
                                        & ((1usize << (PLUS - 297))
                                            | (1usize << (MINUS - 297))
                                            | (1usize << (QUESTION_MARK - 297))
                                            | (1usize << (STRING - 297))
                                            | (1usize << (UNICODE_STRING - 297))
                                            | (1usize << (BINARY_LITERAL - 297))
                                            | (1usize << (INTEGER_VALUE - 297))
                                            | (1usize << (DECIMAL_VALUE - 297))
                                            | (1usize << (DOUBLE_VALUE - 297))
                                            | (1usize << (IDENTIFIER - 297))
                                            | (1usize << (DIGIT_IDENTIFIER - 297))
                                            | (1usize << (QUOTED_IDENTIFIER - 297))
                                            | (1usize << (BACKQUOTED_IDENTIFIER - 297))))
                                        != 0)
                            {
                                {
                                    recog.base.set_state(2008);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    match recog
                                        .interpreter
                                        .adaptive_predict(260, &mut recog.base)?
                                    {
                                        x if x == 1 => {
                                            {
                                                /*InvokeRule setQuantifier*/
                                                recog.base.set_state(2007);
                                                recog.setQuantifier()?;
                                            }
                                        }

                                        _ => {}
                                    }
                                    /*InvokeRule expression*/
                                    recog.base.set_state(2010);
                                    recog.expression()?;

                                    recog.base.set_state(2015);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(2011);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule expression*/
                                                recog.base.set_state(2012);
                                                recog.expression()?;
                                            }
                                        }
                                        recog.base.set_state(2017);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(2030);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == ORDER {
                                {
                                    recog.base.set_state(2020);
                                    recog
                                        .base
                                        .match_token(ORDER, &mut recog.err_handler)?;

                                    recog.base.set_state(2021);
                                    recog.base.match_token(BY, &mut recog.err_handler)?;

                                    /*InvokeRule sortItem*/
                                    recog.base.set_state(2022);
                                    recog.sortItem()?;

                                    recog.base.set_state(2027);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(2023);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule sortItem*/
                                                recog.base.set_state(2024);
                                                recog.sortItem()?;
                                            }
                                        }
                                        recog.base.set_state(2029);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(2032);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;

                            recog.base.set_state(2034);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(265, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule filter*/
                                        recog.base.set_state(2033);
                                        recog.filter()?;
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2040);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(267, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(2037);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == IGNORE || _la == RESPECT {
                                            {
                                                /*InvokeRule nullTreatment*/
                                                recog.base.set_state(2036);
                                                recog.nullTreatment()?;
                                            }
                                        }

                                        /*InvokeRule over*/
                                        recog.base.set_state(2039);
                                        recog.over()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    16 => {
                        {
                            let mut tmp = MeasureContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule identifier*/
                            recog.base.set_state(2042);
                            recog.identifier()?;

                            /*InvokeRule over*/
                            recog.base.set_state(2043);
                            recog.over()?;
                        }
                    }
                    17 => {
                        {
                            let mut tmp = LambdaContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule identifier*/
                            recog.base.set_state(2045);
                            recog.identifier()?;

                            recog.base.set_state(2046);
                            recog.base.match_token(T__5, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(2047);
                            recog.expression()?;
                        }
                    }
                    18 => {
                        {
                            let mut tmp = LambdaContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2049);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(2058);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if (((_la) & !0x3f) == 0
                                && ((1usize << _la)
                                    & ((1usize << ABSENT)
                                        | (1usize << ADD)
                                        | (1usize << ADMIN)
                                        | (1usize << AFTER)
                                        | (1usize << ALL)
                                        | (1usize << ANALYZE)
                                        | (1usize << ANY)
                                        | (1usize << ARRAY)
                                        | (1usize << ASC)
                                        | (1usize << AT)
                                        | (1usize << AUTHORIZATION)
                                        | (1usize << BERNOULLI)))
                                    != 0)
                                || (((_la - 33) & !0x3f) == 0
                                    && ((1usize << (_la - 33))
                                        & ((1usize << (BOTH - 33))
                                            | (1usize << (CALL - 33))
                                            | (1usize << (CASCADE - 33))
                                            | (1usize << (CATALOGS - 33))
                                            | (1usize << (COLUMN - 33))
                                            | (1usize << (COLUMNS - 33))
                                            | (1usize << (COMMENT - 33))
                                            | (1usize << (COMMIT - 33))
                                            | (1usize << (COMMITTED - 33))
                                            | (1usize << (CONDITIONAL - 33))
                                            | (1usize << (COUNT - 33))
                                            | (1usize << (COPARTITION - 33))
                                            | (1usize << (CURRENT - 33))
                                            | (1usize << (DATA - 33))
                                            | (1usize << (DATE - 33))
                                            | (1usize << (DAY - 33))))
                                        != 0)
                                || (((_la - 66) & !0x3f) == 0
                                    && ((1usize << (_la - 66))
                                        & ((1usize << (DEFAULT - 66))
                                            | (1usize << (DEFINE - 66))
                                            | (1usize << (DEFINER - 66))
                                            | (1usize << (DENY - 66))
                                            | (1usize << (DESC - 66))
                                            | (1usize << (DESCRIPTOR - 66))
                                            | (1usize << (DISTRIBUTED - 66))
                                            | (1usize << (DOUBLE - 66))
                                            | (1usize << (EMPTY - 66))
                                            | (1usize << (ENCODING - 66))
                                            | (1usize << (ERROR - 66))
                                            | (1usize << (EXCLUDING - 66))
                                            | (1usize << (EXPLAIN - 66))
                                            | (1usize << (FETCH - 66))
                                            | (1usize << (FILTER - 66))
                                            | (1usize << (FINAL - 66))
                                            | (1usize << (FIRST - 66))
                                            | (1usize << (FOLLOWING - 66))
                                            | (1usize << (FORMAT - 66))))
                                        != 0)
                                || (((_la - 100) & !0x3f) == 0
                                    && ((1usize << (_la - 100))
                                        & ((1usize << (FUNCTIONS - 100))
                                            | (1usize << (GRACE - 100))
                                            | (1usize << (GRANT - 100))
                                            | (1usize << (GRANTED - 100))
                                            | (1usize << (GRANTS - 100))
                                            | (1usize << (GRAPHVIZ - 100))
                                            | (1usize << (GROUPS - 100))
                                            | (1usize << (HOUR - 100))
                                            | (1usize << (IF - 100))
                                            | (1usize << (IGNORE - 100))
                                            | (1usize << (INCLUDING - 100))
                                            | (1usize << (INITIAL - 100))
                                            | (1usize << (INPUT - 100))
                                            | (1usize << (INTERVAL - 100))
                                            | (1usize << (INVOKER - 100))
                                            | (1usize << (IO - 100))
                                            | (1usize << (ISOLATION - 100))
                                            | (1usize << (JSON - 100))))
                                        != 0)
                                || (((_la - 133) & !0x3f) == 0
                                    && ((1usize << (_la - 133))
                                        & ((1usize << (KEEP - 133))
                                            | (1usize << (KEY - 133))
                                            | (1usize << (KEYS - 133))
                                            | (1usize << (LAST - 133))
                                            | (1usize << (LATERAL - 133))
                                            | (1usize << (LEADING - 133))
                                            | (1usize << (LEVEL - 133))
                                            | (1usize << (LIMIT - 133))
                                            | (1usize << (LOCAL - 133))
                                            | (1usize << (LOGICAL - 133))
                                            | (1usize << (MAP - 133))
                                            | (1usize << (MATCH - 133))
                                            | (1usize << (MATCHED - 133))
                                            | (1usize << (MATCHES - 133))
                                            | (1usize << (MATCH_RECOGNIZE - 133))
                                            | (1usize << (MATERIALIZED - 133))
                                            | (1usize << (MEASURES - 133))
                                            | (1usize << (MERGE - 133))
                                            | (1usize << (MINUTE - 133))
                                            | (1usize << (MONTH - 133))
                                            | (1usize << (NEXT - 133))
                                            | (1usize << (NFC - 133))
                                            | (1usize << (NFD - 133))
                                            | (1usize << (NFKC - 133))
                                            | (1usize << (NFKD - 133))
                                            | (1usize << (NO - 133))))
                                        != 0)
                                || (((_la - 165) & !0x3f) == 0
                                    && ((1usize << (_la - 165))
                                        & ((1usize << (NONE - 165))
                                            | (1usize << (NULLIF - 165))
                                            | (1usize << (NULLS - 165))
                                            | (1usize << (OBJECT - 165))
                                            | (1usize << (OF - 165))
                                            | (1usize << (OFFSET - 165))
                                            | (1usize << (OMIT - 165))
                                            | (1usize << (ONE - 165))
                                            | (1usize << (ONLY - 165))
                                            | (1usize << (OPTION - 165))
                                            | (1usize << (ORDINALITY - 165))
                                            | (1usize << (OUTPUT - 165))
                                            | (1usize << (OVER - 165))
                                            | (1usize << (OVERFLOW - 165))
                                            | (1usize << (PARTITION - 165))
                                            | (1usize << (PARTITIONS - 165))
                                            | (1usize << (PASSING - 165))
                                            | (1usize << (PAST - 165))
                                            | (1usize << (PATH - 165))
                                            | (1usize << (PATTERN - 165))
                                            | (1usize << (PER - 165))
                                            | (1usize << (PERIOD - 165))
                                            | (1usize << (PERMUTE - 165))
                                            | (1usize << (POSITION - 165))
                                            | (1usize << (PRECEDING - 165))))
                                        != 0)
                                || (((_la - 197) & !0x3f) == 0
                                    && ((1usize << (_la - 197))
                                        & ((1usize << (PRECISION - 197))
                                            | (1usize << (PRIVILEGES - 197))
                                            | (1usize << (PROPERTIES - 197))
                                            | (1usize << (PRUNE - 197))
                                            | (1usize << (QUOTES - 197))
                                            | (1usize << (RANGE - 197))
                                            | (1usize << (READ - 197))
                                            | (1usize << (REFRESH - 197))
                                            | (1usize << (RENAME - 197))
                                            | (1usize << (REPEATABLE - 197))
                                            | (1usize << (REPLACE - 197))
                                            | (1usize << (RESET - 197))
                                            | (1usize << (RESPECT - 197))
                                            | (1usize << (RESTRICT - 197))
                                            | (1usize << (RETURNING - 197))
                                            | (1usize << (REVOKE - 197))
                                            | (1usize << (ROLE - 197))
                                            | (1usize << (ROLES - 197))
                                            | (1usize << (ROLLBACK - 197))
                                            | (1usize << (ROW - 197))
                                            | (1usize << (ROWS - 197))
                                            | (1usize << (RUNNING - 197))
                                            | (1usize << (SCALAR - 197))
                                            | (1usize << (SCHEMA - 197))
                                            | (1usize << (SCHEMAS - 197))
                                            | (1usize << (SECOND - 197))
                                            | (1usize << (SECURITY - 197))
                                            | (1usize << (SEEK - 197))))
                                        != 0)
                                || (((_la - 230) & !0x3f) == 0
                                    && ((1usize << (_la - 230))
                                        & ((1usize << (SERIALIZABLE - 230))
                                            | (1usize << (SESSION - 230))
                                            | (1usize << (SET - 230))
                                            | (1usize << (SETS - 230))
                                            | (1usize << (SHOW - 230))
                                            | (1usize << (SOME - 230))
                                            | (1usize << (START - 230))
                                            | (1usize << (STATS - 230))
                                            | (1usize << (SUBSET - 230))
                                            | (1usize << (SUBSTRING - 230))
                                            | (1usize << (SYSTEM - 230))
                                            | (1usize << (TABLES - 230))
                                            | (1usize << (TABLESAMPLE - 230))
                                            | (1usize << (TEXT - 230))
                                            | (1usize << (TEXT_STRING - 230))
                                            | (1usize << (TIES - 230))
                                            | (1usize << (TIME - 230))
                                            | (1usize << (TIMESTAMP - 230))
                                            | (1usize << (TO - 230))
                                            | (1usize << (TRAILING - 230))
                                            | (1usize << (TRANSACTION - 230))
                                            | (1usize << (TRUNCATE - 230))
                                            | (1usize << (TRY_CAST - 230))
                                            | (1usize << (TYPE - 230))
                                            | (1usize << (UNBOUNDED - 230))
                                            | (1usize << (UNCOMMITTED - 230))
                                            | (1usize << (UNCONDITIONAL - 230))))
                                        != 0)
                                || (((_la - 263) & !0x3f) == 0
                                    && ((1usize << (_la - 263))
                                        & ((1usize << (UNIQUE - 263))
                                            | (1usize << (UNKNOWN - 263))
                                            | (1usize << (UNMATCHED - 263))
                                            | (1usize << (UPDATE - 263))
                                            | (1usize << (USE - 263))
                                            | (1usize << (USER - 263))
                                            | (1usize << (UTF16 - 263))
                                            | (1usize << (UTF32 - 263))
                                            | (1usize << (UTF8 - 263))
                                            | (1usize << (VALIDATE - 263))
                                            | (1usize << (VALUE - 263))
                                            | (1usize << (VERBOSE - 263))
                                            | (1usize << (VERSION - 263))
                                            | (1usize << (VIEW - 263))
                                            | (1usize << (WINDOW - 263))
                                            | (1usize << (WITHIN - 263))
                                            | (1usize << (WITHOUT - 263))
                                            | (1usize << (WORK - 263))
                                            | (1usize << (WRAPPER - 263))
                                            | (1usize << (WRITE - 263))
                                            | (1usize << (YEAR - 263))
                                            | (1usize << (ZONE - 263))))
                                        != 0)
                                || (((_la - 310) & !0x3f) == 0
                                    && ((1usize << (_la - 310))
                                        & ((1usize << (IDENTIFIER - 310))
                                            | (1usize << (DIGIT_IDENTIFIER - 310))
                                            | (1usize << (QUOTED_IDENTIFIER - 310))
                                            | (1usize << (BACKQUOTED_IDENTIFIER - 310))))
                                        != 0)
                            {
                                {
                                    /*InvokeRule identifier*/
                                    recog.base.set_state(2050);
                                    recog.identifier()?;

                                    recog.base.set_state(2055);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(2051);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule identifier*/
                                                recog.base.set_state(2052);
                                                recog.identifier()?;
                                            }
                                        }
                                        recog.base.set_state(2057);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(2060);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;

                            recog.base.set_state(2061);
                            recog.base.match_token(T__5, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(2062);
                            recog.expression()?;
                        }
                    }
                    19 => {
                        {
                            let mut tmp = SubqueryExpressionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2063);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule query*/
                            recog.base.set_state(2064);
                            recog.query()?;

                            recog.base.set_state(2065);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    20 => {
                        {
                            let mut tmp = ExistsContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2067);
                            recog.base.match_token(EXISTS, &mut recog.err_handler)?;

                            recog.base.set_state(2068);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule query*/
                            recog.base.set_state(2069);
                            recog.query()?;

                            recog.base.set_state(2070);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    21 => {
                        {
                            let mut tmp = SimpleCaseContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2072);
                            recog.base.match_token(CASE, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(2073);
                            let tmp = recog.expression()?;
                            if let PrimaryExpressionContextAll::SimpleCaseContext(ctx) =
                                cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                            {
                                ctx.operand = Some(tmp.clone());
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2075);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            loop {
                                {
                                    {
                                        /*InvokeRule whenClause*/
                                        recog.base.set_state(2074);
                                        recog.whenClause()?;
                                    }
                                }
                                recog.base.set_state(2077);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if !(_la == WHEN) {
                                    break;
                                }
                            }
                            recog.base.set_state(2081);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == ELSE {
                                {
                                    recog.base.set_state(2079);
                                    recog
                                        .base
                                        .match_token(ELSE, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(2080);
                                    let tmp = recog.expression()?;
                                    if let PrimaryExpressionContextAll::SimpleCaseContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.elseExpression = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                }
                            }

                            recog.base.set_state(2083);
                            recog.base.match_token(END, &mut recog.err_handler)?;
                        }
                    }
                    22 => {
                        {
                            let mut tmp = SearchedCaseContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2085);
                            recog.base.match_token(CASE, &mut recog.err_handler)?;

                            recog.base.set_state(2087);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            loop {
                                {
                                    {
                                        /*InvokeRule whenClause*/
                                        recog.base.set_state(2086);
                                        recog.whenClause()?;
                                    }
                                }
                                recog.base.set_state(2089);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if !(_la == WHEN) {
                                    break;
                                }
                            }
                            recog.base.set_state(2093);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == ELSE {
                                {
                                    recog.base.set_state(2091);
                                    recog
                                        .base
                                        .match_token(ELSE, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(2092);
                                    let tmp = recog.expression()?;
                                    if let PrimaryExpressionContextAll::SearchedCaseContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.elseExpression = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                }
                            }

                            recog.base.set_state(2095);
                            recog.base.match_token(END, &mut recog.err_handler)?;
                        }
                    }
                    23 => {
                        {
                            let mut tmp = CastContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2097);
                            recog.base.match_token(CAST, &mut recog.err_handler)?;

                            recog.base.set_state(2098);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(2099);
                            recog.expression()?;

                            recog.base.set_state(2100);
                            recog.base.match_token(AS, &mut recog.err_handler)?;

                            /*InvokeRule type_*/
                            recog.base.set_state(2101);
                            recog.type__rec(0)?;

                            recog.base.set_state(2102);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    24 => {
                        {
                            let mut tmp = CastContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2104);
                            recog.base.match_token(TRY_CAST, &mut recog.err_handler)?;

                            recog.base.set_state(2105);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(2106);
                            recog.expression()?;

                            recog.base.set_state(2107);
                            recog.base.match_token(AS, &mut recog.err_handler)?;

                            /*InvokeRule type_*/
                            recog.base.set_state(2108);
                            recog.type__rec(0)?;

                            recog.base.set_state(2109);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    25 => {
                        {
                            let mut tmp = ArrayConstructorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2111);
                            recog.base.match_token(ARRAY, &mut recog.err_handler)?;

                            recog.base.set_state(2112);
                            recog.base.match_token(T__6, &mut recog.err_handler)?;

                            recog.base.set_state(2121);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if (((_la) & !0x3f) == 0
                                && ((1usize << _la)
                                    & ((1usize << T__1)
                                        | (1usize << ABSENT)
                                        | (1usize << ADD)
                                        | (1usize << ADMIN)
                                        | (1usize << AFTER)
                                        | (1usize << ALL)
                                        | (1usize << ANALYZE)
                                        | (1usize << ANY)
                                        | (1usize << ARRAY)
                                        | (1usize << ASC)
                                        | (1usize << AT)
                                        | (1usize << AUTHORIZATION)
                                        | (1usize << BERNOULLI)))
                                    != 0)
                                || (((_la - 33) & !0x3f) == 0
                                    && ((1usize << (_la - 33))
                                        & ((1usize << (BOTH - 33))
                                            | (1usize << (CALL - 33))
                                            | (1usize << (CASCADE - 33))
                                            | (1usize << (CASE - 33))
                                            | (1usize << (CAST - 33))
                                            | (1usize << (CATALOGS - 33))
                                            | (1usize << (COLUMN - 33))
                                            | (1usize << (COLUMNS - 33))
                                            | (1usize << (COMMENT - 33))
                                            | (1usize << (COMMIT - 33))
                                            | (1usize << (COMMITTED - 33))
                                            | (1usize << (CONDITIONAL - 33))
                                            | (1usize << (COUNT - 33))
                                            | (1usize << (COPARTITION - 33))
                                            | (1usize << (CURRENT - 33))
                                            | (1usize << (CURRENT_CATALOG - 33))
                                            | (1usize << (CURRENT_DATE - 33))
                                            | (1usize << (CURRENT_PATH - 33))
                                            | (1usize << (CURRENT_SCHEMA - 33))
                                            | (1usize << (CURRENT_TIME - 33))
                                            | (1usize << (CURRENT_TIMESTAMP - 33))
                                            | (1usize << (CURRENT_USER - 33))
                                            | (1usize << (DATA - 33))
                                            | (1usize << (DATE - 33))
                                            | (1usize << (DAY - 33))))
                                        != 0)
                                || (((_la - 66) & !0x3f) == 0
                                    && ((1usize << (_la - 66))
                                        & ((1usize << (DEFAULT - 66))
                                            | (1usize << (DEFINE - 66))
                                            | (1usize << (DEFINER - 66))
                                            | (1usize << (DENY - 66))
                                            | (1usize << (DESC - 66))
                                            | (1usize << (DESCRIPTOR - 66))
                                            | (1usize << (DISTRIBUTED - 66))
                                            | (1usize << (DOUBLE - 66))
                                            | (1usize << (EMPTY - 66))
                                            | (1usize << (ENCODING - 66))
                                            | (1usize << (ERROR - 66))
                                            | (1usize << (EXCLUDING - 66))
                                            | (1usize << (EXISTS - 66))
                                            | (1usize << (EXPLAIN - 66))
                                            | (1usize << (EXTRACT - 66))
                                            | (1usize << (FALSE - 66))
                                            | (1usize << (FETCH - 66))
                                            | (1usize << (FILTER - 66))
                                            | (1usize << (FINAL - 66))
                                            | (1usize << (FIRST - 66))
                                            | (1usize << (FOLLOWING - 66))
                                            | (1usize << (FORMAT - 66))))
                                        != 0)
                                || (((_la - 100) & !0x3f) == 0
                                    && ((1usize << (_la - 100))
                                        & ((1usize << (FUNCTIONS - 100))
                                            | (1usize << (GRACE - 100))
                                            | (1usize << (GRANT - 100))
                                            | (1usize << (GRANTED - 100))
                                            | (1usize << (GRANTS - 100))
                                            | (1usize << (GRAPHVIZ - 100))
                                            | (1usize << (GROUPING - 100))
                                            | (1usize << (GROUPS - 100))
                                            | (1usize << (HOUR - 100))
                                            | (1usize << (IF - 100))
                                            | (1usize << (IGNORE - 100))
                                            | (1usize << (INCLUDING - 100))
                                            | (1usize << (INITIAL - 100))
                                            | (1usize << (INPUT - 100))
                                            | (1usize << (INTERVAL - 100))
                                            | (1usize << (INVOKER - 100))
                                            | (1usize << (IO - 100))
                                            | (1usize << (ISOLATION - 100))
                                            | (1usize << (JSON - 100))
                                            | (1usize << (JSON_ARRAY - 100))
                                            | (1usize << (JSON_EXISTS - 100))
                                            | (1usize << (JSON_OBJECT - 100))
                                            | (1usize << (JSON_QUERY - 100))))
                                        != 0)
                                || (((_la - 132) & !0x3f) == 0
                                    && ((1usize << (_la - 132))
                                        & ((1usize << (JSON_VALUE - 132))
                                            | (1usize << (KEEP - 132))
                                            | (1usize << (KEY - 132))
                                            | (1usize << (KEYS - 132))
                                            | (1usize << (LAST - 132))
                                            | (1usize << (LATERAL - 132))
                                            | (1usize << (LEADING - 132))
                                            | (1usize << (LEVEL - 132))
                                            | (1usize << (LIMIT - 132))
                                            | (1usize << (LISTAGG - 132))
                                            | (1usize << (LOCAL - 132))
                                            | (1usize << (LOCALTIME - 132))
                                            | (1usize << (LOCALTIMESTAMP - 132))
                                            | (1usize << (LOGICAL - 132))
                                            | (1usize << (MAP - 132))
                                            | (1usize << (MATCH - 132))
                                            | (1usize << (MATCHED - 132))
                                            | (1usize << (MATCHES - 132))
                                            | (1usize << (MATCH_RECOGNIZE - 132))
                                            | (1usize << (MATERIALIZED - 132))
                                            | (1usize << (MEASURES - 132))
                                            | (1usize << (MERGE - 132))
                                            | (1usize << (MINUTE - 132))
                                            | (1usize << (MONTH - 132))
                                            | (1usize << (NEXT - 132))
                                            | (1usize << (NFC - 132))
                                            | (1usize << (NFD - 132))
                                            | (1usize << (NFKC - 132))
                                            | (1usize << (NFKD - 132))))
                                        != 0)
                                || (((_la - 164) & !0x3f) == 0
                                    && ((1usize << (_la - 164))
                                        & ((1usize << (NO - 164))
                                            | (1usize << (NONE - 164))
                                            | (1usize << (NORMALIZE - 164))
                                            | (1usize << (NOT - 164))
                                            | (1usize << (NULL - 164))
                                            | (1usize << (NULLIF - 164))
                                            | (1usize << (NULLS - 164))
                                            | (1usize << (OBJECT - 164))
                                            | (1usize << (OF - 164))
                                            | (1usize << (OFFSET - 164))
                                            | (1usize << (OMIT - 164))
                                            | (1usize << (ONE - 164))
                                            | (1usize << (ONLY - 164))
                                            | (1usize << (OPTION - 164))
                                            | (1usize << (ORDINALITY - 164))
                                            | (1usize << (OUTPUT - 164))
                                            | (1usize << (OVER - 164))
                                            | (1usize << (OVERFLOW - 164))
                                            | (1usize << (PARTITION - 164))
                                            | (1usize << (PARTITIONS - 164))
                                            | (1usize << (PASSING - 164))
                                            | (1usize << (PAST - 164))
                                            | (1usize << (PATH - 164))
                                            | (1usize << (PATTERN - 164))
                                            | (1usize << (PER - 164))
                                            | (1usize << (PERIOD - 164))
                                            | (1usize << (PERMUTE - 164))
                                            | (1usize << (POSITION - 164))))
                                        != 0)
                                || (((_la - 196) & !0x3f) == 0
                                    && ((1usize << (_la - 196))
                                        & ((1usize << (PRECEDING - 196))
                                            | (1usize << (PRECISION - 196))
                                            | (1usize << (PRIVILEGES - 196))
                                            | (1usize << (PROPERTIES - 196))
                                            | (1usize << (PRUNE - 196))
                                            | (1usize << (QUOTES - 196))
                                            | (1usize << (RANGE - 196))
                                            | (1usize << (READ - 196))
                                            | (1usize << (REFRESH - 196))
                                            | (1usize << (RENAME - 196))
                                            | (1usize << (REPEATABLE - 196))
                                            | (1usize << (REPLACE - 196))
                                            | (1usize << (RESET - 196))
                                            | (1usize << (RESPECT - 196))
                                            | (1usize << (RESTRICT - 196))
                                            | (1usize << (RETURNING - 196))
                                            | (1usize << (REVOKE - 196))
                                            | (1usize << (ROLE - 196))
                                            | (1usize << (ROLES - 196))
                                            | (1usize << (ROLLBACK - 196))
                                            | (1usize << (ROW - 196))
                                            | (1usize << (ROWS - 196))
                                            | (1usize << (RUNNING - 196))
                                            | (1usize << (SCALAR - 196))
                                            | (1usize << (SCHEMA - 196))
                                            | (1usize << (SCHEMAS - 196))
                                            | (1usize << (SECOND - 196))
                                            | (1usize << (SECURITY - 196))))
                                        != 0)
                                || (((_la - 228) & !0x3f) == 0
                                    && ((1usize << (_la - 228))
                                        & ((1usize << (SEEK - 228))
                                            | (1usize << (SERIALIZABLE - 228))
                                            | (1usize << (SESSION - 228))
                                            | (1usize << (SET - 228))
                                            | (1usize << (SETS - 228))
                                            | (1usize << (SHOW - 228))
                                            | (1usize << (SOME - 228))
                                            | (1usize << (START - 228))
                                            | (1usize << (STATS - 228))
                                            | (1usize << (SUBSET - 228))
                                            | (1usize << (SUBSTRING - 228))
                                            | (1usize << (SYSTEM - 228))
                                            | (1usize << (TABLES - 228))
                                            | (1usize << (TABLESAMPLE - 228))
                                            | (1usize << (TEXT - 228))
                                            | (1usize << (TEXT_STRING - 228))
                                            | (1usize << (TIES - 228))
                                            | (1usize << (TIME - 228))
                                            | (1usize << (TIMESTAMP - 228))
                                            | (1usize << (TO - 228))
                                            | (1usize << (TRAILING - 228))
                                            | (1usize << (TRANSACTION - 228))
                                            | (1usize << (TRIM - 228))
                                            | (1usize << (TRUE - 228))
                                            | (1usize << (TRUNCATE - 228))
                                            | (1usize << (TRY_CAST - 228))
                                            | (1usize << (TYPE - 228))
                                            | (1usize << (UNBOUNDED - 228))))
                                        != 0)
                                || (((_la - 260) & !0x3f) == 0
                                    && ((1usize << (_la - 260))
                                        & ((1usize << (UNCOMMITTED - 260))
                                            | (1usize << (UNCONDITIONAL - 260))
                                            | (1usize << (UNIQUE - 260))
                                            | (1usize << (UNKNOWN - 260))
                                            | (1usize << (UNMATCHED - 260))
                                            | (1usize << (UPDATE - 260))
                                            | (1usize << (USE - 260))
                                            | (1usize << (USER - 260))
                                            | (1usize << (UTF16 - 260))
                                            | (1usize << (UTF32 - 260))
                                            | (1usize << (UTF8 - 260))
                                            | (1usize << (VALIDATE - 260))
                                            | (1usize << (VALUE - 260))
                                            | (1usize << (VERBOSE - 260))
                                            | (1usize << (VERSION - 260))
                                            | (1usize << (VIEW - 260))
                                            | (1usize << (WINDOW - 260))
                                            | (1usize << (WITHIN - 260))
                                            | (1usize << (WITHOUT - 260))
                                            | (1usize << (WORK - 260))
                                            | (1usize << (WRAPPER - 260))
                                            | (1usize << (WRITE - 260))
                                            | (1usize << (YEAR - 260))
                                            | (1usize << (ZONE - 260))))
                                        != 0)
                                || (((_la - 297) & !0x3f) == 0
                                    && ((1usize << (_la - 297))
                                        & ((1usize << (PLUS - 297))
                                            | (1usize << (MINUS - 297))
                                            | (1usize << (QUESTION_MARK - 297))
                                            | (1usize << (STRING - 297))
                                            | (1usize << (UNICODE_STRING - 297))
                                            | (1usize << (BINARY_LITERAL - 297))
                                            | (1usize << (INTEGER_VALUE - 297))
                                            | (1usize << (DECIMAL_VALUE - 297))
                                            | (1usize << (DOUBLE_VALUE - 297))
                                            | (1usize << (IDENTIFIER - 297))
                                            | (1usize << (DIGIT_IDENTIFIER - 297))
                                            | (1usize << (QUOTED_IDENTIFIER - 297))
                                            | (1usize << (BACKQUOTED_IDENTIFIER - 297))))
                                        != 0)
                            {
                                {
                                    /*InvokeRule expression*/
                                    recog.base.set_state(2113);
                                    recog.expression()?;

                                    recog.base.set_state(2118);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(2114);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule expression*/
                                                recog.base.set_state(2115);
                                                recog.expression()?;
                                            }
                                        }
                                        recog.base.set_state(2120);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(2123);
                            recog.base.match_token(T__7, &mut recog.err_handler)?;
                        }
                    }
                    26 => {
                        {
                            let mut tmp = ColumnReferenceContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule identifier*/
                            recog.base.set_state(2124);
                            recog.identifier()?;
                        }
                    }
                    27 => {
                        let mut tmp =
                            SpecialDateTimeFunctionContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2125);
                        let tmp = recog
                            .base
                            .match_token(CURRENT_DATE, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.name = Some(&tmp); } else {unreachable!("cant cast");}
                    }
                    28 => {
                        let mut tmp =
                            SpecialDateTimeFunctionContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2126);
                        let tmp = recog
                            .base
                            .match_token(CURRENT_TIME, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.name = Some(&tmp); } else {unreachable!("cant cast");}

                        recog.base.set_state(2130);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(276, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2127);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                recog.base.set_state(2128);
                                let tmp = recog
                                    .base
                                    .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                                if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.precision = Some(&tmp); } else {unreachable!("cant cast");}

                                recog.base.set_state(2129);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                    }
                    29 => {
                        let mut tmp =
                            SpecialDateTimeFunctionContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2132);
                        let tmp = recog
                            .base
                            .match_token(CURRENT_TIMESTAMP, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.name = Some(&tmp); } else {unreachable!("cant cast");}

                        recog.base.set_state(2136);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(277, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2133);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                recog.base.set_state(2134);
                                let tmp = recog
                                    .base
                                    .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                                if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.precision = Some(&tmp); } else {unreachable!("cant cast");}

                                recog.base.set_state(2135);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                    }
                    30 => {
                        let mut tmp =
                            SpecialDateTimeFunctionContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2138);
                        let tmp =
                            recog.base.match_token(LOCALTIME, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.name = Some(&tmp); } else {unreachable!("cant cast");}

                        recog.base.set_state(2142);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(278, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2139);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                recog.base.set_state(2140);
                                let tmp = recog
                                    .base
                                    .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                                if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.precision = Some(&tmp); } else {unreachable!("cant cast");}

                                recog.base.set_state(2141);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                    }
                    31 => {
                        let mut tmp =
                            SpecialDateTimeFunctionContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2144);
                        let tmp = recog
                            .base
                            .match_token(LOCALTIMESTAMP, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.name = Some(&tmp); } else {unreachable!("cant cast");}

                        recog.base.set_state(2148);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(279, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2145);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                recog.base.set_state(2146);
                                let tmp = recog
                                    .base
                                    .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                                if let PrimaryExpressionContextAll::SpecialDateTimeFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.precision = Some(&tmp); } else {unreachable!("cant cast");}

                                recog.base.set_state(2147);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                    }
                    32 => {
                        let mut tmp = CurrentUserContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2150);
                        let tmp = recog
                            .base
                            .match_token(CURRENT_USER, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::CurrentUserContext(ctx) =
                            cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                        {
                            ctx.name = Some(&tmp);
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                    33 => {
                        let mut tmp = CurrentCatalogContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2151);
                        let tmp = recog
                            .base
                            .match_token(CURRENT_CATALOG, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::CurrentCatalogContext(ctx) =
                            cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                        {
                            ctx.name = Some(&tmp);
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                    34 => {
                        let mut tmp = CurrentSchemaContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2152);
                        let tmp = recog
                            .base
                            .match_token(CURRENT_SCHEMA, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::CurrentSchemaContext(ctx) =
                            cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                        {
                            ctx.name = Some(&tmp);
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                    35 => {
                        let mut tmp = CurrentPathContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2153);
                        let tmp = recog
                            .base
                            .match_token(CURRENT_PATH, &mut recog.err_handler)?;
                        if let PrimaryExpressionContextAll::CurrentPathContext(ctx) =
                            cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                        {
                            ctx.name = Some(&tmp);
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                    36 => {
                        {
                            let mut tmp = TrimContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2154);
                            recog.base.match_token(TRIM, &mut recog.err_handler)?;

                            recog.base.set_state(2155);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(2163);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(282, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(2157);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        match recog
                                            .interpreter
                                            .adaptive_predict(280, &mut recog.base)?
                                        {
                                            x if x == 1 => {
                                                {
                                                    /*InvokeRule trimsSpecification*/
                                                    recog.base.set_state(2156);
                                                    recog.trimsSpecification()?;
                                                }
                                            }

                                            _ => {}
                                        }
                                        recog.base.set_state(2160);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if (((_la) & !0x3f) == 0
                                            && ((1usize << _la)
                                                & ((1usize << T__1)
                                                    | (1usize << ABSENT)
                                                    | (1usize << ADD)
                                                    | (1usize << ADMIN)
                                                    | (1usize << AFTER)
                                                    | (1usize << ALL)
                                                    | (1usize << ANALYZE)
                                                    | (1usize << ANY)
                                                    | (1usize << ARRAY)
                                                    | (1usize << ASC)
                                                    | (1usize << AT)
                                                    | (1usize << AUTHORIZATION)
                                                    | (1usize << BERNOULLI)))
                                                != 0)
                                            || (((_la - 33) & !0x3f) == 0
                                                && ((1usize << (_la - 33))
                                                    & ((1usize << (BOTH - 33))
                                                        | (1usize << (CALL - 33))
                                                        | (1usize << (CASCADE - 33))
                                                        | (1usize << (CASE - 33))
                                                        | (1usize << (CAST - 33))
                                                        | (1usize << (CATALOGS - 33))
                                                        | (1usize << (COLUMN - 33))
                                                        | (1usize << (COLUMNS - 33))
                                                        | (1usize << (COMMENT - 33))
                                                        | (1usize << (COMMIT - 33))
                                                        | (1usize << (COMMITTED - 33))
                                                        | (1usize
                                                            << (CONDITIONAL - 33))
                                                        | (1usize << (COUNT - 33))
                                                        | (1usize
                                                            << (COPARTITION - 33))
                                                        | (1usize << (CURRENT - 33))
                                                        | (1usize
                                                            << (CURRENT_CATALOG - 33))
                                                        | (1usize
                                                            << (CURRENT_DATE - 33))
                                                        | (1usize
                                                            << (CURRENT_PATH - 33))
                                                        | (1usize
                                                            << (CURRENT_SCHEMA - 33))
                                                        | (1usize
                                                            << (CURRENT_TIME - 33))
                                                        | (1usize
                                                            << (CURRENT_TIMESTAMP
                                                                - 33))
                                                        | (1usize
                                                            << (CURRENT_USER - 33))
                                                        | (1usize << (DATA - 33))
                                                        | (1usize << (DATE - 33))
                                                        | (1usize << (DAY - 33))))
                                                    != 0)
                                            || (((_la - 66) & !0x3f) == 0
                                                && ((1usize << (_la - 66))
                                                    & ((1usize << (DEFAULT - 66))
                                                        | (1usize << (DEFINE - 66))
                                                        | (1usize << (DEFINER - 66))
                                                        | (1usize << (DENY - 66))
                                                        | (1usize << (DESC - 66))
                                                        | (1usize << (DESCRIPTOR - 66))
                                                        | (1usize
                                                            << (DISTRIBUTED - 66))
                                                        | (1usize << (DOUBLE - 66))
                                                        | (1usize << (EMPTY - 66))
                                                        | (1usize << (ENCODING - 66))
                                                        | (1usize << (ERROR - 66))
                                                        | (1usize << (EXCLUDING - 66))
                                                        | (1usize << (EXISTS - 66))
                                                        | (1usize << (EXPLAIN - 66))
                                                        | (1usize << (EXTRACT - 66))
                                                        | (1usize << (FALSE - 66))
                                                        | (1usize << (FETCH - 66))
                                                        | (1usize << (FILTER - 66))
                                                        | (1usize << (FINAL - 66))
                                                        | (1usize << (FIRST - 66))
                                                        | (1usize << (FOLLOWING - 66))
                                                        | (1usize << (FORMAT - 66))))
                                                    != 0)
                                            || (((_la - 100) & !0x3f) == 0
                                                && ((1usize << (_la - 100))
                                                    & ((1usize << (FUNCTIONS - 100))
                                                        | (1usize << (GRACE - 100))
                                                        | (1usize << (GRANT - 100))
                                                        | (1usize << (GRANTED - 100))
                                                        | (1usize << (GRANTS - 100))
                                                        | (1usize << (GRAPHVIZ - 100))
                                                        | (1usize << (GROUPING - 100))
                                                        | (1usize << (GROUPS - 100))
                                                        | (1usize << (HOUR - 100))
                                                        | (1usize << (IF - 100))
                                                        | (1usize << (IGNORE - 100))
                                                        | (1usize << (INCLUDING - 100))
                                                        | (1usize << (INITIAL - 100))
                                                        | (1usize << (INPUT - 100))
                                                        | (1usize << (INTERVAL - 100))
                                                        | (1usize << (INVOKER - 100))
                                                        | (1usize << (IO - 100))
                                                        | (1usize << (ISOLATION - 100))
                                                        | (1usize << (JSON - 100))
                                                        | (1usize
                                                            << (JSON_ARRAY - 100))
                                                        | (1usize
                                                            << (JSON_EXISTS - 100))
                                                        | (1usize
                                                            << (JSON_OBJECT - 100))
                                                        | (1usize
                                                            << (JSON_QUERY - 100))))
                                                    != 0)
                                            || (((_la - 132) & !0x3f) == 0
                                                && ((1usize << (_la - 132))
                                                    & ((1usize << (JSON_VALUE - 132))
                                                        | (1usize << (KEEP - 132))
                                                        | (1usize << (KEY - 132))
                                                        | (1usize << (KEYS - 132))
                                                        | (1usize << (LAST - 132))
                                                        | (1usize << (LATERAL - 132))
                                                        | (1usize << (LEADING - 132))
                                                        | (1usize << (LEVEL - 132))
                                                        | (1usize << (LIMIT - 132))
                                                        | (1usize << (LISTAGG - 132))
                                                        | (1usize << (LOCAL - 132))
                                                        | (1usize << (LOCALTIME - 132))
                                                        | (1usize
                                                            << (LOCALTIMESTAMP - 132))
                                                        | (1usize << (LOGICAL - 132))
                                                        | (1usize << (MAP - 132))
                                                        | (1usize << (MATCH - 132))
                                                        | (1usize << (MATCHED - 132))
                                                        | (1usize << (MATCHES - 132))
                                                        | (1usize
                                                            << (MATCH_RECOGNIZE - 132))
                                                        | (1usize
                                                            << (MATERIALIZED - 132))
                                                        | (1usize << (MEASURES - 132))
                                                        | (1usize << (MERGE - 132))
                                                        | (1usize << (MINUTE - 132))
                                                        | (1usize << (MONTH - 132))
                                                        | (1usize << (NEXT - 132))
                                                        | (1usize << (NFC - 132))
                                                        | (1usize << (NFD - 132))
                                                        | (1usize << (NFKC - 132))
                                                        | (1usize << (NFKD - 132))))
                                                    != 0)
                                            || (((_la - 164) & !0x3f) == 0
                                                && ((1usize << (_la - 164))
                                                    & ((1usize << (NO - 164))
                                                        | (1usize << (NONE - 164))
                                                        | (1usize << (NORMALIZE - 164))
                                                        | (1usize << (NULL - 164))
                                                        | (1usize << (NULLIF - 164))
                                                        | (1usize << (NULLS - 164))
                                                        | (1usize << (OBJECT - 164))
                                                        | (1usize << (OF - 164))
                                                        | (1usize << (OFFSET - 164))
                                                        | (1usize << (OMIT - 164))
                                                        | (1usize << (ONE - 164))
                                                        | (1usize << (ONLY - 164))
                                                        | (1usize << (OPTION - 164))
                                                        | (1usize
                                                            << (ORDINALITY - 164))
                                                        | (1usize << (OUTPUT - 164))
                                                        | (1usize << (OVER - 164))
                                                        | (1usize << (OVERFLOW - 164))
                                                        | (1usize << (PARTITION - 164))
                                                        | (1usize
                                                            << (PARTITIONS - 164))
                                                        | (1usize << (PASSING - 164))
                                                        | (1usize << (PAST - 164))
                                                        | (1usize << (PATH - 164))
                                                        | (1usize << (PATTERN - 164))
                                                        | (1usize << (PER - 164))
                                                        | (1usize << (PERIOD - 164))
                                                        | (1usize << (PERMUTE - 164))
                                                        | (1usize << (POSITION - 164))))
                                                    != 0)
                                            || (((_la - 196) & !0x3f) == 0
                                                && ((1usize << (_la - 196))
                                                    & ((1usize << (PRECEDING - 196))
                                                        | (1usize << (PRECISION - 196))
                                                        | (1usize
                                                            << (PRIVILEGES - 196))
                                                        | (1usize
                                                            << (PROPERTIES - 196))
                                                        | (1usize << (PRUNE - 196))
                                                        | (1usize << (QUOTES - 196))
                                                        | (1usize << (RANGE - 196))
                                                        | (1usize << (READ - 196))
                                                        | (1usize << (REFRESH - 196))
                                                        | (1usize << (RENAME - 196))
                                                        | (1usize
                                                            << (REPEATABLE - 196))
                                                        | (1usize << (REPLACE - 196))
                                                        | (1usize << (RESET - 196))
                                                        | (1usize << (RESPECT - 196))
                                                        | (1usize << (RESTRICT - 196))
                                                        | (1usize << (RETURNING - 196))
                                                        | (1usize << (REVOKE - 196))
                                                        | (1usize << (ROLE - 196))
                                                        | (1usize << (ROLES - 196))
                                                        | (1usize << (ROLLBACK - 196))
                                                        | (1usize << (ROW - 196))
                                                        | (1usize << (ROWS - 196))
                                                        | (1usize << (RUNNING - 196))
                                                        | (1usize << (SCALAR - 196))
                                                        | (1usize << (SCHEMA - 196))
                                                        | (1usize << (SCHEMAS - 196))
                                                        | (1usize << (SECOND - 196))
                                                        | (1usize << (SECURITY - 196))))
                                                    != 0)
                                            || (((_la - 228) & !0x3f) == 0
                                                && ((1usize << (_la - 228))
                                                    & ((1usize << (SEEK - 228))
                                                        | (1usize
                                                            << (SERIALIZABLE - 228))
                                                        | (1usize << (SESSION - 228))
                                                        | (1usize << (SET - 228))
                                                        | (1usize << (SETS - 228))
                                                        | (1usize << (SHOW - 228))
                                                        | (1usize << (SOME - 228))
                                                        | (1usize << (START - 228))
                                                        | (1usize << (STATS - 228))
                                                        | (1usize << (SUBSET - 228))
                                                        | (1usize << (SUBSTRING - 228))
                                                        | (1usize << (SYSTEM - 228))
                                                        | (1usize << (TABLES - 228))
                                                        | (1usize
                                                            << (TABLESAMPLE - 228))
                                                        | (1usize << (TEXT - 228))
                                                        | (1usize
                                                            << (TEXT_STRING - 228))
                                                        | (1usize << (TIES - 228))
                                                        | (1usize << (TIME - 228))
                                                        | (1usize << (TIMESTAMP - 228))
                                                        | (1usize << (TO - 228))
                                                        | (1usize << (TRAILING - 228))
                                                        | (1usize
                                                            << (TRANSACTION - 228))
                                                        | (1usize << (TRIM - 228))
                                                        | (1usize << (TRUE - 228))
                                                        | (1usize << (TRUNCATE - 228))
                                                        | (1usize << (TRY_CAST - 228))
                                                        | (1usize << (TYPE - 228))
                                                        | (1usize << (UNBOUNDED - 228))))
                                                    != 0)
                                            || (((_la - 260) & !0x3f) == 0
                                                && ((1usize << (_la - 260))
                                                    & ((1usize << (UNCOMMITTED - 260))
                                                        | (1usize
                                                            << (UNCONDITIONAL - 260))
                                                        | (1usize << (UNIQUE - 260))
                                                        | (1usize << (UNKNOWN - 260))
                                                        | (1usize << (UNMATCHED - 260))
                                                        | (1usize << (UPDATE - 260))
                                                        | (1usize << (USE - 260))
                                                        | (1usize << (USER - 260))
                                                        | (1usize << (UTF16 - 260))
                                                        | (1usize << (UTF32 - 260))
                                                        | (1usize << (UTF8 - 260))
                                                        | (1usize << (VALIDATE - 260))
                                                        | (1usize << (VALUE - 260))
                                                        | (1usize << (VERBOSE - 260))
                                                        | (1usize << (VERSION - 260))
                                                        | (1usize << (VIEW - 260))
                                                        | (1usize << (WINDOW - 260))
                                                        | (1usize << (WITHIN - 260))
                                                        | (1usize << (WITHOUT - 260))
                                                        | (1usize << (WORK - 260))
                                                        | (1usize << (WRAPPER - 260))
                                                        | (1usize << (WRITE - 260))
                                                        | (1usize << (YEAR - 260))
                                                        | (1usize << (ZONE - 260))))
                                                    != 0)
                                            || (((_la - 297) & !0x3f) == 0
                                                && ((1usize << (_la - 297))
                                                    & ((1usize << (PLUS - 297))
                                                        | (1usize << (MINUS - 297))
                                                        | (1usize
                                                            << (QUESTION_MARK - 297))
                                                        | (1usize << (STRING - 297))
                                                        | (1usize
                                                            << (UNICODE_STRING - 297))
                                                        | (1usize
                                                            << (BINARY_LITERAL - 297))
                                                        | (1usize
                                                            << (INTEGER_VALUE - 297))
                                                        | (1usize
                                                            << (DECIMAL_VALUE - 297))
                                                        | (1usize
                                                            << (DOUBLE_VALUE - 297))
                                                        | (1usize
                                                            << (IDENTIFIER - 297))
                                                        | (1usize
                                                            << (DIGIT_IDENTIFIER
                                                                - 297))
                                                        | (1usize
                                                            << (QUOTED_IDENTIFIER
                                                                - 297))
                                                        | (1usize
                                                            << (BACKQUOTED_IDENTIFIER
                                                                - 297))))
                                                    != 0)
                                        {
                                            {
                                                /*InvokeRule valueExpression*/
                                                recog.base.set_state(2159);
                                                let tmp = recog.valueExpression_rec(0)?;
                                                if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
								ctx.trimChar = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                            }
                                        }

                                        recog.base.set_state(2162);
                                        recog
                                            .base
                                            .match_token(FROM, &mut recog.err_handler)?;
                                    }
                                }

                                _ => {}
                            }
                            /*InvokeRule valueExpression*/
                            recog.base.set_state(2165);
                            let tmp = recog.valueExpression_rec(0)?;
                            if let PrimaryExpressionContextAll::TrimContext(ctx) =
                                cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                            {
                                ctx.trimSource = Some(tmp.clone());
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2166);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    37 => {
                        {
                            let mut tmp = TrimContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2168);
                            recog.base.match_token(TRIM, &mut recog.err_handler)?;

                            recog.base.set_state(2169);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(2170);
                            let tmp = recog.valueExpression_rec(0)?;
                            if let PrimaryExpressionContextAll::TrimContext(ctx) =
                                cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                            {
                                ctx.trimSource = Some(tmp.clone());
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2171);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(2172);
                            let tmp = recog.valueExpression_rec(0)?;
                            if let PrimaryExpressionContextAll::TrimContext(ctx) =
                                cast_mut::<_, PrimaryExpressionContextAll>(&mut _localctx)
                            {
                                ctx.trimChar = Some(tmp.clone());
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2173);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    38 => {
                        {
                            let mut tmp = SubstringContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2175);
                            recog.base.match_token(SUBSTRING, &mut recog.err_handler)?;

                            recog.base.set_state(2176);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(2177);
                            recog.valueExpression_rec(0)?;

                            recog.base.set_state(2178);
                            recog.base.match_token(FROM, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(2179);
                            recog.valueExpression_rec(0)?;

                            recog.base.set_state(2182);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == FOR {
                                {
                                    recog.base.set_state(2180);
                                    recog
                                        .base
                                        .match_token(FOR, &mut recog.err_handler)?;

                                    /*InvokeRule valueExpression*/
                                    recog.base.set_state(2181);
                                    recog.valueExpression_rec(0)?;
                                }
                            }

                            recog.base.set_state(2184);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    39 => {
                        {
                            let mut tmp = NormalizeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2186);
                            recog.base.match_token(NORMALIZE, &mut recog.err_handler)?;

                            recog.base.set_state(2187);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(2188);
                            recog.valueExpression_rec(0)?;

                            recog.base.set_state(2191);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == COMMA {
                                {
                                    recog.base.set_state(2189);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule normalForm*/
                                    recog.base.set_state(2190);
                                    recog.normalForm()?;
                                }
                            }

                            recog.base.set_state(2193);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    40 => {
                        {
                            let mut tmp = ExtractContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2195);
                            recog.base.match_token(EXTRACT, &mut recog.err_handler)?;

                            recog.base.set_state(2196);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule identifier*/
                            recog.base.set_state(2197);
                            recog.identifier()?;

                            recog.base.set_state(2198);
                            recog.base.match_token(FROM, &mut recog.err_handler)?;

                            /*InvokeRule valueExpression*/
                            recog.base.set_state(2199);
                            recog.valueExpression_rec(0)?;

                            recog.base.set_state(2200);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    41 => {
                        {
                            let mut tmp =
                                ParenthesizedExpressionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2202);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule expression*/
                            recog.base.set_state(2203);
                            recog.expression()?;

                            recog.base.set_state(2204);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    42 => {
                        {
                            let mut tmp = GroupingOperationContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2206);
                            recog.base.match_token(GROUPING, &mut recog.err_handler)?;

                            recog.base.set_state(2207);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(2216);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if (((_la) & !0x3f) == 0
                                && ((1usize << _la)
                                    & ((1usize << ABSENT)
                                        | (1usize << ADD)
                                        | (1usize << ADMIN)
                                        | (1usize << AFTER)
                                        | (1usize << ALL)
                                        | (1usize << ANALYZE)
                                        | (1usize << ANY)
                                        | (1usize << ARRAY)
                                        | (1usize << ASC)
                                        | (1usize << AT)
                                        | (1usize << AUTHORIZATION)
                                        | (1usize << BERNOULLI)))
                                    != 0)
                                || (((_la - 33) & !0x3f) == 0
                                    && ((1usize << (_la - 33))
                                        & ((1usize << (BOTH - 33))
                                            | (1usize << (CALL - 33))
                                            | (1usize << (CASCADE - 33))
                                            | (1usize << (CATALOGS - 33))
                                            | (1usize << (COLUMN - 33))
                                            | (1usize << (COLUMNS - 33))
                                            | (1usize << (COMMENT - 33))
                                            | (1usize << (COMMIT - 33))
                                            | (1usize << (COMMITTED - 33))
                                            | (1usize << (CONDITIONAL - 33))
                                            | (1usize << (COUNT - 33))
                                            | (1usize << (COPARTITION - 33))
                                            | (1usize << (CURRENT - 33))
                                            | (1usize << (DATA - 33))
                                            | (1usize << (DATE - 33))
                                            | (1usize << (DAY - 33))))
                                        != 0)
                                || (((_la - 66) & !0x3f) == 0
                                    && ((1usize << (_la - 66))
                                        & ((1usize << (DEFAULT - 66))
                                            | (1usize << (DEFINE - 66))
                                            | (1usize << (DEFINER - 66))
                                            | (1usize << (DENY - 66))
                                            | (1usize << (DESC - 66))
                                            | (1usize << (DESCRIPTOR - 66))
                                            | (1usize << (DISTRIBUTED - 66))
                                            | (1usize << (DOUBLE - 66))
                                            | (1usize << (EMPTY - 66))
                                            | (1usize << (ENCODING - 66))
                                            | (1usize << (ERROR - 66))
                                            | (1usize << (EXCLUDING - 66))
                                            | (1usize << (EXPLAIN - 66))
                                            | (1usize << (FETCH - 66))
                                            | (1usize << (FILTER - 66))
                                            | (1usize << (FINAL - 66))
                                            | (1usize << (FIRST - 66))
                                            | (1usize << (FOLLOWING - 66))
                                            | (1usize << (FORMAT - 66))))
                                        != 0)
                                || (((_la - 100) & !0x3f) == 0
                                    && ((1usize << (_la - 100))
                                        & ((1usize << (FUNCTIONS - 100))
                                            | (1usize << (GRACE - 100))
                                            | (1usize << (GRANT - 100))
                                            | (1usize << (GRANTED - 100))
                                            | (1usize << (GRANTS - 100))
                                            | (1usize << (GRAPHVIZ - 100))
                                            | (1usize << (GROUPS - 100))
                                            | (1usize << (HOUR - 100))
                                            | (1usize << (IF - 100))
                                            | (1usize << (IGNORE - 100))
                                            | (1usize << (INCLUDING - 100))
                                            | (1usize << (INITIAL - 100))
                                            | (1usize << (INPUT - 100))
                                            | (1usize << (INTERVAL - 100))
                                            | (1usize << (INVOKER - 100))
                                            | (1usize << (IO - 100))
                                            | (1usize << (ISOLATION - 100))
                                            | (1usize << (JSON - 100))))
                                        != 0)
                                || (((_la - 133) & !0x3f) == 0
                                    && ((1usize << (_la - 133))
                                        & ((1usize << (KEEP - 133))
                                            | (1usize << (KEY - 133))
                                            | (1usize << (KEYS - 133))
                                            | (1usize << (LAST - 133))
                                            | (1usize << (LATERAL - 133))
                                            | (1usize << (LEADING - 133))
                                            | (1usize << (LEVEL - 133))
                                            | (1usize << (LIMIT - 133))
                                            | (1usize << (LOCAL - 133))
                                            | (1usize << (LOGICAL - 133))
                                            | (1usize << (MAP - 133))
                                            | (1usize << (MATCH - 133))
                                            | (1usize << (MATCHED - 133))
                                            | (1usize << (MATCHES - 133))
                                            | (1usize << (MATCH_RECOGNIZE - 133))
                                            | (1usize << (MATERIALIZED - 133))
                                            | (1usize << (MEASURES - 133))
                                            | (1usize << (MERGE - 133))
                                            | (1usize << (MINUTE - 133))
                                            | (1usize << (MONTH - 133))
                                            | (1usize << (NEXT - 133))
                                            | (1usize << (NFC - 133))
                                            | (1usize << (NFD - 133))
                                            | (1usize << (NFKC - 133))
                                            | (1usize << (NFKD - 133))
                                            | (1usize << (NO - 133))))
                                        != 0)
                                || (((_la - 165) & !0x3f) == 0
                                    && ((1usize << (_la - 165))
                                        & ((1usize << (NONE - 165))
                                            | (1usize << (NULLIF - 165))
                                            | (1usize << (NULLS - 165))
                                            | (1usize << (OBJECT - 165))
                                            | (1usize << (OF - 165))
                                            | (1usize << (OFFSET - 165))
                                            | (1usize << (OMIT - 165))
                                            | (1usize << (ONE - 165))
                                            | (1usize << (ONLY - 165))
                                            | (1usize << (OPTION - 165))
                                            | (1usize << (ORDINALITY - 165))
                                            | (1usize << (OUTPUT - 165))
                                            | (1usize << (OVER - 165))
                                            | (1usize << (OVERFLOW - 165))
                                            | (1usize << (PARTITION - 165))
                                            | (1usize << (PARTITIONS - 165))
                                            | (1usize << (PASSING - 165))
                                            | (1usize << (PAST - 165))
                                            | (1usize << (PATH - 165))
                                            | (1usize << (PATTERN - 165))
                                            | (1usize << (PER - 165))
                                            | (1usize << (PERIOD - 165))
                                            | (1usize << (PERMUTE - 165))
                                            | (1usize << (POSITION - 165))
                                            | (1usize << (PRECEDING - 165))))
                                        != 0)
                                || (((_la - 197) & !0x3f) == 0
                                    && ((1usize << (_la - 197))
                                        & ((1usize << (PRECISION - 197))
                                            | (1usize << (PRIVILEGES - 197))
                                            | (1usize << (PROPERTIES - 197))
                                            | (1usize << (PRUNE - 197))
                                            | (1usize << (QUOTES - 197))
                                            | (1usize << (RANGE - 197))
                                            | (1usize << (READ - 197))
                                            | (1usize << (REFRESH - 197))
                                            | (1usize << (RENAME - 197))
                                            | (1usize << (REPEATABLE - 197))
                                            | (1usize << (REPLACE - 197))
                                            | (1usize << (RESET - 197))
                                            | (1usize << (RESPECT - 197))
                                            | (1usize << (RESTRICT - 197))
                                            | (1usize << (RETURNING - 197))
                                            | (1usize << (REVOKE - 197))
                                            | (1usize << (ROLE - 197))
                                            | (1usize << (ROLES - 197))
                                            | (1usize << (ROLLBACK - 197))
                                            | (1usize << (ROW - 197))
                                            | (1usize << (ROWS - 197))
                                            | (1usize << (RUNNING - 197))
                                            | (1usize << (SCALAR - 197))
                                            | (1usize << (SCHEMA - 197))
                                            | (1usize << (SCHEMAS - 197))
                                            | (1usize << (SECOND - 197))
                                            | (1usize << (SECURITY - 197))
                                            | (1usize << (SEEK - 197))))
                                        != 0)
                                || (((_la - 230) & !0x3f) == 0
                                    && ((1usize << (_la - 230))
                                        & ((1usize << (SERIALIZABLE - 230))
                                            | (1usize << (SESSION - 230))
                                            | (1usize << (SET - 230))
                                            | (1usize << (SETS - 230))
                                            | (1usize << (SHOW - 230))
                                            | (1usize << (SOME - 230))
                                            | (1usize << (START - 230))
                                            | (1usize << (STATS - 230))
                                            | (1usize << (SUBSET - 230))
                                            | (1usize << (SUBSTRING - 230))
                                            | (1usize << (SYSTEM - 230))
                                            | (1usize << (TABLES - 230))
                                            | (1usize << (TABLESAMPLE - 230))
                                            | (1usize << (TEXT - 230))
                                            | (1usize << (TEXT_STRING - 230))
                                            | (1usize << (TIES - 230))
                                            | (1usize << (TIME - 230))
                                            | (1usize << (TIMESTAMP - 230))
                                            | (1usize << (TO - 230))
                                            | (1usize << (TRAILING - 230))
                                            | (1usize << (TRANSACTION - 230))
                                            | (1usize << (TRUNCATE - 230))
                                            | (1usize << (TRY_CAST - 230))
                                            | (1usize << (TYPE - 230))
                                            | (1usize << (UNBOUNDED - 230))
                                            | (1usize << (UNCOMMITTED - 230))
                                            | (1usize << (UNCONDITIONAL - 230))))
                                        != 0)
                                || (((_la - 263) & !0x3f) == 0
                                    && ((1usize << (_la - 263))
                                        & ((1usize << (UNIQUE - 263))
                                            | (1usize << (UNKNOWN - 263))
                                            | (1usize << (UNMATCHED - 263))
                                            | (1usize << (UPDATE - 263))
                                            | (1usize << (USE - 263))
                                            | (1usize << (USER - 263))
                                            | (1usize << (UTF16 - 263))
                                            | (1usize << (UTF32 - 263))
                                            | (1usize << (UTF8 - 263))
                                            | (1usize << (VALIDATE - 263))
                                            | (1usize << (VALUE - 263))
                                            | (1usize << (VERBOSE - 263))
                                            | (1usize << (VERSION - 263))
                                            | (1usize << (VIEW - 263))
                                            | (1usize << (WINDOW - 263))
                                            | (1usize << (WITHIN - 263))
                                            | (1usize << (WITHOUT - 263))
                                            | (1usize << (WORK - 263))
                                            | (1usize << (WRAPPER - 263))
                                            | (1usize << (WRITE - 263))
                                            | (1usize << (YEAR - 263))
                                            | (1usize << (ZONE - 263))))
                                        != 0)
                                || (((_la - 310) & !0x3f) == 0
                                    && ((1usize << (_la - 310))
                                        & ((1usize << (IDENTIFIER - 310))
                                            | (1usize << (DIGIT_IDENTIFIER - 310))
                                            | (1usize << (QUOTED_IDENTIFIER - 310))
                                            | (1usize << (BACKQUOTED_IDENTIFIER - 310))))
                                        != 0)
                            {
                                {
                                    /*InvokeRule qualifiedName*/
                                    recog.base.set_state(2208);
                                    recog.qualifiedName()?;

                                    recog.base.set_state(2213);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    while _la == COMMA {
                                        {
                                            {
                                                recog.base.set_state(2209);
                                                recog.base.match_token(
                                                    COMMA,
                                                    &mut recog.err_handler,
                                                )?;

                                                /*InvokeRule qualifiedName*/
                                                recog.base.set_state(2210);
                                                recog.qualifiedName()?;
                                            }
                                        }
                                        recog.base.set_state(2215);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                    }
                                }
                            }

                            recog.base.set_state(2218);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    43 => {
                        {
                            let mut tmp = JsonExistsContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2219);
                            recog
                                .base
                                .match_token(JSON_EXISTS, &mut recog.err_handler)?;

                            recog.base.set_state(2220);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule jsonPathInvocation*/
                            recog.base.set_state(2221);
                            recog.jsonPathInvocation()?;

                            recog.base.set_state(2226);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == ERROR
                                || _la == FALSE
                                || _la == TRUE
                                || _la == UNKNOWN
                            {
                                {
                                    /*InvokeRule jsonExistsErrorBehavior*/
                                    recog.base.set_state(2222);
                                    recog.jsonExistsErrorBehavior()?;

                                    recog.base.set_state(2223);
                                    recog.base.match_token(ON, &mut recog.err_handler)?;

                                    recog.base.set_state(2224);
                                    recog
                                        .base
                                        .match_token(ERROR, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(2228);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    44 => {
                        {
                            let mut tmp = JsonValueContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2230);
                            recog.base.match_token(JSON_VALUE, &mut recog.err_handler)?;

                            recog.base.set_state(2231);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule jsonPathInvocation*/
                            recog.base.set_state(2232);
                            recog.jsonPathInvocation()?;

                            recog.base.set_state(2235);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == RETURNING {
                                {
                                    recog.base.set_state(2233);
                                    recog
                                        .base
                                        .match_token(RETURNING, &mut recog.err_handler)?;

                                    /*InvokeRule type_*/
                                    recog.base.set_state(2234);
                                    recog.type__rec(0)?;
                                }
                            }

                            recog.base.set_state(2241);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(289, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule jsonValueBehavior*/
                                        recog.base.set_state(2237);
                                        let tmp = recog.jsonValueBehavior()?;
                                        if let PrimaryExpressionContextAll::JsonValueContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.emptyBehavior = Some(tmp.clone()); } else {unreachable!("cant cast");}

                                        recog.base.set_state(2238);
                                        recog
                                            .base
                                            .match_token(ON, &mut recog.err_handler)?;

                                        recog.base.set_state(2239);
                                        recog
                                            .base
                                            .match_token(EMPTY, &mut recog.err_handler)?;
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2247);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == DEFAULT || _la == ERROR || _la == NULL {
                                {
                                    /*InvokeRule jsonValueBehavior*/
                                    recog.base.set_state(2243);
                                    let tmp = recog.jsonValueBehavior()?;
                                    if let PrimaryExpressionContextAll::JsonValueContext(
                                        ctx,
                                    ) = cast_mut::<_, PrimaryExpressionContextAll>(
                                        &mut _localctx,
                                    ) {
                                        ctx.errorBehavior = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }

                                    recog.base.set_state(2244);
                                    recog.base.match_token(ON, &mut recog.err_handler)?;

                                    recog.base.set_state(2245);
                                    recog
                                        .base
                                        .match_token(ERROR, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(2249);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    45 => {
                        {
                            let mut tmp = JsonQueryContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2251);
                            recog.base.match_token(JSON_QUERY, &mut recog.err_handler)?;

                            recog.base.set_state(2252);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule jsonPathInvocation*/
                            recog.base.set_state(2253);
                            recog.jsonPathInvocation()?;

                            recog.base.set_state(2260);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == RETURNING {
                                {
                                    recog.base.set_state(2254);
                                    recog
                                        .base
                                        .match_token(RETURNING, &mut recog.err_handler)?;

                                    /*InvokeRule type_*/
                                    recog.base.set_state(2255);
                                    recog.type__rec(0)?;

                                    recog.base.set_state(2258);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == FORMAT {
                                        {
                                            recog.base.set_state(2256);
                                            recog.base.match_token(
                                                FORMAT,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule jsonRepresentation*/
                                            recog.base.set_state(2257);
                                            recog.jsonRepresentation()?;
                                        }
                                    }
                                }
                            }

                            recog.base.set_state(2265);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == WITH || _la == WITHOUT {
                                {
                                    /*InvokeRule jsonQueryWrapperBehavior*/
                                    recog.base.set_state(2262);
                                    recog.jsonQueryWrapperBehavior()?;

                                    recog.base.set_state(2263);
                                    recog
                                        .base
                                        .match_token(WRAPPER, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(2274);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == KEEP || _la == OMIT {
                                {
                                    recog.base.set_state(2267);
                                    _la = recog.base.input.la(1);
                                    if { !(_la == KEEP || _la == OMIT) } {
                                        recog
                                            .err_handler
                                            .recover_inline(&mut recog.base)?;
                                    } else {
                                        if recog.base.input.la(1) == TOKEN_EOF {
                                            recog.base.matched_eof = true
                                        };
                                        recog.err_handler.report_match(&mut recog.base);
                                        recog.base.consume(&mut recog.err_handler);
                                    }
                                    recog.base.set_state(2268);
                                    recog
                                        .base
                                        .match_token(QUOTES, &mut recog.err_handler)?;

                                    recog.base.set_state(2272);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == ON {
                                        {
                                            recog.base.set_state(2269);
                                            recog.base.match_token(
                                                ON,
                                                &mut recog.err_handler,
                                            )?;

                                            recog.base.set_state(2270);
                                            recog.base.match_token(
                                                SCALAR,
                                                &mut recog.err_handler,
                                            )?;

                                            recog.base.set_state(2271);
                                            recog.base.match_token(
                                                TEXT_STRING,
                                                &mut recog.err_handler,
                                            )?;
                                        }
                                    }
                                }
                            }

                            recog.base.set_state(2280);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(296, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule jsonQueryBehavior*/
                                        recog.base.set_state(2276);
                                        let tmp = recog.jsonQueryBehavior()?;
                                        if let PrimaryExpressionContextAll::JsonQueryContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.emptyBehavior = Some(tmp.clone()); } else {unreachable!("cant cast");}

                                        recog.base.set_state(2277);
                                        recog
                                            .base
                                            .match_token(ON, &mut recog.err_handler)?;

                                        recog.base.set_state(2278);
                                        recog
                                            .base
                                            .match_token(EMPTY, &mut recog.err_handler)?;
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2286);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == EMPTY || _la == ERROR || _la == NULL {
                                {
                                    /*InvokeRule jsonQueryBehavior*/
                                    recog.base.set_state(2282);
                                    let tmp = recog.jsonQueryBehavior()?;
                                    if let PrimaryExpressionContextAll::JsonQueryContext(
                                        ctx,
                                    ) = cast_mut::<_, PrimaryExpressionContextAll>(
                                        &mut _localctx,
                                    ) {
                                        ctx.errorBehavior = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }

                                    recog.base.set_state(2283);
                                    recog.base.match_token(ON, &mut recog.err_handler)?;

                                    recog.base.set_state(2284);
                                    recog
                                        .base
                                        .match_token(ERROR, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(2288);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    46 => {
                        {
                            let mut tmp = JsonObjectContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2290);
                            recog
                                .base
                                .match_token(JSON_OBJECT, &mut recog.err_handler)?;

                            recog.base.set_state(2291);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(2320);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(303, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule jsonObjectMember*/
                                        recog.base.set_state(2292);
                                        recog.jsonObjectMember()?;

                                        recog.base.set_state(2297);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        while _la == COMMA {
                                            {
                                                {
                                                    recog.base.set_state(2293);
                                                    recog.base.match_token(
                                                        COMMA,
                                                        &mut recog.err_handler,
                                                    )?;

                                                    /*InvokeRule jsonObjectMember*/
                                                    recog.base.set_state(2294);
                                                    recog.jsonObjectMember()?;
                                                }
                                            }
                                            recog.base.set_state(2299);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _la = recog.base.input.la(1);
                                        }
                                        recog.base.set_state(2306);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        match recog.base.input.la(1) {
                                            NULL => {
                                                recog.base.set_state(2300);
                                                recog.base.match_token(
                                                    NULL,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2301);
                                                recog.base.match_token(
                                                    ON,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2302);
                                                recog.base.match_token(
                                                    NULL,
                                                    &mut recog.err_handler,
                                                )?;
                                            }

                                            ABSENT => {
                                                recog.base.set_state(2303);
                                                recog.base.match_token(
                                                    ABSENT,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2304);
                                                recog.base.match_token(
                                                    ON,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2305);
                                                recog.base.match_token(
                                                    NULL,
                                                    &mut recog.err_handler,
                                                )?;
                                            }

                                            T__2 | RETURNING | WITH | WITHOUT => {}

                                            _ => {}
                                        }
                                        recog.base.set_state(2318);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        match recog.base.input.la(1) {
                                            WITH => {
                                                recog.base.set_state(2308);
                                                recog.base.match_token(
                                                    WITH,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2309);
                                                recog.base.match_token(
                                                    UNIQUE,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2311);
                                                recog
                                                    .err_handler
                                                    .sync(&mut recog.base)?;
                                                _la = recog.base.input.la(1);
                                                if _la == KEYS {
                                                    {
                                                        recog.base.set_state(2310);
                                                        recog.base.match_token(
                                                            KEYS,
                                                            &mut recog.err_handler,
                                                        )?;
                                                    }
                                                }
                                            }

                                            WITHOUT => {
                                                recog.base.set_state(2313);
                                                recog.base.match_token(
                                                    WITHOUT,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2314);
                                                recog.base.match_token(
                                                    UNIQUE,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2316);
                                                recog
                                                    .err_handler
                                                    .sync(&mut recog.base)?;
                                                _la = recog.base.input.la(1);
                                                if _la == KEYS {
                                                    {
                                                        recog.base.set_state(2315);
                                                        recog.base.match_token(
                                                            KEYS,
                                                            &mut recog.err_handler,
                                                        )?;
                                                    }
                                                }
                                            }

                                            T__2 | RETURNING => {}

                                            _ => {}
                                        }
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2328);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == RETURNING {
                                {
                                    recog.base.set_state(2322);
                                    recog
                                        .base
                                        .match_token(RETURNING, &mut recog.err_handler)?;

                                    /*InvokeRule type_*/
                                    recog.base.set_state(2323);
                                    recog.type__rec(0)?;

                                    recog.base.set_state(2326);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == FORMAT {
                                        {
                                            recog.base.set_state(2324);
                                            recog.base.match_token(
                                                FORMAT,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule jsonRepresentation*/
                                            recog.base.set_state(2325);
                                            recog.jsonRepresentation()?;
                                        }
                                    }
                                }
                            }

                            recog.base.set_state(2330);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    47 => {
                        {
                            let mut tmp = JsonArrayContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2331);
                            recog.base.match_token(JSON_ARRAY, &mut recog.err_handler)?;

                            recog.base.set_state(2332);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            recog.base.set_state(2349);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(308, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        /*InvokeRule jsonValueExpression*/
                                        recog.base.set_state(2333);
                                        recog.jsonValueExpression()?;

                                        recog.base.set_state(2338);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        while _la == COMMA {
                                            {
                                                {
                                                    recog.base.set_state(2334);
                                                    recog.base.match_token(
                                                        COMMA,
                                                        &mut recog.err_handler,
                                                    )?;

                                                    /*InvokeRule jsonValueExpression*/
                                                    recog.base.set_state(2335);
                                                    recog.jsonValueExpression()?;
                                                }
                                            }
                                            recog.base.set_state(2340);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _la = recog.base.input.la(1);
                                        }
                                        recog.base.set_state(2347);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        match recog.base.input.la(1) {
                                            NULL => {
                                                recog.base.set_state(2341);
                                                recog.base.match_token(
                                                    NULL,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2342);
                                                recog.base.match_token(
                                                    ON,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2343);
                                                recog.base.match_token(
                                                    NULL,
                                                    &mut recog.err_handler,
                                                )?;
                                            }

                                            ABSENT => {
                                                recog.base.set_state(2344);
                                                recog.base.match_token(
                                                    ABSENT,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2345);
                                                recog.base.match_token(
                                                    ON,
                                                    &mut recog.err_handler,
                                                )?;

                                                recog.base.set_state(2346);
                                                recog.base.match_token(
                                                    NULL,
                                                    &mut recog.err_handler,
                                                )?;
                                            }

                                            T__2 | RETURNING => {}

                                            _ => {}
                                        }
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2357);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == RETURNING {
                                {
                                    recog.base.set_state(2351);
                                    recog
                                        .base
                                        .match_token(RETURNING, &mut recog.err_handler)?;

                                    /*InvokeRule type_*/
                                    recog.base.set_state(2352);
                                    recog.type__rec(0)?;

                                    recog.base.set_state(2355);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == FORMAT {
                                        {
                                            recog.base.set_state(2353);
                                            recog.base.match_token(
                                                FORMAT,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule jsonRepresentation*/
                                            recog.base.set_state(2354);
                                            recog.jsonRepresentation()?;
                                        }
                                    }
                                }
                            }

                            recog.base.set_state(2359);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(2372);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(313, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(2370);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(312, &mut recog.base)?
                            {
                                1 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = SubscriptContextExt::new(
                                            &**PrimaryExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        if let PrimaryExpressionContextAll::SubscriptContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut tmp){
								ctx.value = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_primaryExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(2362);
                                        if !({ recog.precpred(None, 24) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 24)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(2363);
                                        recog
                                            .base
                                            .match_token(T__6, &mut recog.err_handler)?;

                                        /*InvokeRule valueExpression*/
                                        recog.base.set_state(2364);
                                        let tmp = recog.valueExpression_rec(0)?;
                                        if let PrimaryExpressionContextAll::SubscriptContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.index = Some(tmp.clone()); } else {unreachable!("cant cast");}

                                        recog.base.set_state(2365);
                                        recog
                                            .base
                                            .match_token(T__7, &mut recog.err_handler)?;
                                    }
                                }
                                2 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = DereferenceContextExt::new(
                                            &**PrimaryExpressionContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        if let PrimaryExpressionContextAll::DereferenceContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut tmp){
								ctx.base_ = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_primaryExpression,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(2367);
                                        if !({ recog.precpred(None, 22) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 22)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(2368);
                                        recog
                                            .base
                                            .match_token(T__0, &mut recog.err_handler)?;

                                        /*InvokeRule identifier*/
                                        recog.base.set_state(2369);
                                        let tmp = recog.identifier()?;
                                        if let PrimaryExpressionContextAll::DereferenceContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.fieldName = Some(tmp.clone()); } else {unreachable!("cant cast");}
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(2374);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(313, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- jsonPathInvocation ----------------
pub type JsonPathInvocationContextAll<'input> = JsonPathInvocationContext<'input>;

pub type JsonPathInvocationContext<'input> =
    BaseParserRuleContext<'input, JsonPathInvocationContextExt<'input>>;

#[derive(Clone)]
pub struct JsonPathInvocationContextExt<'input> {
    pub path: Option<Rc<StringContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonPathInvocationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonPathInvocationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonPathInvocation(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonPathInvocation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonPathInvocationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonPathInvocation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonPathInvocation }
}
antlr_rust::tid! {JsonPathInvocationContextExt<'a>}

impl<'input> JsonPathInvocationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonPathInvocationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonPathInvocationContextExt {
                path: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait JsonPathInvocationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonPathInvocationContextExt<'input>>
{
    fn jsonValueExpression(&self) -> Option<Rc<JsonValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PASSING
    /// Returns `None` if there is no child corresponding to token PASSING
    fn PASSING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PASSING, 0)
    }
    fn jsonArgument_all(&self) -> Vec<Rc<JsonArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn jsonArgument(&self, i: usize) -> Option<Rc<JsonArgumentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> JsonPathInvocationContextAttrs<'input>
    for JsonPathInvocationContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonPathInvocation(
        &mut self,
    ) -> Result<Rc<JsonPathInvocationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JsonPathInvocationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 122, RULE_jsonPathInvocation);
        let mut _localctx: Rc<JsonPathInvocationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule jsonValueExpression*/
                recog.base.set_state(2375);
                recog.jsonValueExpression()?;

                recog.base.set_state(2376);
                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                /*InvokeRule string*/
                recog.base.set_state(2377);
                let tmp = recog.string()?;
                cast_mut::<_, JsonPathInvocationContext>(&mut _localctx).path =
                    Some(tmp.clone());

                recog.base.set_state(2387);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PASSING {
                    {
                        recog.base.set_state(2378);
                        recog.base.match_token(PASSING, &mut recog.err_handler)?;

                        /*InvokeRule jsonArgument*/
                        recog.base.set_state(2379);
                        recog.jsonArgument()?;

                        recog.base.set_state(2384);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(2380);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule jsonArgument*/
                                    recog.base.set_state(2381);
                                    recog.jsonArgument()?;
                                }
                            }
                            recog.base.set_state(2386);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonValueExpression ----------------
pub type JsonValueExpressionContextAll<'input> = JsonValueExpressionContext<'input>;

pub type JsonValueExpressionContext<'input> =
    BaseParserRuleContext<'input, JsonValueExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct JsonValueExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonValueExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonValueExpressionContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonValueExpression(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonValueExpression(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonValueExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonValueExpression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonValueExpression }
}
antlr_rust::tid! {JsonValueExpressionContextExt<'a>}

impl<'input> JsonValueExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonValueExpressionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonValueExpressionContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonValueExpressionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonValueExpressionContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FORMAT
    /// Returns `None` if there is no child corresponding to token FORMAT
    fn FORMAT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FORMAT, 0)
    }
    fn jsonRepresentation(&self) -> Option<Rc<JsonRepresentationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> JsonValueExpressionContextAttrs<'input>
    for JsonValueExpressionContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonValueExpression(
        &mut self,
    ) -> Result<Rc<JsonValueExpressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = JsonValueExpressionContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 124, RULE_jsonValueExpression);
        let mut _localctx: Rc<JsonValueExpressionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule expression*/
                recog.base.set_state(2389);
                recog.expression()?;

                recog.base.set_state(2392);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == FORMAT {
                    {
                        recog.base.set_state(2390);
                        recog.base.match_token(FORMAT, &mut recog.err_handler)?;

                        /*InvokeRule jsonRepresentation*/
                        recog.base.set_state(2391);
                        recog.jsonRepresentation()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonRepresentation ----------------
pub type JsonRepresentationContextAll<'input> = JsonRepresentationContext<'input>;

pub type JsonRepresentationContext<'input> =
    BaseParserRuleContext<'input, JsonRepresentationContextExt<'input>>;

#[derive(Clone)]
pub struct JsonRepresentationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonRepresentationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonRepresentationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonRepresentation(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonRepresentation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonRepresentationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonRepresentation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonRepresentation }
}
antlr_rust::tid! {JsonRepresentationContextExt<'a>}

impl<'input> JsonRepresentationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonRepresentationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonRepresentationContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonRepresentationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonRepresentationContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token JSON
    /// Returns `None` if there is no child corresponding to token JSON
    fn JSON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ENCODING
    /// Returns `None` if there is no child corresponding to token ENCODING
    fn ENCODING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ENCODING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UTF8
    /// Returns `None` if there is no child corresponding to token UTF8
    fn UTF8(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UTF8, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UTF16
    /// Returns `None` if there is no child corresponding to token UTF16
    fn UTF16(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UTF16, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UTF32
    /// Returns `None` if there is no child corresponding to token UTF32
    fn UTF32(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UTF32, 0)
    }
}

impl<'input> JsonRepresentationContextAttrs<'input>
    for JsonRepresentationContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonRepresentation(
        &mut self,
    ) -> Result<Rc<JsonRepresentationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JsonRepresentationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 126, RULE_jsonRepresentation);
        let mut _localctx: Rc<JsonRepresentationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2394);
                recog.base.match_token(JSON, &mut recog.err_handler)?;

                recog.base.set_state(2397);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == ENCODING {
                    {
                        recog.base.set_state(2395);
                        recog.base.match_token(ENCODING, &mut recog.err_handler)?;

                        recog.base.set_state(2396);
                        _la = recog.base.input.la(1);
                        if {
                            !(((_la - 271) & !0x3f) == 0
                                && ((1usize << (_la - 271))
                                    & ((1usize << (UTF16 - 271))
                                        | (1usize << (UTF32 - 271))
                                        | (1usize << (UTF8 - 271))))
                                    != 0)
                        } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonArgument ----------------
pub type JsonArgumentContextAll<'input> = JsonArgumentContext<'input>;

pub type JsonArgumentContext<'input> =
    BaseParserRuleContext<'input, JsonArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct JsonArgumentContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonArgument(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonArgument(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonArgument
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonArgument }
}
antlr_rust::tid! {JsonArgumentContextExt<'a>}

impl<'input> JsonArgumentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonArgumentContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonArgumentContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonArgumentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonArgumentContextExt<'input>>
{
    fn jsonValueExpression(&self) -> Option<Rc<JsonValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> JsonArgumentContextAttrs<'input> for JsonArgumentContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonArgument(
        &mut self,
    ) -> Result<Rc<JsonArgumentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JsonArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 128, RULE_jsonArgument);
        let mut _localctx: Rc<JsonArgumentContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule jsonValueExpression*/
                recog.base.set_state(2399);
                recog.jsonValueExpression()?;

                recog.base.set_state(2400);
                recog.base.match_token(AS, &mut recog.err_handler)?;

                /*InvokeRule identifier*/
                recog.base.set_state(2401);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonExistsErrorBehavior ----------------
pub type JsonExistsErrorBehaviorContextAll<'input> =
    JsonExistsErrorBehaviorContext<'input>;

pub type JsonExistsErrorBehaviorContext<'input> =
    BaseParserRuleContext<'input, JsonExistsErrorBehaviorContextExt<'input>>;

#[derive(Clone)]
pub struct JsonExistsErrorBehaviorContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonExistsErrorBehaviorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonExistsErrorBehaviorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonExistsErrorBehavior(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonExistsErrorBehavior(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonExistsErrorBehaviorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonExistsErrorBehavior
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonExistsErrorBehavior }
}
antlr_rust::tid! {JsonExistsErrorBehaviorContextExt<'a>}

impl<'input> JsonExistsErrorBehaviorContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonExistsErrorBehaviorContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonExistsErrorBehaviorContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonExistsErrorBehaviorContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonExistsErrorBehaviorContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token TRUE
    /// Returns `None` if there is no child corresponding to token TRUE
    fn TRUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FALSE
    /// Returns `None` if there is no child corresponding to token FALSE
    fn FALSE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FALSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNKNOWN
    /// Returns `None` if there is no child corresponding to token UNKNOWN
    fn UNKNOWN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNKNOWN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
}

impl<'input> JsonExistsErrorBehaviorContextAttrs<'input>
    for JsonExistsErrorBehaviorContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonExistsErrorBehavior(
        &mut self,
    ) -> Result<Rc<JsonExistsErrorBehaviorContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = JsonExistsErrorBehaviorContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 130, RULE_jsonExistsErrorBehavior);
        let mut _localctx: Rc<JsonExistsErrorBehaviorContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2403);
                _la = recog.base.input.la(1);
                if { !(_la == ERROR || _la == FALSE || _la == TRUE || _la == UNKNOWN) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonValueBehavior ----------------
pub type JsonValueBehaviorContextAll<'input> = JsonValueBehaviorContext<'input>;

pub type JsonValueBehaviorContext<'input> =
    BaseParserRuleContext<'input, JsonValueBehaviorContextExt<'input>>;

#[derive(Clone)]
pub struct JsonValueBehaviorContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonValueBehaviorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonValueBehaviorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonValueBehavior(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonValueBehavior(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonValueBehaviorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonValueBehavior
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonValueBehavior }
}
antlr_rust::tid! {JsonValueBehaviorContextExt<'a>}

impl<'input> JsonValueBehaviorContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonValueBehaviorContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonValueBehaviorContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonValueBehaviorContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonValueBehaviorContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DEFAULT
    /// Returns `None` if there is no child corresponding to token DEFAULT
    fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFAULT, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> JsonValueBehaviorContextAttrs<'input> for JsonValueBehaviorContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonValueBehavior(
        &mut self,
    ) -> Result<Rc<JsonValueBehaviorContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JsonValueBehaviorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 132, RULE_jsonValueBehavior);
        let mut _localctx: Rc<JsonValueBehaviorContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2409);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ERROR => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2405);
                        recog.base.match_token(ERROR, &mut recog.err_handler)?;
                    }
                }

                NULL => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2406);
                        recog.base.match_token(NULL, &mut recog.err_handler)?;
                    }
                }

                DEFAULT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(2407);
                        recog.base.match_token(DEFAULT, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(2408);
                        recog.expression()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonQueryWrapperBehavior ----------------
pub type JsonQueryWrapperBehaviorContextAll<'input> =
    JsonQueryWrapperBehaviorContext<'input>;

pub type JsonQueryWrapperBehaviorContext<'input> =
    BaseParserRuleContext<'input, JsonQueryWrapperBehaviorContextExt<'input>>;

#[derive(Clone)]
pub struct JsonQueryWrapperBehaviorContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonQueryWrapperBehaviorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonQueryWrapperBehaviorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonQueryWrapperBehavior(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonQueryWrapperBehavior(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonQueryWrapperBehaviorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonQueryWrapperBehavior
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonQueryWrapperBehavior }
}
antlr_rust::tid! {JsonQueryWrapperBehaviorContextExt<'a>}

impl<'input> JsonQueryWrapperBehaviorContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonQueryWrapperBehaviorContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonQueryWrapperBehaviorContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonQueryWrapperBehaviorContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonQueryWrapperBehaviorContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token WITHOUT
    /// Returns `None` if there is no child corresponding to token WITHOUT
    fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITHOUT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ARRAY
    /// Returns `None` if there is no child corresponding to token ARRAY
    fn ARRAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ARRAY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CONDITIONAL
    /// Returns `None` if there is no child corresponding to token CONDITIONAL
    fn CONDITIONAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CONDITIONAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNCONDITIONAL
    /// Returns `None` if there is no child corresponding to token UNCONDITIONAL
    fn UNCONDITIONAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNCONDITIONAL, 0)
    }
}

impl<'input> JsonQueryWrapperBehaviorContextAttrs<'input>
    for JsonQueryWrapperBehaviorContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonQueryWrapperBehavior(
        &mut self,
    ) -> Result<Rc<JsonQueryWrapperBehaviorContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = JsonQueryWrapperBehaviorContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 134, RULE_jsonQueryWrapperBehavior);
        let mut _localctx: Rc<JsonQueryWrapperBehaviorContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2422);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                WITHOUT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2411);
                        recog.base.match_token(WITHOUT, &mut recog.err_handler)?;

                        recog.base.set_state(2413);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == ARRAY {
                            {
                                recog.base.set_state(2412);
                                recog.base.match_token(ARRAY, &mut recog.err_handler)?;
                            }
                        }
                    }
                }

                WITH => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2415);
                        recog.base.match_token(WITH, &mut recog.err_handler)?;

                        recog.base.set_state(2417);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == CONDITIONAL || _la == UNCONDITIONAL {
                            {
                                recog.base.set_state(2416);
                                _la = recog.base.input.la(1);
                                if { !(_la == CONDITIONAL || _la == UNCONDITIONAL) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                } else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                            }
                        }

                        recog.base.set_state(2420);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == ARRAY {
                            {
                                recog.base.set_state(2419);
                                recog.base.match_token(ARRAY, &mut recog.err_handler)?;
                            }
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonQueryBehavior ----------------
pub type JsonQueryBehaviorContextAll<'input> = JsonQueryBehaviorContext<'input>;

pub type JsonQueryBehaviorContext<'input> =
    BaseParserRuleContext<'input, JsonQueryBehaviorContextExt<'input>>;

#[derive(Clone)]
pub struct JsonQueryBehaviorContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonQueryBehaviorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonQueryBehaviorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonQueryBehavior(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonQueryBehavior(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonQueryBehaviorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonQueryBehavior
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonQueryBehavior }
}
antlr_rust::tid! {JsonQueryBehaviorContextExt<'a>}

impl<'input> JsonQueryBehaviorContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonQueryBehaviorContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonQueryBehaviorContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonQueryBehaviorContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonQueryBehaviorContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULL
    /// Returns `None` if there is no child corresponding to token NULL
    fn NULL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EMPTY
    /// Returns `None` if there is no child corresponding to token EMPTY
    fn EMPTY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EMPTY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ARRAY
    /// Returns `None` if there is no child corresponding to token ARRAY
    fn ARRAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ARRAY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OBJECT
    /// Returns `None` if there is no child corresponding to token OBJECT
    fn OBJECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OBJECT, 0)
    }
}

impl<'input> JsonQueryBehaviorContextAttrs<'input> for JsonQueryBehaviorContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonQueryBehavior(
        &mut self,
    ) -> Result<Rc<JsonQueryBehaviorContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JsonQueryBehaviorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 136, RULE_jsonQueryBehavior);
        let mut _localctx: Rc<JsonQueryBehaviorContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2430);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(323, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2424);
                        recog.base.match_token(ERROR, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2425);
                        recog.base.match_token(NULL, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(2426);
                        recog.base.match_token(EMPTY, &mut recog.err_handler)?;

                        recog.base.set_state(2427);
                        recog.base.match_token(ARRAY, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(2428);
                        recog.base.match_token(EMPTY, &mut recog.err_handler)?;

                        recog.base.set_state(2429);
                        recog.base.match_token(OBJECT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- jsonObjectMember ----------------
pub type JsonObjectMemberContextAll<'input> = JsonObjectMemberContext<'input>;

pub type JsonObjectMemberContext<'input> =
    BaseParserRuleContext<'input, JsonObjectMemberContextExt<'input>>;

#[derive(Clone)]
pub struct JsonObjectMemberContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for JsonObjectMemberContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for JsonObjectMemberContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_jsonObjectMember(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_jsonObjectMember(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for JsonObjectMemberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_jsonObjectMember
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_jsonObjectMember }
}
antlr_rust::tid! {JsonObjectMemberContextExt<'a>}

impl<'input> JsonObjectMemberContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<JsonObjectMemberContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            JsonObjectMemberContextExt { ph: PhantomData },
        ))
    }
}

pub trait JsonObjectMemberContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<JsonObjectMemberContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token VALUE
    /// Returns `None` if there is no child corresponding to token VALUE
    fn VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VALUE, 0)
    }
    fn jsonValueExpression(&self) -> Option<Rc<JsonValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KEY
    /// Returns `None` if there is no child corresponding to token KEY
    fn KEY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KEY, 0)
    }
}

impl<'input> JsonObjectMemberContextAttrs<'input> for JsonObjectMemberContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn jsonObjectMember(
        &mut self,
    ) -> Result<Rc<JsonObjectMemberContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            JsonObjectMemberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 138, RULE_jsonObjectMember);
        let mut _localctx: Rc<JsonObjectMemberContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2443);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(325, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2433);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(324, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2432);
                                recog.base.match_token(KEY, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        /*InvokeRule expression*/
                        recog.base.set_state(2435);
                        recog.expression()?;

                        recog.base.set_state(2436);
                        recog.base.match_token(VALUE, &mut recog.err_handler)?;

                        /*InvokeRule jsonValueExpression*/
                        recog.base.set_state(2437);
                        recog.jsonValueExpression()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /*InvokeRule expression*/
                        recog.base.set_state(2439);
                        recog.expression()?;

                        recog.base.set_state(2440);
                        recog.base.match_token(T__8, &mut recog.err_handler)?;

                        /*InvokeRule jsonValueExpression*/
                        recog.base.set_state(2441);
                        recog.jsonValueExpression()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- processingMode ----------------
pub type ProcessingModeContextAll<'input> = ProcessingModeContext<'input>;

pub type ProcessingModeContext<'input> =
    BaseParserRuleContext<'input, ProcessingModeContextExt<'input>>;

#[derive(Clone)]
pub struct ProcessingModeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ProcessingModeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ProcessingModeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_processingMode(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_processingMode(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ProcessingModeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_processingMode
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_processingMode }
}
antlr_rust::tid! {ProcessingModeContextExt<'a>}

impl<'input> ProcessingModeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ProcessingModeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ProcessingModeContextExt { ph: PhantomData },
        ))
    }
}

pub trait ProcessingModeContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ProcessingModeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token RUNNING
    /// Returns `None` if there is no child corresponding to token RUNNING
    fn RUNNING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RUNNING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FINAL
    /// Returns `None` if there is no child corresponding to token FINAL
    fn FINAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FINAL, 0)
    }
}

impl<'input> ProcessingModeContextAttrs<'input> for ProcessingModeContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn processingMode(
        &mut self,
    ) -> Result<Rc<ProcessingModeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            ProcessingModeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 140, RULE_processingMode);
        let mut _localctx: Rc<ProcessingModeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2445);
                _la = recog.base.input.la(1);
                if { !(_la == FINAL || _la == RUNNING) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- nullTreatment ----------------
pub type NullTreatmentContextAll<'input> = NullTreatmentContext<'input>;

pub type NullTreatmentContext<'input> =
    BaseParserRuleContext<'input, NullTreatmentContextExt<'input>>;

#[derive(Clone)]
pub struct NullTreatmentContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for NullTreatmentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NullTreatmentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_nullTreatment(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_nullTreatment(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for NullTreatmentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_nullTreatment
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_nullTreatment }
}
antlr_rust::tid! {NullTreatmentContextExt<'a>}

impl<'input> NullTreatmentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NullTreatmentContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            NullTreatmentContextExt { ph: PhantomData },
        ))
    }
}

pub trait NullTreatmentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<NullTreatmentContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token IGNORE
    /// Returns `None` if there is no child corresponding to token IGNORE
    fn IGNORE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IGNORE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULLS
    /// Returns `None` if there is no child corresponding to token NULLS
    fn NULLS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULLS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESPECT
    /// Returns `None` if there is no child corresponding to token RESPECT
    fn RESPECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESPECT, 0)
    }
}

impl<'input> NullTreatmentContextAttrs<'input> for NullTreatmentContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn nullTreatment(
        &mut self,
    ) -> Result<Rc<NullTreatmentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            NullTreatmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 142, RULE_nullTreatment);
        let mut _localctx: Rc<NullTreatmentContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2451);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                IGNORE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2447);
                        recog.base.match_token(IGNORE, &mut recog.err_handler)?;

                        recog.base.set_state(2448);
                        recog.base.match_token(NULLS, &mut recog.err_handler)?;
                    }
                }

                RESPECT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2449);
                        recog.base.match_token(RESPECT, &mut recog.err_handler)?;

                        recog.base.set_state(2450);
                        recog.base.match_token(NULLS, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string ----------------
#[derive(Debug)]
pub enum StringContextAll<'input> {
    UnicodeStringLiteralContext(UnicodeStringLiteralContext<'input>),
    BasicStringLiteralContext(BasicStringLiteralContext<'input>),
    Error(StringContext<'input>),
}
antlr_rust::tid! {StringContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for StringContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for StringContextAll<'input> {}

impl<'input> Deref for StringContextAll<'input> {
    type Target = dyn StringContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use StringContextAll::*;
        match self {
            UnicodeStringLiteralContext(inner) => inner,
            BasicStringLiteralContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for StringContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type StringContext<'input> = BaseParserRuleContext<'input, StringContextExt<'input>>;

#[derive(Clone)]
pub struct StringContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for StringContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for StringContext<'input> {}

impl<'input> CustomRuleContext<'input> for StringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string }
}
antlr_rust::tid! {StringContextExt<'a>}

impl<'input> StringContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StringContextAll<'input>> {
        Rc::new(StringContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                StringContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait StringContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<StringContextExt<'input>>
{
}

impl<'input> StringContextAttrs<'input> for StringContext<'input> {}

pub type UnicodeStringLiteralContext<'input> =
    BaseParserRuleContext<'input, UnicodeStringLiteralContextExt<'input>>;

pub trait UnicodeStringLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token UNICODE_STRING
    /// Returns `None` if there is no child corresponding to token UNICODE_STRING
    fn UNICODE_STRING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNICODE_STRING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UESCAPE
    /// Returns `None` if there is no child corresponding to token UESCAPE
    fn UESCAPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UESCAPE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING
    /// Returns `None` if there is no child corresponding to token STRING
    fn STRING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING, 0)
    }
}

impl<'input> UnicodeStringLiteralContextAttrs<'input>
    for UnicodeStringLiteralContext<'input>
{
}

pub struct UnicodeStringLiteralContextExt<'input> {
    base: StringContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UnicodeStringLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UnicodeStringLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for UnicodeStringLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_unicodeStringLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for UnicodeStringLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string }
}

impl<'input> Borrow<StringContextExt<'input>> for UnicodeStringLiteralContext<'input> {
    fn borrow(&self) -> &StringContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StringContextExt<'input>> for UnicodeStringLiteralContext<'input> {
    fn borrow_mut(&mut self) -> &mut StringContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StringContextAttrs<'input> for UnicodeStringLiteralContext<'input> {}

impl<'input> UnicodeStringLiteralContextExt<'input> {
    fn new(ctx: &dyn StringContextAttrs<'input>) -> Rc<StringContextAll<'input>> {
        Rc::new(StringContextAll::UnicodeStringLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UnicodeStringLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type BasicStringLiteralContext<'input> =
    BaseParserRuleContext<'input, BasicStringLiteralContextExt<'input>>;

pub trait BasicStringLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token STRING
    /// Returns `None` if there is no child corresponding to token STRING
    fn STRING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING, 0)
    }
}

impl<'input> BasicStringLiteralContextAttrs<'input>
    for BasicStringLiteralContext<'input>
{
}

pub struct BasicStringLiteralContextExt<'input> {
    base: StringContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {BasicStringLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for BasicStringLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BasicStringLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_basicStringLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for BasicStringLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string }
}

impl<'input> Borrow<StringContextExt<'input>> for BasicStringLiteralContext<'input> {
    fn borrow(&self) -> &StringContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<StringContextExt<'input>> for BasicStringLiteralContext<'input> {
    fn borrow_mut(&mut self) -> &mut StringContextExt<'input> {
        &mut self.base
    }
}

impl<'input> StringContextAttrs<'input> for BasicStringLiteralContext<'input> {}

impl<'input> BasicStringLiteralContextExt<'input> {
    fn new(ctx: &dyn StringContextAttrs<'input>) -> Rc<StringContextAll<'input>> {
        Rc::new(StringContextAll::BasicStringLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                BasicStringLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string(&mut self) -> Result<Rc<StringContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            StringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_string);
        let mut _localctx: Rc<StringContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2459);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                STRING => {
                    let tmp = BasicStringLiteralContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2453);
                        recog.base.match_token(STRING, &mut recog.err_handler)?;
                    }
                }

                UNICODE_STRING => {
                    let tmp = UnicodeStringLiteralContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2454);
                        recog
                            .base
                            .match_token(UNICODE_STRING, &mut recog.err_handler)?;

                        recog.base.set_state(2457);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(327, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2455);
                                recog
                                    .base
                                    .match_token(UESCAPE, &mut recog.err_handler)?;

                                recog.base.set_state(2456);
                                recog.base.match_token(STRING, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- timeZoneSpecifier ----------------
#[derive(Debug)]
pub enum TimeZoneSpecifierContextAll<'input> {
    TimeZoneIntervalContext(TimeZoneIntervalContext<'input>),
    TimeZoneStringContext(TimeZoneStringContext<'input>),
    Error(TimeZoneSpecifierContext<'input>),
}
antlr_rust::tid! {TimeZoneSpecifierContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for TimeZoneSpecifierContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for TimeZoneSpecifierContextAll<'input> {}

impl<'input> Deref for TimeZoneSpecifierContextAll<'input> {
    type Target = dyn TimeZoneSpecifierContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use TimeZoneSpecifierContextAll::*;
        match self {
            TimeZoneIntervalContext(inner) => inner,
            TimeZoneStringContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TimeZoneSpecifierContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type TimeZoneSpecifierContext<'input> =
    BaseParserRuleContext<'input, TimeZoneSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct TimeZoneSpecifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TimeZoneSpecifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TimeZoneSpecifierContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for TimeZoneSpecifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_timeZoneSpecifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_timeZoneSpecifier }
}
antlr_rust::tid! {TimeZoneSpecifierContextExt<'a>}

impl<'input> TimeZoneSpecifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TimeZoneSpecifierContextAll<'input>> {
        Rc::new(TimeZoneSpecifierContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                TimeZoneSpecifierContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait TimeZoneSpecifierContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TimeZoneSpecifierContextExt<'input>>
{
}

impl<'input> TimeZoneSpecifierContextAttrs<'input> for TimeZoneSpecifierContext<'input> {}

pub type TimeZoneIntervalContext<'input> =
    BaseParserRuleContext<'input, TimeZoneIntervalContextExt<'input>>;

pub trait TimeZoneIntervalContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TIME
    /// Returns `None` if there is no child corresponding to token TIME
    fn TIME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ZONE
    /// Returns `None` if there is no child corresponding to token ZONE
    fn ZONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ZONE, 0)
    }
    fn interval(&self) -> Option<Rc<IntervalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TimeZoneIntervalContextAttrs<'input> for TimeZoneIntervalContext<'input> {}

pub struct TimeZoneIntervalContextExt<'input> {
    base: TimeZoneSpecifierContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TimeZoneIntervalContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TimeZoneIntervalContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TimeZoneIntervalContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_timeZoneInterval(self);
    }
}

impl<'input> CustomRuleContext<'input> for TimeZoneIntervalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_timeZoneSpecifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_timeZoneSpecifier }
}

impl<'input> Borrow<TimeZoneSpecifierContextExt<'input>>
    for TimeZoneIntervalContext<'input>
{
    fn borrow(&self) -> &TimeZoneSpecifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<TimeZoneSpecifierContextExt<'input>>
    for TimeZoneIntervalContext<'input>
{
    fn borrow_mut(&mut self) -> &mut TimeZoneSpecifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> TimeZoneSpecifierContextAttrs<'input> for TimeZoneIntervalContext<'input> {}

impl<'input> TimeZoneIntervalContextExt<'input> {
    fn new(
        ctx: &dyn TimeZoneSpecifierContextAttrs<'input>,
    ) -> Rc<TimeZoneSpecifierContextAll<'input>> {
        Rc::new(TimeZoneSpecifierContextAll::TimeZoneIntervalContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TimeZoneIntervalContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type TimeZoneStringContext<'input> =
    BaseParserRuleContext<'input, TimeZoneStringContextExt<'input>>;

pub trait TimeZoneStringContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TIME
    /// Returns `None` if there is no child corresponding to token TIME
    fn TIME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ZONE
    /// Returns `None` if there is no child corresponding to token ZONE
    fn ZONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ZONE, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TimeZoneStringContextAttrs<'input> for TimeZoneStringContext<'input> {}

pub struct TimeZoneStringContextExt<'input> {
    base: TimeZoneSpecifierContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TimeZoneStringContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TimeZoneStringContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TimeZoneStringContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_timeZoneString(self);
    }
}

impl<'input> CustomRuleContext<'input> for TimeZoneStringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_timeZoneSpecifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_timeZoneSpecifier }
}

impl<'input> Borrow<TimeZoneSpecifierContextExt<'input>>
    for TimeZoneStringContext<'input>
{
    fn borrow(&self) -> &TimeZoneSpecifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<TimeZoneSpecifierContextExt<'input>>
    for TimeZoneStringContext<'input>
{
    fn borrow_mut(&mut self) -> &mut TimeZoneSpecifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> TimeZoneSpecifierContextAttrs<'input> for TimeZoneStringContext<'input> {}

impl<'input> TimeZoneStringContextExt<'input> {
    fn new(
        ctx: &dyn TimeZoneSpecifierContextAttrs<'input>,
    ) -> Rc<TimeZoneSpecifierContextAll<'input>> {
        Rc::new(TimeZoneSpecifierContextAll::TimeZoneStringContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TimeZoneStringContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn timeZoneSpecifier(
        &mut self,
    ) -> Result<Rc<TimeZoneSpecifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            TimeZoneSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 146, RULE_timeZoneSpecifier);
        let mut _localctx: Rc<TimeZoneSpecifierContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2467);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(329, &mut recog.base)? {
                1 => {
                    let tmp = TimeZoneIntervalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2461);
                        recog.base.match_token(TIME, &mut recog.err_handler)?;

                        recog.base.set_state(2462);
                        recog.base.match_token(ZONE, &mut recog.err_handler)?;

                        /*InvokeRule interval*/
                        recog.base.set_state(2463);
                        recog.interval()?;
                    }
                }
                2 => {
                    let tmp = TimeZoneStringContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2464);
                        recog.base.match_token(TIME, &mut recog.err_handler)?;

                        recog.base.set_state(2465);
                        recog.base.match_token(ZONE, &mut recog.err_handler)?;

                        /*InvokeRule string*/
                        recog.base.set_state(2466);
                        recog.string()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- comparisonOperator ----------------
pub type ComparisonOperatorContextAll<'input> = ComparisonOperatorContext<'input>;

pub type ComparisonOperatorContext<'input> =
    BaseParserRuleContext<'input, ComparisonOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonOperatorContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ComparisonOperatorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ComparisonOperatorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_comparisonOperator(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_comparisonOperator(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ComparisonOperatorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_comparisonOperator
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_comparisonOperator }
}
antlr_rust::tid! {ComparisonOperatorContextExt<'a>}

impl<'input> ComparisonOperatorContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ComparisonOperatorContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ComparisonOperatorContextExt { ph: PhantomData },
        ))
    }
}

pub trait ComparisonOperatorContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ComparisonOperatorContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token EQ
    /// Returns `None` if there is no child corresponding to token EQ
    fn EQ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NEQ
    /// Returns `None` if there is no child corresponding to token NEQ
    fn NEQ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LT
    /// Returns `None` if there is no child corresponding to token LT
    fn LT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LTE
    /// Returns `None` if there is no child corresponding to token LTE
    fn LTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LTE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GT
    /// Returns `None` if there is no child corresponding to token GT
    fn GT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GTE
    /// Returns `None` if there is no child corresponding to token GTE
    fn GTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GTE, 0)
    }
}

impl<'input> ComparisonOperatorContextAttrs<'input>
    for ComparisonOperatorContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn comparisonOperator(
        &mut self,
    ) -> Result<Rc<ComparisonOperatorContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            ComparisonOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 148, RULE_comparisonOperator);
        let mut _localctx: Rc<ComparisonOperatorContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2469);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 291) & !0x3f) == 0
                        && ((1usize << (_la - 291))
                            & ((1usize << (EQ - 291))
                                | (1usize << (NEQ - 291))
                                | (1usize << (LT - 291))
                                | (1usize << (LTE - 291))
                                | (1usize << (GT - 291))
                                | (1usize << (GTE - 291))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- comparisonQuantifier ----------------
pub type ComparisonQuantifierContextAll<'input> = ComparisonQuantifierContext<'input>;

pub type ComparisonQuantifierContext<'input> =
    BaseParserRuleContext<'input, ComparisonQuantifierContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonQuantifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ComparisonQuantifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ComparisonQuantifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_comparisonQuantifier(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_comparisonQuantifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for ComparisonQuantifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_comparisonQuantifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_comparisonQuantifier }
}
antlr_rust::tid! {ComparisonQuantifierContextExt<'a>}

impl<'input> ComparisonQuantifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ComparisonQuantifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ComparisonQuantifierContextExt { ph: PhantomData },
        ))
    }
}

pub trait ComparisonQuantifierContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ComparisonQuantifierContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SOME
    /// Returns `None` if there is no child corresponding to token SOME
    fn SOME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SOME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ANY
    /// Returns `None` if there is no child corresponding to token ANY
    fn ANY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ANY, 0)
    }
}

impl<'input> ComparisonQuantifierContextAttrs<'input>
    for ComparisonQuantifierContext<'input>
{
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn comparisonQuantifier(
        &mut self,
    ) -> Result<Rc<ComparisonQuantifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ComparisonQuantifierContextExt::new(
            _parentctx.clone(),
            recog.base.get_state(),
        );
        recog
            .base
            .enter_rule(_localctx.clone(), 150, RULE_comparisonQuantifier);
        let mut _localctx: Rc<ComparisonQuantifierContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2471);
                _la = recog.base.input.la(1);
                if { !(_la == ALL || _la == ANY || _la == SOME) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- booleanValue ----------------
pub type BooleanValueContextAll<'input> = BooleanValueContext<'input>;

pub type BooleanValueContext<'input> =
    BaseParserRuleContext<'input, BooleanValueContextExt<'input>>;

#[derive(Clone)]
pub struct BooleanValueContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for BooleanValueContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BooleanValueContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_booleanValue(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_booleanValue(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for BooleanValueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_booleanValue
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_booleanValue }
}
antlr_rust::tid! {BooleanValueContextExt<'a>}

impl<'input> BooleanValueContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<BooleanValueContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            BooleanValueContextExt { ph: PhantomData },
        ))
    }
}

pub trait BooleanValueContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<BooleanValueContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token TRUE
    /// Returns `None` if there is no child corresponding to token TRUE
    fn TRUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FALSE
    /// Returns `None` if there is no child corresponding to token FALSE
    fn FALSE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FALSE, 0)
    }
}

impl<'input> BooleanValueContextAttrs<'input> for BooleanValueContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn booleanValue(
        &mut self,
    ) -> Result<Rc<BooleanValueContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            BooleanValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 152, RULE_booleanValue);
        let mut _localctx: Rc<BooleanValueContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2473);
                _la = recog.base.input.la(1);
                if { !(_la == FALSE || _la == TRUE) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- interval ----------------
pub type IntervalContextAll<'input> = IntervalContext<'input>;

pub type IntervalContext<'input> =
    BaseParserRuleContext<'input, IntervalContextExt<'input>>;

#[derive(Clone)]
pub struct IntervalContextExt<'input> {
    pub sign: Option<TokenType<'input>>,
    pub from: Option<Rc<IntervalFieldContextAll<'input>>>,
    pub to: Option<Rc<IntervalFieldContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for IntervalContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for IntervalContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_interval(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_interval(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for IntervalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_interval
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_interval }
}
antlr_rust::tid! {IntervalContextExt<'a>}

impl<'input> IntervalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<IntervalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            IntervalContextExt {
                sign: None,
                from: None,
                to: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait IntervalContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<IntervalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token INTERVAL
    /// Returns `None` if there is no child corresponding to token INTERVAL
    fn INTERVAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTERVAL, 0)
    }
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn intervalField_all(&self) -> Vec<Rc<IntervalFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn intervalField(&self, i: usize) -> Option<Rc<IntervalFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PLUS
    /// Returns `None` if there is no child corresponding to token PLUS
    fn PLUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PLUS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUS
    /// Returns `None` if there is no child corresponding to token MINUS
    fn MINUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUS, 0)
    }
}

impl<'input> IntervalContextAttrs<'input> for IntervalContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn interval(&mut self) -> Result<Rc<IntervalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            IntervalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_interval);
        let mut _localctx: Rc<IntervalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2475);
                recog.base.match_token(INTERVAL, &mut recog.err_handler)?;

                recog.base.set_state(2477);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PLUS || _la == MINUS {
                    {
                        recog.base.set_state(2476);
                        cast_mut::<_, IntervalContext>(&mut _localctx).sign =
                            recog.base.input.lt(1).cloned();

                        _la = recog.base.input.la(1);
                        if { !(_la == PLUS || _la == MINUS) } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            cast_mut::<_, IntervalContext>(&mut _localctx).sign =
                                Some(&tmp);
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                /*InvokeRule string*/
                recog.base.set_state(2479);
                recog.string()?;

                /*InvokeRule intervalField*/
                recog.base.set_state(2480);
                let tmp = recog.intervalField()?;
                cast_mut::<_, IntervalContext>(&mut _localctx).from = Some(tmp.clone());

                recog.base.set_state(2483);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(331, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(2481);
                            recog.base.match_token(TO, &mut recog.err_handler)?;

                            /*InvokeRule intervalField*/
                            recog.base.set_state(2482);
                            let tmp = recog.intervalField()?;
                            cast_mut::<_, IntervalContext>(&mut _localctx).to =
                                Some(tmp.clone());
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- intervalField ----------------
pub type IntervalFieldContextAll<'input> = IntervalFieldContext<'input>;

pub type IntervalFieldContext<'input> =
    BaseParserRuleContext<'input, IntervalFieldContextExt<'input>>;

#[derive(Clone)]
pub struct IntervalFieldContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for IntervalFieldContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for IntervalFieldContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_intervalField(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_intervalField(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for IntervalFieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_intervalField
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_intervalField }
}
antlr_rust::tid! {IntervalFieldContextExt<'a>}

impl<'input> IntervalFieldContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<IntervalFieldContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            IntervalFieldContextExt { ph: PhantomData },
        ))
    }
}

pub trait IntervalFieldContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<IntervalFieldContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token YEAR
    /// Returns `None` if there is no child corresponding to token YEAR
    fn YEAR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YEAR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MONTH
    /// Returns `None` if there is no child corresponding to token MONTH
    fn MONTH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MONTH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DAY
    /// Returns `None` if there is no child corresponding to token DAY
    fn DAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DAY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token HOUR
    /// Returns `None` if there is no child corresponding to token HOUR
    fn HOUR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(HOUR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUTE
    /// Returns `None` if there is no child corresponding to token MINUTE
    fn MINUTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUTE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SECOND
    /// Returns `None` if there is no child corresponding to token SECOND
    fn SECOND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SECOND, 0)
    }
}

impl<'input> IntervalFieldContextAttrs<'input> for IntervalFieldContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn intervalField(
        &mut self,
    ) -> Result<Rc<IntervalFieldContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            IntervalFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 156, RULE_intervalField);
        let mut _localctx: Rc<IntervalFieldContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2485);
                _la = recog.base.input.la(1);
                if {
                    !(_la == DAY
                        || _la == HOUR
                        || _la == MINUTE
                        || _la == MONTH
                        || _la == SECOND
                        || _la == YEAR)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- normalForm ----------------
pub type NormalFormContextAll<'input> = NormalFormContext<'input>;

pub type NormalFormContext<'input> =
    BaseParserRuleContext<'input, NormalFormContextExt<'input>>;

#[derive(Clone)]
pub struct NormalFormContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for NormalFormContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NormalFormContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_normalForm(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_normalForm(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for NormalFormContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_normalForm
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_normalForm }
}
antlr_rust::tid! {NormalFormContextExt<'a>}

impl<'input> NormalFormContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NormalFormContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            NormalFormContextExt { ph: PhantomData },
        ))
    }
}

pub trait NormalFormContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<NormalFormContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token NFD
    /// Returns `None` if there is no child corresponding to token NFD
    fn NFD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NFC
    /// Returns `None` if there is no child corresponding to token NFC
    fn NFC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NFKD
    /// Returns `None` if there is no child corresponding to token NFKD
    fn NFKD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFKD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NFKC
    /// Returns `None` if there is no child corresponding to token NFKC
    fn NFKC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFKC, 0)
    }
}

impl<'input> NormalFormContextAttrs<'input> for NormalFormContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn normalForm(&mut self) -> Result<Rc<NormalFormContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            NormalFormContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 158, RULE_normalForm);
        let mut _localctx: Rc<NormalFormContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2487);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 160) & !0x3f) == 0
                        && ((1usize << (_la - 160))
                            & ((1usize << (NFC - 160))
                                | (1usize << (NFD - 160))
                                | (1usize << (NFKC - 160))
                                | (1usize << (NFKD - 160))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- type_ ----------------
#[derive(Debug)]
pub enum Type_ContextAll<'input> {
    RowTypeContext(RowTypeContext<'input>),
    IntervalTypeContext(IntervalTypeContext<'input>),
    ArrayTypeContext(ArrayTypeContext<'input>),
    DoublePrecisionTypeContext(DoublePrecisionTypeContext<'input>),
    LegacyArrayTypeContext(LegacyArrayTypeContext<'input>),
    GenericTypeContext(GenericTypeContext<'input>),
    DateTimeTypeContext(DateTimeTypeContext<'input>),
    LegacyMapTypeContext(LegacyMapTypeContext<'input>),
    Error(Type_Context<'input>),
}
antlr_rust::tid! {Type_ContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Type_ContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for Type_ContextAll<'input> {}

impl<'input> Deref for Type_ContextAll<'input> {
    type Target = dyn Type_ContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Type_ContextAll::*;
        match self {
            RowTypeContext(inner) => inner,
            IntervalTypeContext(inner) => inner,
            ArrayTypeContext(inner) => inner,
            DoublePrecisionTypeContext(inner) => inner,
            LegacyArrayTypeContext(inner) => inner,
            GenericTypeContext(inner) => inner,
            DateTimeTypeContext(inner) => inner,
            LegacyMapTypeContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for Type_ContextAll<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Type_Context<'input> = BaseParserRuleContext<'input, Type_ContextExt<'input>>;

#[derive(Clone)]
pub struct Type_ContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for Type_Context<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for Type_Context<'input> {}

impl<'input> CustomRuleContext<'input> for Type_ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}
antlr_rust::tid! {Type_ContextExt<'a>}

impl<'input> Type_ContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                Type_ContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait Type_ContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<Type_ContextExt<'input>>
{
}

impl<'input> Type_ContextAttrs<'input> for Type_Context<'input> {}

pub type RowTypeContext<'input> =
    BaseParserRuleContext<'input, RowTypeContextExt<'input>>;

pub trait RowTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ROW
    /// Returns `None` if there is no child corresponding to token ROW
    fn ROW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROW, 0)
    }
    fn rowField_all(&self) -> Vec<Rc<RowFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn rowField(&self, i: usize) -> Option<Rc<RowFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> RowTypeContextAttrs<'input> for RowTypeContext<'input> {}

pub struct RowTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RowTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RowTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RowTypeContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rowType(self);
    }
}

impl<'input> CustomRuleContext<'input> for RowTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for RowTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for RowTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for RowTypeContext<'input> {}

impl<'input> RowTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::RowTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RowTypeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type IntervalTypeContext<'input> =
    BaseParserRuleContext<'input, IntervalTypeContextExt<'input>>;

pub trait IntervalTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token INTERVAL
    /// Returns `None` if there is no child corresponding to token INTERVAL
    fn INTERVAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTERVAL, 0)
    }
    fn intervalField_all(&self) -> Vec<Rc<IntervalFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn intervalField(&self, i: usize) -> Option<Rc<IntervalFieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
}

impl<'input> IntervalTypeContextAttrs<'input> for IntervalTypeContext<'input> {}

pub struct IntervalTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    pub from: Option<Rc<IntervalFieldContextAll<'input>>>,
    pub to: Option<Rc<IntervalFieldContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IntervalTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for IntervalTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for IntervalTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_intervalType(self);
    }
}

impl<'input> CustomRuleContext<'input> for IntervalTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for IntervalTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for IntervalTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for IntervalTypeContext<'input> {}

impl<'input> IntervalTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::IntervalTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                IntervalTypeContextExt {
                    from: None,
                    to: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ArrayTypeContext<'input> =
    BaseParserRuleContext<'input, ArrayTypeContextExt<'input>>;

pub trait ArrayTypeContextAttrs<'input>: PrestoParserContext<'input> {
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token ARRAY
    /// Returns `None` if there is no child corresponding to token ARRAY
    fn ARRAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ARRAY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
    /// Returns `None` if there is no child corresponding to token INTEGER_VALUE
    fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER_VALUE, 0)
    }
}

impl<'input> ArrayTypeContextAttrs<'input> for ArrayTypeContext<'input> {}

pub struct ArrayTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ArrayTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ArrayTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ArrayTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_arrayType(self);
    }
}

impl<'input> CustomRuleContext<'input> for ArrayTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for ArrayTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for ArrayTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for ArrayTypeContext<'input> {}

impl<'input> ArrayTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::ArrayTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ArrayTypeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DoublePrecisionTypeContext<'input> =
    BaseParserRuleContext<'input, DoublePrecisionTypeContextExt<'input>>;

pub trait DoublePrecisionTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DOUBLE
    /// Returns `None` if there is no child corresponding to token DOUBLE
    fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOUBLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRECISION
    /// Returns `None` if there is no child corresponding to token PRECISION
    fn PRECISION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRECISION, 0)
    }
}

impl<'input> DoublePrecisionTypeContextAttrs<'input>
    for DoublePrecisionTypeContext<'input>
{
}

pub struct DoublePrecisionTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DoublePrecisionTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DoublePrecisionTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DoublePrecisionTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_doublePrecisionType(self);
    }
}

impl<'input> CustomRuleContext<'input> for DoublePrecisionTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for DoublePrecisionTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for DoublePrecisionTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for DoublePrecisionTypeContext<'input> {}

impl<'input> DoublePrecisionTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::DoublePrecisionTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DoublePrecisionTypeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type LegacyArrayTypeContext<'input> =
    BaseParserRuleContext<'input, LegacyArrayTypeContextExt<'input>>;

pub trait LegacyArrayTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ARRAY
    /// Returns `None` if there is no child corresponding to token ARRAY
    fn ARRAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ARRAY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LT
    /// Returns `None` if there is no child corresponding to token LT
    fn LT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LT, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token GT
    /// Returns `None` if there is no child corresponding to token GT
    fn GT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GT, 0)
    }
}

impl<'input> LegacyArrayTypeContextAttrs<'input> for LegacyArrayTypeContext<'input> {}

pub struct LegacyArrayTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {LegacyArrayTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for LegacyArrayTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for LegacyArrayTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_legacyArrayType(self);
    }
}

impl<'input> CustomRuleContext<'input> for LegacyArrayTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for LegacyArrayTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for LegacyArrayTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for LegacyArrayTypeContext<'input> {}

impl<'input> LegacyArrayTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::LegacyArrayTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                LegacyArrayTypeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type GenericTypeContext<'input> =
    BaseParserRuleContext<'input, GenericTypeContextExt<'input>>;

pub trait GenericTypeContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn typeParameter_all(&self) -> Vec<Rc<TypeParameterContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn typeParameter(&self, i: usize) -> Option<Rc<TypeParameterContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> GenericTypeContextAttrs<'input> for GenericTypeContext<'input> {}

pub struct GenericTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {GenericTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for GenericTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GenericTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_genericType(self);
    }
}

impl<'input> CustomRuleContext<'input> for GenericTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for GenericTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for GenericTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for GenericTypeContext<'input> {}

impl<'input> GenericTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::GenericTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                GenericTypeContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DateTimeTypeContext<'input> =
    BaseParserRuleContext<'input, DateTimeTypeContextExt<'input>>;

pub trait DateTimeTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TIMESTAMP
    /// Returns `None` if there is no child corresponding to token TIMESTAMP
    fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIMESTAMP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITHOUT
    /// Returns `None` if there is no child corresponding to token WITHOUT
    fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITHOUT, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token TIME in current rule
    fn TIME_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token TIME, starting from 0.
    /// Returns `None` if number of children corresponding to token TIME is less or equal than `i`.
    fn TIME(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIME, i)
    }
    /// Retrieves first TerminalNode corresponding to token ZONE
    /// Returns `None` if there is no child corresponding to token ZONE
    fn ZONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ZONE, 0)
    }
    fn typeParameter(&self) -> Option<Rc<TypeParameterContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token WITH
    /// Returns `None` if there is no child corresponding to token WITH
    fn WITH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITH, 0)
    }
}

impl<'input> DateTimeTypeContextAttrs<'input> for DateTimeTypeContext<'input> {}

pub struct DateTimeTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    pub base_: Option<TokenType<'input>>,
    pub precision: Option<Rc<TypeParameterContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DateTimeTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DateTimeTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DateTimeTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dateTimeType(self);
    }
}

impl<'input> CustomRuleContext<'input> for DateTimeTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for DateTimeTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for DateTimeTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for DateTimeTypeContext<'input> {}

impl<'input> DateTimeTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::DateTimeTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DateTimeTypeContextExt {
                    base_: None,
                    precision: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type LegacyMapTypeContext<'input> =
    BaseParserRuleContext<'input, LegacyMapTypeContextExt<'input>>;

pub trait LegacyMapTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token MAP
    /// Returns `None` if there is no child corresponding to token MAP
    fn MAP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MAP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LT
    /// Returns `None` if there is no child corresponding to token LT
    fn LT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GT
    /// Returns `None` if there is no child corresponding to token GT
    fn GT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GT, 0)
    }
    fn type__all(&self) -> Vec<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> LegacyMapTypeContextAttrs<'input> for LegacyMapTypeContext<'input> {}

pub struct LegacyMapTypeContextExt<'input> {
    base: Type_ContextExt<'input>,
    pub keyType: Option<Rc<Type_ContextAll<'input>>>,
    pub valueType: Option<Rc<Type_ContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {LegacyMapTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for LegacyMapTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for LegacyMapTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_legacyMapType(self);
    }
}

impl<'input> CustomRuleContext<'input> for LegacyMapTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for LegacyMapTypeContext<'input> {
    fn borrow(&self) -> &Type_ContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for LegacyMapTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_ContextAttrs<'input> for LegacyMapTypeContext<'input> {}

impl<'input> LegacyMapTypeContextExt<'input> {
    fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>> {
        Rc::new(Type_ContextAll::LegacyMapTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                LegacyMapTypeContextExt {
                    keyType: None,
                    valueType: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_(&mut self) -> Result<Rc<Type_ContextAll<'input>>, ANTLRError> {
        self.type__rec(0)
    }

    fn type__rec(
        &mut self,
        _p: isize,
    ) -> Result<Rc<Type_ContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx =
            Type_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_recursion_rule(_localctx.clone(), 160, RULE_type_, _p);
        let mut _localctx: Rc<Type_ContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 160;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2580);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(342, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = RowTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            recog.base.set_state(2490);
                            recog.base.match_token(ROW, &mut recog.err_handler)?;

                            recog.base.set_state(2491);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule rowField*/
                            recog.base.set_state(2492);
                            recog.rowField()?;

                            recog.base.set_state(2497);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            while _la == COMMA {
                                {
                                    {
                                        recog.base.set_state(2493);
                                        recog
                                            .base
                                            .match_token(COMMA, &mut recog.err_handler)?;

                                        /*InvokeRule rowField*/
                                        recog.base.set_state(2494);
                                        recog.rowField()?;
                                    }
                                }
                                recog.base.set_state(2499);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                            }
                            recog.base.set_state(2500);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = IntervalTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2502);
                            recog.base.match_token(INTERVAL, &mut recog.err_handler)?;

                            /*InvokeRule intervalField*/
                            recog.base.set_state(2503);
                            let tmp = recog.intervalField()?;
                            if let Type_ContextAll::IntervalTypeContext(ctx) =
                                cast_mut::<_, Type_ContextAll>(&mut _localctx)
                            {
                                ctx.from = Some(tmp.clone());
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2506);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(333, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(2504);
                                        recog
                                            .base
                                            .match_token(TO, &mut recog.err_handler)?;

                                        /*InvokeRule intervalField*/
                                        recog.base.set_state(2505);
                                        let tmp = recog.intervalField()?;
                                        if let Type_ContextAll::IntervalTypeContext(ctx) =
                                            cast_mut::<_, Type_ContextAll>(&mut _localctx)
                                        {
                                            ctx.to = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    3 => {
                        {
                            let mut tmp = DateTimeTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2508);
                            let tmp = recog
                                .base
                                .match_token(TIMESTAMP, &mut recog.err_handler)?;
                            if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                cast_mut::<_, Type_ContextAll>(&mut _localctx)
                            {
                                ctx.base_ = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2513);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(334, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(2509);
                                        recog
                                            .base
                                            .match_token(T__1, &mut recog.err_handler)?;

                                        /*InvokeRule typeParameter*/
                                        recog.base.set_state(2510);
                                        let tmp = recog.typeParameter()?;
                                        if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                            cast_mut::<_, Type_ContextAll>(&mut _localctx)
                                        {
                                            ctx.precision = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }

                                        recog.base.set_state(2511);
                                        recog
                                            .base
                                            .match_token(T__2, &mut recog.err_handler)?;
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2518);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(335, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    recog.base.set_state(2515);
                                    recog
                                        .base
                                        .match_token(WITHOUT, &mut recog.err_handler)?;

                                    recog.base.set_state(2516);
                                    recog
                                        .base
                                        .match_token(TIME, &mut recog.err_handler)?;

                                    recog.base.set_state(2517);
                                    recog
                                        .base
                                        .match_token(ZONE, &mut recog.err_handler)?;
                                }

                                _ => {}
                            }
                        }
                    }
                    4 => {
                        {
                            let mut tmp = DateTimeTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2520);
                            let tmp = recog
                                .base
                                .match_token(TIMESTAMP, &mut recog.err_handler)?;
                            if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                cast_mut::<_, Type_ContextAll>(&mut _localctx)
                            {
                                ctx.base_ = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2525);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == T__1 {
                                {
                                    recog.base.set_state(2521);
                                    recog
                                        .base
                                        .match_token(T__1, &mut recog.err_handler)?;

                                    /*InvokeRule typeParameter*/
                                    recog.base.set_state(2522);
                                    let tmp = recog.typeParameter()?;
                                    if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                        cast_mut::<_, Type_ContextAll>(&mut _localctx)
                                    {
                                        ctx.precision = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }

                                    recog.base.set_state(2523);
                                    recog
                                        .base
                                        .match_token(T__2, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(2527);
                            recog.base.match_token(WITH, &mut recog.err_handler)?;

                            recog.base.set_state(2528);
                            recog.base.match_token(TIME, &mut recog.err_handler)?;

                            recog.base.set_state(2529);
                            recog.base.match_token(ZONE, &mut recog.err_handler)?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = DateTimeTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2530);
                            let tmp =
                                recog.base.match_token(TIME, &mut recog.err_handler)?;
                            if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                cast_mut::<_, Type_ContextAll>(&mut _localctx)
                            {
                                ctx.base_ = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2535);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(337, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(2531);
                                        recog
                                            .base
                                            .match_token(T__1, &mut recog.err_handler)?;

                                        /*InvokeRule typeParameter*/
                                        recog.base.set_state(2532);
                                        let tmp = recog.typeParameter()?;
                                        if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                            cast_mut::<_, Type_ContextAll>(&mut _localctx)
                                        {
                                            ctx.precision = Some(tmp.clone());
                                        } else {
                                            unreachable!("cant cast");
                                        }

                                        recog.base.set_state(2533);
                                        recog
                                            .base
                                            .match_token(T__2, &mut recog.err_handler)?;
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(2540);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(338, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    recog.base.set_state(2537);
                                    recog
                                        .base
                                        .match_token(WITHOUT, &mut recog.err_handler)?;

                                    recog.base.set_state(2538);
                                    recog
                                        .base
                                        .match_token(TIME, &mut recog.err_handler)?;

                                    recog.base.set_state(2539);
                                    recog
                                        .base
                                        .match_token(ZONE, &mut recog.err_handler)?;
                                }

                                _ => {}
                            }
                        }
                    }
                    6 => {
                        {
                            let mut tmp = DateTimeTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2542);
                            let tmp =
                                recog.base.match_token(TIME, &mut recog.err_handler)?;
                            if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                cast_mut::<_, Type_ContextAll>(&mut _localctx)
                            {
                                ctx.base_ = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2547);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == T__1 {
                                {
                                    recog.base.set_state(2543);
                                    recog
                                        .base
                                        .match_token(T__1, &mut recog.err_handler)?;

                                    /*InvokeRule typeParameter*/
                                    recog.base.set_state(2544);
                                    let tmp = recog.typeParameter()?;
                                    if let Type_ContextAll::DateTimeTypeContext(ctx) =
                                        cast_mut::<_, Type_ContextAll>(&mut _localctx)
                                    {
                                        ctx.precision = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }

                                    recog.base.set_state(2545);
                                    recog
                                        .base
                                        .match_token(T__2, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(2549);
                            recog.base.match_token(WITH, &mut recog.err_handler)?;

                            recog.base.set_state(2550);
                            recog.base.match_token(TIME, &mut recog.err_handler)?;

                            recog.base.set_state(2551);
                            recog.base.match_token(ZONE, &mut recog.err_handler)?;
                        }
                    }
                    7 => {
                        let mut tmp = DoublePrecisionTypeContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(2552);
                        recog.base.match_token(DOUBLE, &mut recog.err_handler)?;

                        recog.base.set_state(2553);
                        recog.base.match_token(PRECISION, &mut recog.err_handler)?;
                    }
                    8 => {
                        {
                            let mut tmp = LegacyArrayTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2554);
                            recog.base.match_token(ARRAY, &mut recog.err_handler)?;

                            recog.base.set_state(2555);
                            recog.base.match_token(LT, &mut recog.err_handler)?;

                            /*InvokeRule type_*/
                            recog.base.set_state(2556);
                            recog.type__rec(0)?;

                            recog.base.set_state(2557);
                            recog.base.match_token(GT, &mut recog.err_handler)?;
                        }
                    }
                    9 => {
                        {
                            let mut tmp = LegacyMapTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(2559);
                            recog.base.match_token(MAP, &mut recog.err_handler)?;

                            recog.base.set_state(2560);
                            recog.base.match_token(LT, &mut recog.err_handler)?;

                            /*InvokeRule type_*/
                            recog.base.set_state(2561);
                            let tmp = recog.type__rec(0)?;
                            if let Type_ContextAll::LegacyMapTypeContext(ctx) =
                                cast_mut::<_, Type_ContextAll>(&mut _localctx)
                            {
                                ctx.keyType = Some(tmp.clone());
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2562);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule type_*/
                            recog.base.set_state(2563);
                            let tmp = recog.type__rec(0)?;
                            if let Type_ContextAll::LegacyMapTypeContext(ctx) =
                                cast_mut::<_, Type_ContextAll>(&mut _localctx)
                            {
                                ctx.valueType = Some(tmp.clone());
                            } else {
                                unreachable!("cant cast");
                            }

                            recog.base.set_state(2564);
                            recog.base.match_token(GT, &mut recog.err_handler)?;
                        }
                    }
                    10 => {
                        {
                            let mut tmp = GenericTypeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /*InvokeRule identifier*/
                            recog.base.set_state(2566);
                            recog.identifier()?;

                            recog.base.set_state(2578);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(341, &mut recog.base)?
                            {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(2567);
                                        recog
                                            .base
                                            .match_token(T__1, &mut recog.err_handler)?;

                                        /*InvokeRule typeParameter*/
                                        recog.base.set_state(2568);
                                        recog.typeParameter()?;

                                        recog.base.set_state(2573);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        while _la == COMMA {
                                            {
                                                {
                                                    recog.base.set_state(2569);
                                                    recog.base.match_token(
                                                        COMMA,
                                                        &mut recog.err_handler,
                                                    )?;

                                                    /*InvokeRule typeParameter*/
                                                    recog.base.set_state(2570);
                                                    recog.typeParameter()?;
                                                }
                                            }
                                            recog.base.set_state(2575);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _la = recog.base.input.la(1);
                                        }
                                        recog.base.set_state(2576);
                                        recog
                                            .base
                                            .match_token(T__2, &mut recog.err_handler)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(2591);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(344, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            {
                                /*recRuleLabeledAltStartAction*/
                                let mut tmp =
                                    ArrayTypeContextExt::new(&**Type_ContextExt::new(
                                        _parentctx.clone(),
                                        _parentState,
                                    ));
                                recog.push_new_recursion_context(
                                    tmp.clone(),
                                    _startState,
                                    RULE_type_,
                                );
                                _localctx = tmp;
                                recog.base.set_state(2582);
                                if !({ recog.precpred(None, 2) }) {
                                    Err(FailedPredicateError::new(
                                        &mut recog.base,
                                        Some("recog.precpred(None, 2)".to_owned()),
                                        None,
                                    ))?;
                                }
                                recog.base.set_state(2583);
                                recog.base.match_token(ARRAY, &mut recog.err_handler)?;

                                recog.base.set_state(2587);
                                recog.err_handler.sync(&mut recog.base)?;
                                match recog
                                    .interpreter
                                    .adaptive_predict(343, &mut recog.base)?
                                {
                                    x if x == 1 => {
                                        recog.base.set_state(2584);
                                        recog
                                            .base
                                            .match_token(T__6, &mut recog.err_handler)?;

                                        recog.base.set_state(2585);
                                        recog.base.match_token(
                                            INTEGER_VALUE,
                                            &mut recog.err_handler,
                                        )?;

                                        recog.base.set_state(2586);
                                        recog
                                            .base
                                            .match_token(T__7, &mut recog.err_handler)?;
                                    }

                                    _ => {}
                                }
                            }
                        }
                    }
                    recog.base.set_state(2593);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(344, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- rowField ----------------
pub type RowFieldContextAll<'input> = RowFieldContext<'input>;

pub type RowFieldContext<'input> =
    BaseParserRuleContext<'input, RowFieldContextExt<'input>>;

#[derive(Clone)]
pub struct RowFieldContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RowFieldContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RowFieldContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rowField(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_rowField(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for RowFieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rowField
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rowField }
}
antlr_rust::tid! {RowFieldContextExt<'a>}

impl<'input> RowFieldContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RowFieldContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            RowFieldContextExt { ph: PhantomData },
        ))
    }
}

pub trait RowFieldContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RowFieldContextExt<'input>>
{
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> RowFieldContextAttrs<'input> for RowFieldContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn rowField(&mut self) -> Result<Rc<RowFieldContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            RowFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_rowField);
        let mut _localctx: Rc<RowFieldContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2598);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(345, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /*InvokeRule type_*/
                        recog.base.set_state(2594);
                        recog.type__rec(0)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /*InvokeRule identifier*/
                        recog.base.set_state(2595);
                        recog.identifier()?;

                        /*InvokeRule type_*/
                        recog.base.set_state(2596);
                        recog.type__rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- typeParameter ----------------
pub type TypeParameterContextAll<'input> = TypeParameterContext<'input>;

pub type TypeParameterContext<'input> =
    BaseParserRuleContext<'input, TypeParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TypeParameterContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TypeParameterContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_typeParameter(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_typeParameter(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for TypeParameterContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_typeParameter
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_typeParameter }
}
antlr_rust::tid! {TypeParameterContextExt<'a>}

impl<'input> TypeParameterContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TypeParameterContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            TypeParameterContextExt { ph: PhantomData },
        ))
    }
}

pub trait TypeParameterContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TypeParameterContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
    /// Returns `None` if there is no child corresponding to token INTEGER_VALUE
    fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER_VALUE, 0)
    }
    fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TypeParameterContextAttrs<'input> for TypeParameterContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn typeParameter(
        &mut self,
    ) -> Result<Rc<TypeParameterContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            TypeParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 164, RULE_typeParameter);
        let mut _localctx: Rc<TypeParameterContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2602);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                INTEGER_VALUE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2600);
                        recog
                            .base
                            .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                    }
                }

                ABSENT
                | ADD
                | ADMIN
                | AFTER
                | ALL
                | ANALYZE
                | ANY
                | ARRAY
                | ASC
                | AT
                | AUTHORIZATION
                | BERNOULLI
                | BOTH
                | CALL
                | CASCADE
                | CATALOGS
                | COLUMN
                | COLUMNS
                | COMMENT
                | COMMIT
                | COMMITTED
                | CONDITIONAL
                | COUNT
                | COPARTITION
                | CURRENT
                | DATA
                | DATE
                | DAY
                | DEFAULT
                | DEFINE
                | DEFINER
                | DENY
                | DESC
                | DESCRIPTOR
                | DISTRIBUTED
                | DOUBLE
                | EMPTY
                | ENCODING
                | ERROR
                | EXCLUDING
                | EXPLAIN
                | FETCH
                | FILTER
                | FINAL
                | FIRST
                | FOLLOWING
                | FORMAT
                | FUNCTIONS
                | GRACE
                | GRANT
                | GRANTED
                | GRANTS
                | GRAPHVIZ
                | GROUPS
                | HOUR
                | IF
                | IGNORE
                | INCLUDING
                | INITIAL
                | INPUT
                | INTERVAL
                | INVOKER
                | IO
                | ISOLATION
                | JSON
                | KEEP
                | KEY
                | KEYS
                | LAST
                | LATERAL
                | LEADING
                | LEVEL
                | LIMIT
                | LOCAL
                | LOGICAL
                | MAP
                | MATCH
                | MATCHED
                | MATCHES
                | MATCH_RECOGNIZE
                | MATERIALIZED
                | MEASURES
                | MERGE
                | MINUTE
                | MONTH
                | NEXT
                | NFC
                | NFD
                | NFKC
                | NFKD
                | NO
                | NONE
                | NULLIF
                | NULLS
                | OBJECT
                | OF
                | OFFSET
                | OMIT
                | ONE
                | ONLY
                | OPTION
                | ORDINALITY
                | OUTPUT
                | OVER
                | OVERFLOW
                | PARTITION
                | PARTITIONS
                | PASSING
                | PAST
                | PATH
                | PATTERN
                | PER
                | PERIOD
                | PERMUTE
                | POSITION
                | PRECEDING
                | PRECISION
                | PRIVILEGES
                | PROPERTIES
                | PRUNE
                | QUOTES
                | RANGE
                | READ
                | REFRESH
                | RENAME
                | REPEATABLE
                | REPLACE
                | RESET
                | RESPECT
                | RESTRICT
                | RETURNING
                | REVOKE
                | ROLE
                | ROLES
                | ROLLBACK
                | ROW
                | ROWS
                | RUNNING
                | SCALAR
                | SCHEMA
                | SCHEMAS
                | SECOND
                | SECURITY
                | SEEK
                | SERIALIZABLE
                | SESSION
                | SET
                | SETS
                | SHOW
                | SOME
                | START
                | STATS
                | SUBSET
                | SUBSTRING
                | SYSTEM
                | TABLES
                | TABLESAMPLE
                | TEXT
                | TEXT_STRING
                | TIES
                | TIME
                | TIMESTAMP
                | TO
                | TRAILING
                | TRANSACTION
                | TRUNCATE
                | TRY_CAST
                | TYPE
                | UNBOUNDED
                | UNCOMMITTED
                | UNCONDITIONAL
                | UNIQUE
                | UNKNOWN
                | UNMATCHED
                | UPDATE
                | USE
                | USER
                | UTF16
                | UTF32
                | UTF8
                | VALIDATE
                | VALUE
                | VERBOSE
                | VERSION
                | VIEW
                | WINDOW
                | WITHIN
                | WITHOUT
                | WORK
                | WRAPPER
                | WRITE
                | YEAR
                | ZONE
                | IDENTIFIER
                | DIGIT_IDENTIFIER
                | QUOTED_IDENTIFIER
                | BACKQUOTED_IDENTIFIER => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /*InvokeRule type_*/
                        recog.base.set_state(2601);
                        recog.type__rec(0)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- whenClause ----------------
pub type WhenClauseContextAll<'input> = WhenClauseContext<'input>;

pub type WhenClauseContext<'input> =
    BaseParserRuleContext<'input, WhenClauseContextExt<'input>>;

#[derive(Clone)]
pub struct WhenClauseContextExt<'input> {
    pub condition: Option<Rc<ExpressionContextAll<'input>>>,
    pub result: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for WhenClauseContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for WhenClauseContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_whenClause(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_whenClause(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhenClauseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_whenClause
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_whenClause }
}
antlr_rust::tid! {WhenClauseContextExt<'a>}

impl<'input> WhenClauseContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<WhenClauseContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            WhenClauseContextExt {
                condition: None,
                result: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait WhenClauseContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<WhenClauseContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token WHEN
    /// Returns `None` if there is no child corresponding to token WHEN
    fn WHEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token THEN
    /// Returns `None` if there is no child corresponding to token THEN
    fn THEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(THEN, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhenClauseContextAttrs<'input> for WhenClauseContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn whenClause(&mut self) -> Result<Rc<WhenClauseContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            WhenClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 166, RULE_whenClause);
        let mut _localctx: Rc<WhenClauseContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2604);
                recog.base.match_token(WHEN, &mut recog.err_handler)?;

                /*InvokeRule expression*/
                recog.base.set_state(2605);
                let tmp = recog.expression()?;
                cast_mut::<_, WhenClauseContext>(&mut _localctx).condition =
                    Some(tmp.clone());

                recog.base.set_state(2606);
                recog.base.match_token(THEN, &mut recog.err_handler)?;

                /*InvokeRule expression*/
                recog.base.set_state(2607);
                let tmp = recog.expression()?;
                cast_mut::<_, WhenClauseContext>(&mut _localctx).result =
                    Some(tmp.clone());
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- filter ----------------
pub type FilterContextAll<'input> = FilterContext<'input>;

pub type FilterContext<'input> = BaseParserRuleContext<'input, FilterContextExt<'input>>;

#[derive(Clone)]
pub struct FilterContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for FilterContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for FilterContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_filter(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_filter(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for FilterContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_filter
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_filter }
}
antlr_rust::tid! {FilterContextExt<'a>}

impl<'input> FilterContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<FilterContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            FilterContextExt { ph: PhantomData },
        ))
    }
}

pub trait FilterContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<FilterContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token FILTER
    /// Returns `None` if there is no child corresponding to token FILTER
    fn FILTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FILTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WHERE
    /// Returns `None` if there is no child corresponding to token WHERE
    fn WHERE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHERE, 0)
    }
    fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> FilterContextAttrs<'input> for FilterContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn filter(&mut self) -> Result<Rc<FilterContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            FilterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_filter);
        let mut _localctx: Rc<FilterContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2609);
                recog.base.match_token(FILTER, &mut recog.err_handler)?;

                recog.base.set_state(2610);
                recog.base.match_token(T__1, &mut recog.err_handler)?;

                recog.base.set_state(2611);
                recog.base.match_token(WHERE, &mut recog.err_handler)?;

                /*InvokeRule booleanExpression*/
                recog.base.set_state(2612);
                recog.booleanExpression_rec(0)?;

                recog.base.set_state(2613);
                recog.base.match_token(T__2, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- mergeCase ----------------
#[derive(Debug)]
pub enum MergeCaseContextAll<'input> {
    MergeInsertContext(MergeInsertContext<'input>),
    MergeUpdateContext(MergeUpdateContext<'input>),
    MergeDeleteContext(MergeDeleteContext<'input>),
    Error(MergeCaseContext<'input>),
}
antlr_rust::tid! {MergeCaseContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for MergeCaseContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for MergeCaseContextAll<'input> {}

impl<'input> Deref for MergeCaseContextAll<'input> {
    type Target = dyn MergeCaseContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use MergeCaseContextAll::*;
        match self {
            MergeInsertContext(inner) => inner,
            MergeUpdateContext(inner) => inner,
            MergeDeleteContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for MergeCaseContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type MergeCaseContext<'input> =
    BaseParserRuleContext<'input, MergeCaseContextExt<'input>>;

#[derive(Clone)]
pub struct MergeCaseContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for MergeCaseContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for MergeCaseContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for MergeCaseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_mergeCase
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_mergeCase }
}
antlr_rust::tid! {MergeCaseContextExt<'a>}

impl<'input> MergeCaseContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<MergeCaseContextAll<'input>> {
        Rc::new(MergeCaseContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                MergeCaseContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait MergeCaseContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<MergeCaseContextExt<'input>>
{
}

impl<'input> MergeCaseContextAttrs<'input> for MergeCaseContext<'input> {}

pub type MergeInsertContext<'input> =
    BaseParserRuleContext<'input, MergeInsertContextExt<'input>>;

pub trait MergeInsertContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token WHEN
    /// Returns `None` if there is no child corresponding to token WHEN
    fn WHEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NOT
    /// Returns `None` if there is no child corresponding to token NOT
    fn NOT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCHED
    /// Returns `None` if there is no child corresponding to token MATCHED
    fn MATCHED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCHED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token THEN
    /// Returns `None` if there is no child corresponding to token THEN
    fn THEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INSERT
    /// Returns `None` if there is no child corresponding to token INSERT
    fn INSERT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INSERT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VALUES
    /// Returns `None` if there is no child corresponding to token VALUES
    fn VALUES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VALUES, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token AND
    /// Returns `None` if there is no child corresponding to token AND
    fn AND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AND, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MergeInsertContextAttrs<'input> for MergeInsertContext<'input> {}

pub struct MergeInsertContextExt<'input> {
    base: MergeCaseContextExt<'input>,
    pub condition: Option<Rc<ExpressionContextAll<'input>>>,
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub targets: Vec<Rc<IdentifierContextAll<'input>>>,
    pub expression: Option<Rc<ExpressionContextAll<'input>>>,
    pub values: Vec<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MergeInsertContextExt<'a>}

impl<'input> PrestoParserContext<'input> for MergeInsertContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for MergeInsertContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_mergeInsert(self);
    }
}

impl<'input> CustomRuleContext<'input> for MergeInsertContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_mergeCase
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_mergeCase }
}

impl<'input> Borrow<MergeCaseContextExt<'input>> for MergeInsertContext<'input> {
    fn borrow(&self) -> &MergeCaseContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<MergeCaseContextExt<'input>> for MergeInsertContext<'input> {
    fn borrow_mut(&mut self) -> &mut MergeCaseContextExt<'input> {
        &mut self.base
    }
}

impl<'input> MergeCaseContextAttrs<'input> for MergeInsertContext<'input> {}

impl<'input> MergeInsertContextExt<'input> {
    fn new(ctx: &dyn MergeCaseContextAttrs<'input>) -> Rc<MergeCaseContextAll<'input>> {
        Rc::new(MergeCaseContextAll::MergeInsertContext(
            BaseParserRuleContext::copy_from(
                ctx,
                MergeInsertContextExt {
                    condition: None,
                    identifier: None,
                    expression: None,
                    targets: Vec::new(),
                    values: Vec::new(),
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type MergeUpdateContext<'input> =
    BaseParserRuleContext<'input, MergeUpdateContextExt<'input>>;

pub trait MergeUpdateContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token WHEN
    /// Returns `None` if there is no child corresponding to token WHEN
    fn WHEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCHED
    /// Returns `None` if there is no child corresponding to token MATCHED
    fn MATCHED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCHED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token THEN
    /// Returns `None` if there is no child corresponding to token THEN
    fn THEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UPDATE
    /// Returns `None` if there is no child corresponding to token UPDATE
    fn UPDATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UPDATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token EQ in current rule
    fn EQ_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token EQ, starting from 0.
    /// Returns `None` if number of children corresponding to token EQ is less or equal than `i`.
    fn EQ(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EQ, i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token AND
    /// Returns `None` if there is no child corresponding to token AND
    fn AND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AND, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> MergeUpdateContextAttrs<'input> for MergeUpdateContext<'input> {}

pub struct MergeUpdateContextExt<'input> {
    base: MergeCaseContextExt<'input>,
    pub condition: Option<Rc<ExpressionContextAll<'input>>>,
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub targets: Vec<Rc<IdentifierContextAll<'input>>>,
    pub expression: Option<Rc<ExpressionContextAll<'input>>>,
    pub values: Vec<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MergeUpdateContextExt<'a>}

impl<'input> PrestoParserContext<'input> for MergeUpdateContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for MergeUpdateContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_mergeUpdate(self);
    }
}

impl<'input> CustomRuleContext<'input> for MergeUpdateContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_mergeCase
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_mergeCase }
}

impl<'input> Borrow<MergeCaseContextExt<'input>> for MergeUpdateContext<'input> {
    fn borrow(&self) -> &MergeCaseContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<MergeCaseContextExt<'input>> for MergeUpdateContext<'input> {
    fn borrow_mut(&mut self) -> &mut MergeCaseContextExt<'input> {
        &mut self.base
    }
}

impl<'input> MergeCaseContextAttrs<'input> for MergeUpdateContext<'input> {}

impl<'input> MergeUpdateContextExt<'input> {
    fn new(ctx: &dyn MergeCaseContextAttrs<'input>) -> Rc<MergeCaseContextAll<'input>> {
        Rc::new(MergeCaseContextAll::MergeUpdateContext(
            BaseParserRuleContext::copy_from(
                ctx,
                MergeUpdateContextExt {
                    condition: None,
                    identifier: None,
                    expression: None,
                    targets: Vec::new(),
                    values: Vec::new(),
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type MergeDeleteContext<'input> =
    BaseParserRuleContext<'input, MergeDeleteContextExt<'input>>;

pub trait MergeDeleteContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token WHEN
    /// Returns `None` if there is no child corresponding to token WHEN
    fn WHEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WHEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCHED
    /// Returns `None` if there is no child corresponding to token MATCHED
    fn MATCHED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCHED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token THEN
    /// Returns `None` if there is no child corresponding to token THEN
    fn THEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DELETE
    /// Returns `None` if there is no child corresponding to token DELETE
    fn DELETE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DELETE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AND
    /// Returns `None` if there is no child corresponding to token AND
    fn AND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AND, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MergeDeleteContextAttrs<'input> for MergeDeleteContext<'input> {}

pub struct MergeDeleteContextExt<'input> {
    base: MergeCaseContextExt<'input>,
    pub condition: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MergeDeleteContextExt<'a>}

impl<'input> PrestoParserContext<'input> for MergeDeleteContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for MergeDeleteContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_mergeDelete(self);
    }
}

impl<'input> CustomRuleContext<'input> for MergeDeleteContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_mergeCase
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_mergeCase }
}

impl<'input> Borrow<MergeCaseContextExt<'input>> for MergeDeleteContext<'input> {
    fn borrow(&self) -> &MergeCaseContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<MergeCaseContextExt<'input>> for MergeDeleteContext<'input> {
    fn borrow_mut(&mut self) -> &mut MergeCaseContextExt<'input> {
        &mut self.base
    }
}

impl<'input> MergeCaseContextAttrs<'input> for MergeDeleteContext<'input> {}

impl<'input> MergeDeleteContextExt<'input> {
    fn new(ctx: &dyn MergeCaseContextAttrs<'input>) -> Rc<MergeCaseContextAll<'input>> {
        Rc::new(MergeCaseContextAll::MergeDeleteContext(
            BaseParserRuleContext::copy_from(
                ctx,
                MergeDeleteContextExt {
                    condition: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn mergeCase(&mut self) -> Result<Rc<MergeCaseContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            MergeCaseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 170, RULE_mergeCase);
        let mut _localctx: Rc<MergeCaseContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2679);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(354, &mut recog.base)? {
                1 => {
                    let tmp = MergeUpdateContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2615);
                        recog.base.match_token(WHEN, &mut recog.err_handler)?;

                        recog.base.set_state(2616);
                        recog.base.match_token(MATCHED, &mut recog.err_handler)?;

                        recog.base.set_state(2619);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == AND {
                            {
                                recog.base.set_state(2617);
                                recog.base.match_token(AND, &mut recog.err_handler)?;

                                /*InvokeRule expression*/
                                recog.base.set_state(2618);
                                let tmp = recog.expression()?;
                                if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                                    cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                {
                                    ctx.condition = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }

                        recog.base.set_state(2621);
                        recog.base.match_token(THEN, &mut recog.err_handler)?;

                        recog.base.set_state(2622);
                        recog.base.match_token(UPDATE, &mut recog.err_handler)?;

                        recog.base.set_state(2623);
                        recog.base.match_token(SET, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(2624);
                        let tmp = recog.identifier()?;
                        if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.identifier = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        let temp = if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.identifier.clone().unwrap()
                        } else {
                            unreachable!("cant cast");
                        };
                        if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.targets.push(temp);
                        } else {
                            unreachable!("cant cast");
                        }
                        recog.base.set_state(2625);
                        recog.base.match_token(EQ, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(2626);
                        let tmp = recog.expression()?;
                        if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.expression = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        let temp = if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.expression.clone().unwrap()
                        } else {
                            unreachable!("cant cast");
                        };
                        if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.values.push(temp);
                        } else {
                            unreachable!("cant cast");
                        }
                        recog.base.set_state(2634);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(2627);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule identifier*/
                                    recog.base.set_state(2628);
                                    let tmp = recog.identifier()?;
                                    if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                                        cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                    {
                                        ctx.identifier = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }

                                    let temp =
                                        if let MergeCaseContextAll::MergeUpdateContext(
                                            ctx,
                                        ) = cast_mut::<_, MergeCaseContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.identifier.clone().unwrap()
                                        } else {
                                            unreachable!("cant cast");
                                        };
                                    if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                                        cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                    {
                                        ctx.targets.push(temp);
                                    } else {
                                        unreachable!("cant cast");
                                    }
                                    recog.base.set_state(2629);
                                    recog.base.match_token(EQ, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(2630);
                                    let tmp = recog.expression()?;
                                    if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                                        cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                    {
                                        ctx.expression = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }

                                    let temp =
                                        if let MergeCaseContextAll::MergeUpdateContext(
                                            ctx,
                                        ) = cast_mut::<_, MergeCaseContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.expression.clone().unwrap()
                                        } else {
                                            unreachable!("cant cast");
                                        };
                                    if let MergeCaseContextAll::MergeUpdateContext(ctx) =
                                        cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                    {
                                        ctx.values.push(temp);
                                    } else {
                                        unreachable!("cant cast");
                                    }
                                }
                            }
                            recog.base.set_state(2636);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }
                2 => {
                    let tmp = MergeDeleteContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2637);
                        recog.base.match_token(WHEN, &mut recog.err_handler)?;

                        recog.base.set_state(2638);
                        recog.base.match_token(MATCHED, &mut recog.err_handler)?;

                        recog.base.set_state(2641);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == AND {
                            {
                                recog.base.set_state(2639);
                                recog.base.match_token(AND, &mut recog.err_handler)?;

                                /*InvokeRule expression*/
                                recog.base.set_state(2640);
                                let tmp = recog.expression()?;
                                if let MergeCaseContextAll::MergeDeleteContext(ctx) =
                                    cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                {
                                    ctx.condition = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }

                        recog.base.set_state(2643);
                        recog.base.match_token(THEN, &mut recog.err_handler)?;

                        recog.base.set_state(2644);
                        recog.base.match_token(DELETE, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = MergeInsertContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2645);
                        recog.base.match_token(WHEN, &mut recog.err_handler)?;

                        recog.base.set_state(2646);
                        recog.base.match_token(NOT, &mut recog.err_handler)?;

                        recog.base.set_state(2647);
                        recog.base.match_token(MATCHED, &mut recog.err_handler)?;

                        recog.base.set_state(2650);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == AND {
                            {
                                recog.base.set_state(2648);
                                recog.base.match_token(AND, &mut recog.err_handler)?;

                                /*InvokeRule expression*/
                                recog.base.set_state(2649);
                                let tmp = recog.expression()?;
                                if let MergeCaseContextAll::MergeInsertContext(ctx) =
                                    cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                {
                                    ctx.condition = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }
                            }
                        }

                        recog.base.set_state(2652);
                        recog.base.match_token(THEN, &mut recog.err_handler)?;

                        recog.base.set_state(2653);
                        recog.base.match_token(INSERT, &mut recog.err_handler)?;

                        recog.base.set_state(2665);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == T__1 {
                            {
                                recog.base.set_state(2654);
                                recog.base.match_token(T__1, &mut recog.err_handler)?;

                                /*InvokeRule identifier*/
                                recog.base.set_state(2655);
                                let tmp = recog.identifier()?;
                                if let MergeCaseContextAll::MergeInsertContext(ctx) =
                                    cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                {
                                    ctx.identifier = Some(tmp.clone());
                                } else {
                                    unreachable!("cant cast");
                                }

                                let temp =
                                    if let MergeCaseContextAll::MergeInsertContext(ctx) =
                                        cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                    {
                                        ctx.identifier.clone().unwrap()
                                    } else {
                                        unreachable!("cant cast");
                                    };
                                if let MergeCaseContextAll::MergeInsertContext(ctx) =
                                    cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                {
                                    ctx.targets.push(temp);
                                } else {
                                    unreachable!("cant cast");
                                }
                                recog.base.set_state(2660);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                while _la == COMMA {
                                    {
                                        {
                                            recog.base.set_state(2656);
                                            recog.base.match_token(
                                                COMMA,
                                                &mut recog.err_handler,
                                            )?;

                                            /*InvokeRule identifier*/
                                            recog.base.set_state(2657);
                                            let tmp = recog.identifier()?;
                                            if let MergeCaseContextAll::MergeInsertContext(ctx) = cast_mut::<_,MergeCaseContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}

                                            let temp = if let MergeCaseContextAll::MergeInsertContext(ctx) = cast_mut::<_,MergeCaseContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
                                            if let MergeCaseContextAll::MergeInsertContext(ctx) = cast_mut::<_,MergeCaseContextAll >(&mut _localctx){
							ctx.targets.push(temp); } else {unreachable!("cant cast");}
                                        }
                                    }
                                    recog.base.set_state(2662);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                }
                                recog.base.set_state(2663);
                                recog.base.match_token(T__2, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(2667);
                        recog.base.match_token(VALUES, &mut recog.err_handler)?;

                        recog.base.set_state(2668);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(2669);
                        let tmp = recog.expression()?;
                        if let MergeCaseContextAll::MergeInsertContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.expression = Some(tmp.clone());
                        } else {
                            unreachable!("cant cast");
                        }

                        let temp = if let MergeCaseContextAll::MergeInsertContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.expression.clone().unwrap()
                        } else {
                            unreachable!("cant cast");
                        };
                        if let MergeCaseContextAll::MergeInsertContext(ctx) =
                            cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                        {
                            ctx.values.push(temp);
                        } else {
                            unreachable!("cant cast");
                        }
                        recog.base.set_state(2674);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(2670);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule expression*/
                                    recog.base.set_state(2671);
                                    let tmp = recog.expression()?;
                                    if let MergeCaseContextAll::MergeInsertContext(ctx) =
                                        cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                    {
                                        ctx.expression = Some(tmp.clone());
                                    } else {
                                        unreachable!("cant cast");
                                    }

                                    let temp =
                                        if let MergeCaseContextAll::MergeInsertContext(
                                            ctx,
                                        ) = cast_mut::<_, MergeCaseContextAll>(
                                            &mut _localctx,
                                        ) {
                                            ctx.expression.clone().unwrap()
                                        } else {
                                            unreachable!("cant cast");
                                        };
                                    if let MergeCaseContextAll::MergeInsertContext(ctx) =
                                        cast_mut::<_, MergeCaseContextAll>(&mut _localctx)
                                    {
                                        ctx.values.push(temp);
                                    } else {
                                        unreachable!("cant cast");
                                    }
                                }
                            }
                            recog.base.set_state(2676);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(2677);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- over ----------------
pub type OverContextAll<'input> = OverContext<'input>;

pub type OverContext<'input> = BaseParserRuleContext<'input, OverContextExt<'input>>;

#[derive(Clone)]
pub struct OverContextExt<'input> {
    pub windowName: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for OverContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for OverContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_over(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_over(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for OverContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_over
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_over }
}
antlr_rust::tid! {OverContextExt<'a>}

impl<'input> OverContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<OverContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            OverContextExt {
                windowName: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait OverContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<OverContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OVER
    /// Returns `None` if there is no child corresponding to token OVER
    fn OVER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OVER, 0)
    }
    fn windowSpecification(&self) -> Option<Rc<WindowSpecificationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> OverContextAttrs<'input> for OverContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn over(&mut self) -> Result<Rc<OverContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            OverContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_over);
        let mut _localctx: Rc<OverContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2681);
                recog.base.match_token(OVER, &mut recog.err_handler)?;

                recog.base.set_state(2687);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    ABSENT
                    | ADD
                    | ADMIN
                    | AFTER
                    | ALL
                    | ANALYZE
                    | ANY
                    | ARRAY
                    | ASC
                    | AT
                    | AUTHORIZATION
                    | BERNOULLI
                    | BOTH
                    | CALL
                    | CASCADE
                    | CATALOGS
                    | COLUMN
                    | COLUMNS
                    | COMMENT
                    | COMMIT
                    | COMMITTED
                    | CONDITIONAL
                    | COUNT
                    | COPARTITION
                    | CURRENT
                    | DATA
                    | DATE
                    | DAY
                    | DEFAULT
                    | DEFINE
                    | DEFINER
                    | DENY
                    | DESC
                    | DESCRIPTOR
                    | DISTRIBUTED
                    | DOUBLE
                    | EMPTY
                    | ENCODING
                    | ERROR
                    | EXCLUDING
                    | EXPLAIN
                    | FETCH
                    | FILTER
                    | FINAL
                    | FIRST
                    | FOLLOWING
                    | FORMAT
                    | FUNCTIONS
                    | GRACE
                    | GRANT
                    | GRANTED
                    | GRANTS
                    | GRAPHVIZ
                    | GROUPS
                    | HOUR
                    | IF
                    | IGNORE
                    | INCLUDING
                    | INITIAL
                    | INPUT
                    | INTERVAL
                    | INVOKER
                    | IO
                    | ISOLATION
                    | JSON
                    | KEEP
                    | KEY
                    | KEYS
                    | LAST
                    | LATERAL
                    | LEADING
                    | LEVEL
                    | LIMIT
                    | LOCAL
                    | LOGICAL
                    | MAP
                    | MATCH
                    | MATCHED
                    | MATCHES
                    | MATCH_RECOGNIZE
                    | MATERIALIZED
                    | MEASURES
                    | MERGE
                    | MINUTE
                    | MONTH
                    | NEXT
                    | NFC
                    | NFD
                    | NFKC
                    | NFKD
                    | NO
                    | NONE
                    | NULLIF
                    | NULLS
                    | OBJECT
                    | OF
                    | OFFSET
                    | OMIT
                    | ONE
                    | ONLY
                    | OPTION
                    | ORDINALITY
                    | OUTPUT
                    | OVER
                    | OVERFLOW
                    | PARTITION
                    | PARTITIONS
                    | PASSING
                    | PAST
                    | PATH
                    | PATTERN
                    | PER
                    | PERIOD
                    | PERMUTE
                    | POSITION
                    | PRECEDING
                    | PRECISION
                    | PRIVILEGES
                    | PROPERTIES
                    | PRUNE
                    | QUOTES
                    | RANGE
                    | READ
                    | REFRESH
                    | RENAME
                    | REPEATABLE
                    | REPLACE
                    | RESET
                    | RESPECT
                    | RESTRICT
                    | RETURNING
                    | REVOKE
                    | ROLE
                    | ROLES
                    | ROLLBACK
                    | ROW
                    | ROWS
                    | RUNNING
                    | SCALAR
                    | SCHEMA
                    | SCHEMAS
                    | SECOND
                    | SECURITY
                    | SEEK
                    | SERIALIZABLE
                    | SESSION
                    | SET
                    | SETS
                    | SHOW
                    | SOME
                    | START
                    | STATS
                    | SUBSET
                    | SUBSTRING
                    | SYSTEM
                    | TABLES
                    | TABLESAMPLE
                    | TEXT
                    | TEXT_STRING
                    | TIES
                    | TIME
                    | TIMESTAMP
                    | TO
                    | TRAILING
                    | TRANSACTION
                    | TRUNCATE
                    | TRY_CAST
                    | TYPE
                    | UNBOUNDED
                    | UNCOMMITTED
                    | UNCONDITIONAL
                    | UNIQUE
                    | UNKNOWN
                    | UNMATCHED
                    | UPDATE
                    | USE
                    | USER
                    | UTF16
                    | UTF32
                    | UTF8
                    | VALIDATE
                    | VALUE
                    | VERBOSE
                    | VERSION
                    | VIEW
                    | WINDOW
                    | WITHIN
                    | WITHOUT
                    | WORK
                    | WRAPPER
                    | WRITE
                    | YEAR
                    | ZONE
                    | IDENTIFIER
                    | DIGIT_IDENTIFIER
                    | QUOTED_IDENTIFIER
                    | BACKQUOTED_IDENTIFIER => {
                        {
                            /*InvokeRule identifier*/
                            recog.base.set_state(2682);
                            let tmp = recog.identifier()?;
                            cast_mut::<_, OverContext>(&mut _localctx).windowName =
                                Some(tmp.clone());
                        }
                    }

                    T__1 => {
                        {
                            recog.base.set_state(2683);
                            recog.base.match_token(T__1, &mut recog.err_handler)?;

                            /*InvokeRule windowSpecification*/
                            recog.base.set_state(2684);
                            recog.windowSpecification()?;

                            recog.base.set_state(2685);
                            recog.base.match_token(T__2, &mut recog.err_handler)?;
                        }
                    }

                    _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                        &mut recog.base,
                    )))?,
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- windowFrame ----------------
pub type WindowFrameContextAll<'input> = WindowFrameContext<'input>;

pub type WindowFrameContext<'input> =
    BaseParserRuleContext<'input, WindowFrameContextExt<'input>>;

#[derive(Clone)]
pub struct WindowFrameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for WindowFrameContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for WindowFrameContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_windowFrame(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_windowFrame(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for WindowFrameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_windowFrame
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_windowFrame }
}
antlr_rust::tid! {WindowFrameContextExt<'a>}

impl<'input> WindowFrameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<WindowFrameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            WindowFrameContextExt { ph: PhantomData },
        ))
    }
}

pub trait WindowFrameContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<WindowFrameContextExt<'input>>
{
    fn frameExtent(&self) -> Option<Rc<FrameExtentContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token MEASURES
    /// Returns `None` if there is no child corresponding to token MEASURES
    fn MEASURES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MEASURES, 0)
    }
    fn measureDefinition_all(&self) -> Vec<Rc<MeasureDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn measureDefinition(
        &self,
        i: usize,
    ) -> Option<Rc<MeasureDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token AFTER
    /// Returns `None` if there is no child corresponding to token AFTER
    fn AFTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AFTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCH
    /// Returns `None` if there is no child corresponding to token MATCH
    fn MATCH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCH, 0)
    }
    fn skipTo(&self) -> Option<Rc<SkipToContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PATTERN
    /// Returns `None` if there is no child corresponding to token PATTERN
    fn PATTERN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PATTERN, 0)
    }
    fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SUBSET
    /// Returns `None` if there is no child corresponding to token SUBSET
    fn SUBSET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SUBSET, 0)
    }
    fn subsetDefinition_all(&self) -> Vec<Rc<SubsetDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn subsetDefinition(&self, i: usize) -> Option<Rc<SubsetDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token DEFINE
    /// Returns `None` if there is no child corresponding to token DEFINE
    fn DEFINE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFINE, 0)
    }
    fn variableDefinition_all(&self) -> Vec<Rc<VariableDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn variableDefinition(
        &self,
        i: usize,
    ) -> Option<Rc<VariableDefinitionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token INITIAL
    /// Returns `None` if there is no child corresponding to token INITIAL
    fn INITIAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INITIAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SEEK
    /// Returns `None` if there is no child corresponding to token SEEK
    fn SEEK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEEK, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> WindowFrameContextAttrs<'input> for WindowFrameContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn windowFrame(
        &mut self,
    ) -> Result<Rc<WindowFrameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            WindowFrameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 174, RULE_windowFrame);
        let mut _localctx: Rc<WindowFrameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2698);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == MEASURES {
                    {
                        recog.base.set_state(2689);
                        recog.base.match_token(MEASURES, &mut recog.err_handler)?;

                        /*InvokeRule measureDefinition*/
                        recog.base.set_state(2690);
                        recog.measureDefinition()?;

                        recog.base.set_state(2695);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(2691);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule measureDefinition*/
                                    recog.base.set_state(2692);
                                    recog.measureDefinition()?;
                                }
                            }
                            recog.base.set_state(2697);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }

                /*InvokeRule frameExtent*/
                recog.base.set_state(2700);
                recog.frameExtent()?;

                recog.base.set_state(2704);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == AFTER {
                    {
                        recog.base.set_state(2701);
                        recog.base.match_token(AFTER, &mut recog.err_handler)?;

                        recog.base.set_state(2702);
                        recog.base.match_token(MATCH, &mut recog.err_handler)?;

                        /*InvokeRule skipTo*/
                        recog.base.set_state(2703);
                        recog.skipTo()?;
                    }
                }

                recog.base.set_state(2707);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == INITIAL || _la == SEEK {
                    {
                        recog.base.set_state(2706);
                        _la = recog.base.input.la(1);
                        if { !(_la == INITIAL || _la == SEEK) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                recog.base.set_state(2714);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PATTERN {
                    {
                        recog.base.set_state(2709);
                        recog.base.match_token(PATTERN, &mut recog.err_handler)?;

                        recog.base.set_state(2710);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule rowPattern*/
                        recog.base.set_state(2711);
                        recog.rowPattern_rec(0)?;

                        recog.base.set_state(2712);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }

                recog.base.set_state(2725);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == SUBSET {
                    {
                        recog.base.set_state(2716);
                        recog.base.match_token(SUBSET, &mut recog.err_handler)?;

                        /*InvokeRule subsetDefinition*/
                        recog.base.set_state(2717);
                        recog.subsetDefinition()?;

                        recog.base.set_state(2722);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(2718);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule subsetDefinition*/
                                    recog.base.set_state(2719);
                                    recog.subsetDefinition()?;
                                }
                            }
                            recog.base.set_state(2724);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }

                recog.base.set_state(2736);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == DEFINE {
                    {
                        recog.base.set_state(2727);
                        recog.base.match_token(DEFINE, &mut recog.err_handler)?;

                        /*InvokeRule variableDefinition*/
                        recog.base.set_state(2728);
                        recog.variableDefinition()?;

                        recog.base.set_state(2733);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(2729);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule variableDefinition*/
                                    recog.base.set_state(2730);
                                    recog.variableDefinition()?;
                                }
                            }
                            recog.base.set_state(2735);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- frameExtent ----------------
pub type FrameExtentContextAll<'input> = FrameExtentContext<'input>;

pub type FrameExtentContext<'input> =
    BaseParserRuleContext<'input, FrameExtentContextExt<'input>>;

#[derive(Clone)]
pub struct FrameExtentContextExt<'input> {
    pub frameType: Option<TokenType<'input>>,
    pub start: Option<Rc<FrameBoundContextAll<'input>>>,
    pub end: Option<Rc<FrameBoundContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for FrameExtentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for FrameExtentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_frameExtent(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_frameExtent(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for FrameExtentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_frameExtent
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_frameExtent }
}
antlr_rust::tid! {FrameExtentContextExt<'a>}

impl<'input> FrameExtentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<FrameExtentContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            FrameExtentContextExt {
                frameType: None,
                start: None,
                end: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait FrameExtentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<FrameExtentContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token RANGE
    /// Returns `None` if there is no child corresponding to token RANGE
    fn RANGE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RANGE, 0)
    }
    fn frameBound_all(&self) -> Vec<Rc<FrameBoundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn frameBound(&self, i: usize) -> Option<Rc<FrameBoundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token ROWS
    /// Returns `None` if there is no child corresponding to token ROWS
    fn ROWS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROWS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GROUPS
    /// Returns `None` if there is no child corresponding to token GROUPS
    fn GROUPS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GROUPS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BETWEEN
    /// Returns `None` if there is no child corresponding to token BETWEEN
    fn BETWEEN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BETWEEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AND
    /// Returns `None` if there is no child corresponding to token AND
    fn AND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AND, 0)
    }
}

impl<'input> FrameExtentContextAttrs<'input> for FrameExtentContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn frameExtent(
        &mut self,
    ) -> Result<Rc<FrameExtentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            FrameExtentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 176, RULE_frameExtent);
        let mut _localctx: Rc<FrameExtentContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2762);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(365, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2738);
                        let tmp =
                            recog.base.match_token(RANGE, &mut recog.err_handler)?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).frameType =
                            Some(&tmp);

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2739);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).start =
                            Some(tmp.clone());
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2740);
                        let tmp = recog.base.match_token(ROWS, &mut recog.err_handler)?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).frameType =
                            Some(&tmp);

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2741);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).start =
                            Some(tmp.clone());
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(2742);
                        let tmp =
                            recog.base.match_token(GROUPS, &mut recog.err_handler)?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).frameType =
                            Some(&tmp);

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2743);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).start =
                            Some(tmp.clone());
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(2744);
                        let tmp =
                            recog.base.match_token(RANGE, &mut recog.err_handler)?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).frameType =
                            Some(&tmp);

                        recog.base.set_state(2745);
                        recog.base.match_token(BETWEEN, &mut recog.err_handler)?;

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2746);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).start =
                            Some(tmp.clone());

                        recog.base.set_state(2747);
                        recog.base.match_token(AND, &mut recog.err_handler)?;

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2748);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).end =
                            Some(tmp.clone());
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(2750);
                        let tmp = recog.base.match_token(ROWS, &mut recog.err_handler)?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).frameType =
                            Some(&tmp);

                        recog.base.set_state(2751);
                        recog.base.match_token(BETWEEN, &mut recog.err_handler)?;

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2752);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).start =
                            Some(tmp.clone());

                        recog.base.set_state(2753);
                        recog.base.match_token(AND, &mut recog.err_handler)?;

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2754);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).end =
                            Some(tmp.clone());
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        recog.base.set_state(2756);
                        let tmp =
                            recog.base.match_token(GROUPS, &mut recog.err_handler)?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).frameType =
                            Some(&tmp);

                        recog.base.set_state(2757);
                        recog.base.match_token(BETWEEN, &mut recog.err_handler)?;

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2758);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).start =
                            Some(tmp.clone());

                        recog.base.set_state(2759);
                        recog.base.match_token(AND, &mut recog.err_handler)?;

                        /*InvokeRule frameBound*/
                        recog.base.set_state(2760);
                        let tmp = recog.frameBound()?;
                        cast_mut::<_, FrameExtentContext>(&mut _localctx).end =
                            Some(tmp.clone());
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- frameBound ----------------
#[derive(Debug)]
pub enum FrameBoundContextAll<'input> {
    BoundedFrameContext(BoundedFrameContext<'input>),
    UnboundedFrameContext(UnboundedFrameContext<'input>),
    CurrentRowBoundContext(CurrentRowBoundContext<'input>),
    Error(FrameBoundContext<'input>),
}
antlr_rust::tid! {FrameBoundContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for FrameBoundContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for FrameBoundContextAll<'input> {}

impl<'input> Deref for FrameBoundContextAll<'input> {
    type Target = dyn FrameBoundContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use FrameBoundContextAll::*;
        match self {
            BoundedFrameContext(inner) => inner,
            UnboundedFrameContext(inner) => inner,
            CurrentRowBoundContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for FrameBoundContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type FrameBoundContext<'input> =
    BaseParserRuleContext<'input, FrameBoundContextExt<'input>>;

#[derive(Clone)]
pub struct FrameBoundContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for FrameBoundContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for FrameBoundContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for FrameBoundContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_frameBound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}
antlr_rust::tid! {FrameBoundContextExt<'a>}

impl<'input> FrameBoundContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<FrameBoundContextAll<'input>> {
        Rc::new(FrameBoundContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                FrameBoundContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait FrameBoundContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<FrameBoundContextExt<'input>>
{
}

impl<'input> FrameBoundContextAttrs<'input> for FrameBoundContext<'input> {}

pub type BoundedFrameContext<'input> =
    BaseParserRuleContext<'input, BoundedFrameContextExt<'input>>;

pub trait BoundedFrameContextAttrs<'input>: PrestoParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PRECEDING
    /// Returns `None` if there is no child corresponding to token PRECEDING
    fn PRECEDING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRECEDING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOLLOWING
    /// Returns `None` if there is no child corresponding to token FOLLOWING
    fn FOLLOWING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOLLOWING, 0)
    }
}

impl<'input> BoundedFrameContextAttrs<'input> for BoundedFrameContext<'input> {}

pub struct BoundedFrameContextExt<'input> {
    base: FrameBoundContextExt<'input>,
    pub boundType: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {BoundedFrameContextExt<'a>}

impl<'input> PrestoParserContext<'input> for BoundedFrameContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BoundedFrameContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_boundedFrame(self);
    }
}

impl<'input> CustomRuleContext<'input> for BoundedFrameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_frameBound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}

impl<'input> Borrow<FrameBoundContextExt<'input>> for BoundedFrameContext<'input> {
    fn borrow(&self) -> &FrameBoundContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<FrameBoundContextExt<'input>> for BoundedFrameContext<'input> {
    fn borrow_mut(&mut self) -> &mut FrameBoundContextExt<'input> {
        &mut self.base
    }
}

impl<'input> FrameBoundContextAttrs<'input> for BoundedFrameContext<'input> {}

impl<'input> BoundedFrameContextExt<'input> {
    fn new(ctx: &dyn FrameBoundContextAttrs<'input>) -> Rc<FrameBoundContextAll<'input>> {
        Rc::new(FrameBoundContextAll::BoundedFrameContext(
            BaseParserRuleContext::copy_from(
                ctx,
                BoundedFrameContextExt {
                    boundType: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type UnboundedFrameContext<'input> =
    BaseParserRuleContext<'input, UnboundedFrameContextExt<'input>>;

pub trait UnboundedFrameContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token UNBOUNDED
    /// Returns `None` if there is no child corresponding to token UNBOUNDED
    fn UNBOUNDED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNBOUNDED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRECEDING
    /// Returns `None` if there is no child corresponding to token PRECEDING
    fn PRECEDING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRECEDING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOLLOWING
    /// Returns `None` if there is no child corresponding to token FOLLOWING
    fn FOLLOWING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOLLOWING, 0)
    }
}

impl<'input> UnboundedFrameContextAttrs<'input> for UnboundedFrameContext<'input> {}

pub struct UnboundedFrameContextExt<'input> {
    base: FrameBoundContextExt<'input>,
    pub boundType: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UnboundedFrameContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UnboundedFrameContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for UnboundedFrameContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_unboundedFrame(self);
    }
}

impl<'input> CustomRuleContext<'input> for UnboundedFrameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_frameBound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}

impl<'input> Borrow<FrameBoundContextExt<'input>> for UnboundedFrameContext<'input> {
    fn borrow(&self) -> &FrameBoundContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<FrameBoundContextExt<'input>> for UnboundedFrameContext<'input> {
    fn borrow_mut(&mut self) -> &mut FrameBoundContextExt<'input> {
        &mut self.base
    }
}

impl<'input> FrameBoundContextAttrs<'input> for UnboundedFrameContext<'input> {}

impl<'input> UnboundedFrameContextExt<'input> {
    fn new(ctx: &dyn FrameBoundContextAttrs<'input>) -> Rc<FrameBoundContextAll<'input>> {
        Rc::new(FrameBoundContextAll::UnboundedFrameContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UnboundedFrameContextExt {
                    boundType: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CurrentRowBoundContext<'input> =
    BaseParserRuleContext<'input, CurrentRowBoundContextExt<'input>>;

pub trait CurrentRowBoundContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CURRENT
    /// Returns `None` if there is no child corresponding to token CURRENT
    fn CURRENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROW
    /// Returns `None` if there is no child corresponding to token ROW
    fn ROW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROW, 0)
    }
}

impl<'input> CurrentRowBoundContextAttrs<'input> for CurrentRowBoundContext<'input> {}

pub struct CurrentRowBoundContextExt<'input> {
    base: FrameBoundContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CurrentRowBoundContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CurrentRowBoundContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CurrentRowBoundContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_currentRowBound(self);
    }
}

impl<'input> CustomRuleContext<'input> for CurrentRowBoundContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_frameBound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}

impl<'input> Borrow<FrameBoundContextExt<'input>> for CurrentRowBoundContext<'input> {
    fn borrow(&self) -> &FrameBoundContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<FrameBoundContextExt<'input>> for CurrentRowBoundContext<'input> {
    fn borrow_mut(&mut self) -> &mut FrameBoundContextExt<'input> {
        &mut self.base
    }
}

impl<'input> FrameBoundContextAttrs<'input> for CurrentRowBoundContext<'input> {}

impl<'input> CurrentRowBoundContextExt<'input> {
    fn new(ctx: &dyn FrameBoundContextAttrs<'input>) -> Rc<FrameBoundContextAll<'input>> {
        Rc::new(FrameBoundContextAll::CurrentRowBoundContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CurrentRowBoundContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn frameBound(&mut self) -> Result<Rc<FrameBoundContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            FrameBoundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 178, RULE_frameBound);
        let mut _localctx: Rc<FrameBoundContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2773);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(366, &mut recog.base)? {
                1 => {
                    let tmp = UnboundedFrameContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2764);
                        recog.base.match_token(UNBOUNDED, &mut recog.err_handler)?;

                        recog.base.set_state(2765);
                        let tmp =
                            recog.base.match_token(PRECEDING, &mut recog.err_handler)?;
                        if let FrameBoundContextAll::UnboundedFrameContext(ctx) =
                            cast_mut::<_, FrameBoundContextAll>(&mut _localctx)
                        {
                            ctx.boundType = Some(&tmp);
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                2 => {
                    let tmp = UnboundedFrameContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2766);
                        recog.base.match_token(UNBOUNDED, &mut recog.err_handler)?;

                        recog.base.set_state(2767);
                        let tmp =
                            recog.base.match_token(FOLLOWING, &mut recog.err_handler)?;
                        if let FrameBoundContextAll::UnboundedFrameContext(ctx) =
                            cast_mut::<_, FrameBoundContextAll>(&mut _localctx)
                        {
                            ctx.boundType = Some(&tmp);
                        } else {
                            unreachable!("cant cast");
                        }
                    }
                }
                3 => {
                    let tmp = CurrentRowBoundContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2768);
                        recog.base.match_token(CURRENT, &mut recog.err_handler)?;

                        recog.base.set_state(2769);
                        recog.base.match_token(ROW, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    let tmp = BoundedFrameContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /*InvokeRule expression*/
                        recog.base.set_state(2770);
                        recog.expression()?;

                        recog.base.set_state(2771);
                        if let FrameBoundContextAll::BoundedFrameContext(ctx) =
                            cast_mut::<_, FrameBoundContextAll>(&mut _localctx)
                        {
                            ctx.boundType = recog.base.input.lt(1).cloned();
                        } else {
                            unreachable!("cant cast");
                        }
                        _la = recog.base.input.la(1);
                        if { !(_la == FOLLOWING || _la == PRECEDING) } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            if let FrameBoundContextAll::BoundedFrameContext(ctx) =
                                cast_mut::<_, FrameBoundContextAll>(&mut _localctx)
                            {
                                ctx.boundType = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- rowPattern ----------------
#[derive(Debug)]
pub enum RowPatternContextAll<'input> {
    QuantifiedPrimaryContext(QuantifiedPrimaryContext<'input>),
    PatternConcatenationContext(PatternConcatenationContext<'input>),
    PatternAlternationContext(PatternAlternationContext<'input>),
    Error(RowPatternContext<'input>),
}
antlr_rust::tid! {RowPatternContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for RowPatternContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for RowPatternContextAll<'input> {}

impl<'input> Deref for RowPatternContextAll<'input> {
    type Target = dyn RowPatternContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use RowPatternContextAll::*;
        match self {
            QuantifiedPrimaryContext(inner) => inner,
            PatternConcatenationContext(inner) => inner,
            PatternAlternationContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RowPatternContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type RowPatternContext<'input> =
    BaseParserRuleContext<'input, RowPatternContextExt<'input>>;

#[derive(Clone)]
pub struct RowPatternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RowPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RowPatternContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for RowPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rowPattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}
antlr_rust::tid! {RowPatternContextExt<'a>}

impl<'input> RowPatternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RowPatternContextAll<'input>> {
        Rc::new(RowPatternContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                RowPatternContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait RowPatternContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RowPatternContextExt<'input>>
{
}

impl<'input> RowPatternContextAttrs<'input> for RowPatternContext<'input> {}

pub type QuantifiedPrimaryContext<'input> =
    BaseParserRuleContext<'input, QuantifiedPrimaryContextExt<'input>>;

pub trait QuantifiedPrimaryContextAttrs<'input>: PrestoParserContext<'input> {
    fn patternPrimary(&self) -> Option<Rc<PatternPrimaryContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn patternQuantifier(&self) -> Option<Rc<PatternQuantifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> QuantifiedPrimaryContextAttrs<'input> for QuantifiedPrimaryContext<'input> {}

pub struct QuantifiedPrimaryContextExt<'input> {
    base: RowPatternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {QuantifiedPrimaryContextExt<'a>}

impl<'input> PrestoParserContext<'input> for QuantifiedPrimaryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QuantifiedPrimaryContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_quantifiedPrimary(self);
    }
}

impl<'input> CustomRuleContext<'input> for QuantifiedPrimaryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rowPattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}

impl<'input> Borrow<RowPatternContextExt<'input>> for QuantifiedPrimaryContext<'input> {
    fn borrow(&self) -> &RowPatternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RowPatternContextExt<'input>>
    for QuantifiedPrimaryContext<'input>
{
    fn borrow_mut(&mut self) -> &mut RowPatternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RowPatternContextAttrs<'input> for QuantifiedPrimaryContext<'input> {}

impl<'input> QuantifiedPrimaryContextExt<'input> {
    fn new(ctx: &dyn RowPatternContextAttrs<'input>) -> Rc<RowPatternContextAll<'input>> {
        Rc::new(RowPatternContextAll::QuantifiedPrimaryContext(
            BaseParserRuleContext::copy_from(
                ctx,
                QuantifiedPrimaryContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PatternConcatenationContext<'input> =
    BaseParserRuleContext<'input, PatternConcatenationContextExt<'input>>;

pub trait PatternConcatenationContextAttrs<'input>: PrestoParserContext<'input> {
    fn rowPattern_all(&self) -> Vec<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn rowPattern(&self, i: usize) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> PatternConcatenationContextAttrs<'input>
    for PatternConcatenationContext<'input>
{
}

pub struct PatternConcatenationContextExt<'input> {
    base: RowPatternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PatternConcatenationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PatternConcatenationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternConcatenationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_patternConcatenation(self);
    }
}

impl<'input> CustomRuleContext<'input> for PatternConcatenationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rowPattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}

impl<'input> Borrow<RowPatternContextExt<'input>>
    for PatternConcatenationContext<'input>
{
    fn borrow(&self) -> &RowPatternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RowPatternContextExt<'input>>
    for PatternConcatenationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut RowPatternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RowPatternContextAttrs<'input> for PatternConcatenationContext<'input> {}

impl<'input> PatternConcatenationContextExt<'input> {
    fn new(ctx: &dyn RowPatternContextAttrs<'input>) -> Rc<RowPatternContextAll<'input>> {
        Rc::new(RowPatternContextAll::PatternConcatenationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PatternConcatenationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PatternAlternationContext<'input> =
    BaseParserRuleContext<'input, PatternAlternationContextExt<'input>>;

pub trait PatternAlternationContextAttrs<'input>: PrestoParserContext<'input> {
    fn rowPattern_all(&self) -> Vec<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn rowPattern(&self, i: usize) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> PatternAlternationContextAttrs<'input>
    for PatternAlternationContext<'input>
{
}

pub struct PatternAlternationContextExt<'input> {
    base: RowPatternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PatternAlternationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PatternAlternationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternAlternationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_patternAlternation(self);
    }
}

impl<'input> CustomRuleContext<'input> for PatternAlternationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rowPattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}

impl<'input> Borrow<RowPatternContextExt<'input>> for PatternAlternationContext<'input> {
    fn borrow(&self) -> &RowPatternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<RowPatternContextExt<'input>>
    for PatternAlternationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut RowPatternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> RowPatternContextAttrs<'input> for PatternAlternationContext<'input> {}

impl<'input> PatternAlternationContextExt<'input> {
    fn new(ctx: &dyn RowPatternContextAttrs<'input>) -> Rc<RowPatternContextAll<'input>> {
        Rc::new(RowPatternContextAll::PatternAlternationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PatternAlternationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn rowPattern(&mut self) -> Result<Rc<RowPatternContextAll<'input>>, ANTLRError> {
        self.rowPattern_rec(0)
    }

    fn rowPattern_rec(
        &mut self,
        _p: isize,
    ) -> Result<Rc<RowPatternContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx =
            RowPatternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_recursion_rule(_localctx.clone(), 180, RULE_rowPattern, _p);
        let mut _localctx: Rc<RowPatternContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 180;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                {
                    let mut tmp = QuantifiedPrimaryContextExt::new(&**_localctx);
                    recog.ctx = Some(tmp.clone());
                    _localctx = tmp;
                    _prevctx = _localctx.clone();

                    /*InvokeRule patternPrimary*/
                    recog.base.set_state(2776);
                    recog.patternPrimary()?;

                    recog.base.set_state(2778);
                    recog.err_handler.sync(&mut recog.base)?;
                    match recog.interpreter.adaptive_predict(367, &mut recog.base)? {
                        x if x == 1 => {
                            {
                                /*InvokeRule patternQuantifier*/
                                recog.base.set_state(2777);
                                recog.patternQuantifier()?;
                            }
                        }

                        _ => {}
                    }
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(2787);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(369, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(2785);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog
                                .interpreter
                                .adaptive_predict(368, &mut recog.base)?
                            {
                                1 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = PatternConcatenationContextExt::new(
                                            &**RowPatternContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_rowPattern,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(2780);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 2)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        /*InvokeRule rowPattern*/
                                        recog.base.set_state(2781);
                                        recog.rowPattern_rec(3)?;
                                    }
                                }
                                2 => {
                                    {
                                        /*recRuleLabeledAltStartAction*/
                                        let mut tmp = PatternAlternationContextExt::new(
                                            &**RowPatternContextExt::new(
                                                _parentctx.clone(),
                                                _parentState,
                                            ),
                                        );
                                        recog.push_new_recursion_context(
                                            tmp.clone(),
                                            _startState,
                                            RULE_rowPattern,
                                        );
                                        _localctx = tmp;
                                        recog.base.set_state(2782);
                                        if !({ recog.precpred(None, 1) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some(
                                                    "recog.precpred(None, 1)".to_owned(),
                                                ),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(2783);
                                        recog
                                            .base
                                            .match_token(T__9, &mut recog.err_handler)?;

                                        /*InvokeRule rowPattern*/
                                        recog.base.set_state(2784);
                                        recog.rowPattern_rec(2)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(2789);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(369, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- patternPrimary ----------------
#[derive(Debug)]
pub enum PatternPrimaryContextAll<'input> {
    PatternPermutationContext(PatternPermutationContext<'input>),
    PartitionEndAnchorContext(PartitionEndAnchorContext<'input>),
    PatternVariableContext(PatternVariableContext<'input>),
    ExcludedPatternContext(ExcludedPatternContext<'input>),
    PartitionStartAnchorContext(PartitionStartAnchorContext<'input>),
    EmptyPatternContext(EmptyPatternContext<'input>),
    GroupedPatternContext(GroupedPatternContext<'input>),
    Error(PatternPrimaryContext<'input>),
}
antlr_rust::tid! {PatternPrimaryContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for PatternPrimaryContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for PatternPrimaryContextAll<'input> {}

impl<'input> Deref for PatternPrimaryContextAll<'input> {
    type Target = dyn PatternPrimaryContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use PatternPrimaryContextAll::*;
        match self {
            PatternPermutationContext(inner) => inner,
            PartitionEndAnchorContext(inner) => inner,
            PatternVariableContext(inner) => inner,
            ExcludedPatternContext(inner) => inner,
            PartitionStartAnchorContext(inner) => inner,
            EmptyPatternContext(inner) => inner,
            GroupedPatternContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternPrimaryContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type PatternPrimaryContext<'input> =
    BaseParserRuleContext<'input, PatternPrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct PatternPrimaryContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PatternPrimaryContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternPrimaryContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for PatternPrimaryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}
antlr_rust::tid! {PatternPrimaryContextExt<'a>}

impl<'input> PatternPrimaryContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                PatternPrimaryContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait PatternPrimaryContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PatternPrimaryContextExt<'input>>
{
}

impl<'input> PatternPrimaryContextAttrs<'input> for PatternPrimaryContext<'input> {}

pub type PatternPermutationContext<'input> =
    BaseParserRuleContext<'input, PatternPermutationContextExt<'input>>;

pub trait PatternPermutationContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PERMUTE
    /// Returns `None` if there is no child corresponding to token PERMUTE
    fn PERMUTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PERMUTE, 0)
    }
    fn rowPattern_all(&self) -> Vec<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn rowPattern(&self, i: usize) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> PatternPermutationContextAttrs<'input>
    for PatternPermutationContext<'input>
{
}

pub struct PatternPermutationContextExt<'input> {
    base: PatternPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PatternPermutationContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PatternPermutationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternPermutationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_patternPermutation(self);
    }
}

impl<'input> CustomRuleContext<'input> for PatternPermutationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>>
    for PatternPermutationContext<'input>
{
    fn borrow(&self) -> &PatternPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>>
    for PatternPermutationContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PatternPermutationContext<'input> {}

impl<'input> PatternPermutationContextExt<'input> {
    fn new(
        ctx: &dyn PatternPrimaryContextAttrs<'input>,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::PatternPermutationContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PatternPermutationContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PartitionEndAnchorContext<'input> =
    BaseParserRuleContext<'input, PartitionEndAnchorContextExt<'input>>;

pub trait PartitionEndAnchorContextAttrs<'input>: PrestoParserContext<'input> {}

impl<'input> PartitionEndAnchorContextAttrs<'input>
    for PartitionEndAnchorContext<'input>
{
}

pub struct PartitionEndAnchorContextExt<'input> {
    base: PatternPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PartitionEndAnchorContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PartitionEndAnchorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PartitionEndAnchorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_partitionEndAnchor(self);
    }
}

impl<'input> CustomRuleContext<'input> for PartitionEndAnchorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>>
    for PartitionEndAnchorContext<'input>
{
    fn borrow(&self) -> &PatternPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>>
    for PartitionEndAnchorContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PartitionEndAnchorContext<'input> {}

impl<'input> PartitionEndAnchorContextExt<'input> {
    fn new(
        ctx: &dyn PatternPrimaryContextAttrs<'input>,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::PartitionEndAnchorContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PartitionEndAnchorContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PatternVariableContext<'input> =
    BaseParserRuleContext<'input, PatternVariableContextExt<'input>>;

pub trait PatternVariableContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> PatternVariableContextAttrs<'input> for PatternVariableContext<'input> {}

pub struct PatternVariableContextExt<'input> {
    base: PatternPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PatternVariableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PatternVariableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternVariableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_patternVariable(self);
    }
}

impl<'input> CustomRuleContext<'input> for PatternVariableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for PatternVariableContext<'input> {
    fn borrow(&self) -> &PatternPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>>
    for PatternVariableContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PatternVariableContext<'input> {}

impl<'input> PatternVariableContextExt<'input> {
    fn new(
        ctx: &dyn PatternPrimaryContextAttrs<'input>,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::PatternVariableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PatternVariableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ExcludedPatternContext<'input> =
    BaseParserRuleContext<'input, ExcludedPatternContextExt<'input>>;

pub trait ExcludedPatternContextAttrs<'input>: PrestoParserContext<'input> {
    fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ExcludedPatternContextAttrs<'input> for ExcludedPatternContext<'input> {}

pub struct ExcludedPatternContextExt<'input> {
    base: PatternPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExcludedPatternContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExcludedPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ExcludedPatternContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_excludedPattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExcludedPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for ExcludedPatternContext<'input> {
    fn borrow(&self) -> &PatternPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>>
    for ExcludedPatternContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternPrimaryContextAttrs<'input> for ExcludedPatternContext<'input> {}

impl<'input> ExcludedPatternContextExt<'input> {
    fn new(
        ctx: &dyn PatternPrimaryContextAttrs<'input>,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::ExcludedPatternContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExcludedPatternContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type PartitionStartAnchorContext<'input> =
    BaseParserRuleContext<'input, PartitionStartAnchorContextExt<'input>>;

pub trait PartitionStartAnchorContextAttrs<'input>: PrestoParserContext<'input> {}

impl<'input> PartitionStartAnchorContextAttrs<'input>
    for PartitionStartAnchorContext<'input>
{
}

pub struct PartitionStartAnchorContextExt<'input> {
    base: PatternPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PartitionStartAnchorContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PartitionStartAnchorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PartitionStartAnchorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_partitionStartAnchor(self);
    }
}

impl<'input> CustomRuleContext<'input> for PartitionStartAnchorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>>
    for PartitionStartAnchorContext<'input>
{
    fn borrow(&self) -> &PatternPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>>
    for PartitionStartAnchorContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PartitionStartAnchorContext<'input> {}

impl<'input> PartitionStartAnchorContextExt<'input> {
    fn new(
        ctx: &dyn PatternPrimaryContextAttrs<'input>,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::PartitionStartAnchorContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PartitionStartAnchorContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type EmptyPatternContext<'input> =
    BaseParserRuleContext<'input, EmptyPatternContextExt<'input>>;

pub trait EmptyPatternContextAttrs<'input>: PrestoParserContext<'input> {}

impl<'input> EmptyPatternContextAttrs<'input> for EmptyPatternContext<'input> {}

pub struct EmptyPatternContextExt<'input> {
    base: PatternPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EmptyPatternContextExt<'a>}

impl<'input> PrestoParserContext<'input> for EmptyPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for EmptyPatternContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_emptyPattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for EmptyPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for EmptyPatternContext<'input> {
    fn borrow(&self) -> &PatternPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for EmptyPatternContext<'input> {
    fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternPrimaryContextAttrs<'input> for EmptyPatternContext<'input> {}

impl<'input> EmptyPatternContextExt<'input> {
    fn new(
        ctx: &dyn PatternPrimaryContextAttrs<'input>,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::EmptyPatternContext(
            BaseParserRuleContext::copy_from(
                ctx,
                EmptyPatternContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type GroupedPatternContext<'input> =
    BaseParserRuleContext<'input, GroupedPatternContextExt<'input>>;

pub trait GroupedPatternContextAttrs<'input>: PrestoParserContext<'input> {
    fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> GroupedPatternContextAttrs<'input> for GroupedPatternContext<'input> {}

pub struct GroupedPatternContextExt<'input> {
    base: PatternPrimaryContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {GroupedPatternContextExt<'a>}

impl<'input> PrestoParserContext<'input> for GroupedPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GroupedPatternContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_groupedPattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for GroupedPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternPrimary
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for GroupedPatternContext<'input> {
    fn borrow(&self) -> &PatternPrimaryContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>>
    for GroupedPatternContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternPrimaryContextAttrs<'input> for GroupedPatternContext<'input> {}

impl<'input> GroupedPatternContextExt<'input> {
    fn new(
        ctx: &dyn PatternPrimaryContextAttrs<'input>,
    ) -> Rc<PatternPrimaryContextAll<'input>> {
        Rc::new(PatternPrimaryContextAll::GroupedPatternContext(
            BaseParserRuleContext::copy_from(
                ctx,
                GroupedPatternContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn patternPrimary(
        &mut self,
    ) -> Result<Rc<PatternPrimaryContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PatternPrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 182, RULE_patternPrimary);
        let mut _localctx: Rc<PatternPrimaryContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2815);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(371, &mut recog.base)? {
                1 => {
                    let tmp = PatternVariableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule identifier*/
                        recog.base.set_state(2790);
                        recog.identifier()?;
                    }
                }
                2 => {
                    let tmp = EmptyPatternContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2791);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        recog.base.set_state(2792);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = PatternPermutationContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2793);
                        recog.base.match_token(PERMUTE, &mut recog.err_handler)?;

                        recog.base.set_state(2794);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule rowPattern*/
                        recog.base.set_state(2795);
                        recog.rowPattern_rec(0)?;

                        recog.base.set_state(2800);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(2796);
                                    recog
                                        .base
                                        .match_token(COMMA, &mut recog.err_handler)?;

                                    /*InvokeRule rowPattern*/
                                    recog.base.set_state(2797);
                                    recog.rowPattern_rec(0)?;
                                }
                            }
                            recog.base.set_state(2802);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(2803);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    let tmp = GroupedPatternContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2805);
                        recog.base.match_token(T__1, &mut recog.err_handler)?;

                        /*InvokeRule rowPattern*/
                        recog.base.set_state(2806);
                        recog.rowPattern_rec(0)?;

                        recog.base.set_state(2807);
                        recog.base.match_token(T__2, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    let tmp = PartitionStartAnchorContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2809);
                        recog.base.match_token(T__10, &mut recog.err_handler)?;
                    }
                }
                6 => {
                    let tmp = PartitionEndAnchorContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2810);
                        recog.base.match_token(T__11, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    let tmp = ExcludedPatternContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2811);
                        recog.base.match_token(T__12, &mut recog.err_handler)?;

                        /*InvokeRule rowPattern*/
                        recog.base.set_state(2812);
                        recog.rowPattern_rec(0)?;

                        recog.base.set_state(2813);
                        recog.base.match_token(T__13, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- patternQuantifier ----------------
#[derive(Debug)]
pub enum PatternQuantifierContextAll<'input> {
    ZeroOrMoreQuantifierContext(ZeroOrMoreQuantifierContext<'input>),
    OneOrMoreQuantifierContext(OneOrMoreQuantifierContext<'input>),
    ZeroOrOneQuantifierContext(ZeroOrOneQuantifierContext<'input>),
    RangeQuantifierContext(RangeQuantifierContext<'input>),
    Error(PatternQuantifierContext<'input>),
}
antlr_rust::tid! {PatternQuantifierContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for PatternQuantifierContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for PatternQuantifierContextAll<'input> {}

impl<'input> Deref for PatternQuantifierContextAll<'input> {
    type Target = dyn PatternQuantifierContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use PatternQuantifierContextAll::*;
        match self {
            ZeroOrMoreQuantifierContext(inner) => inner,
            OneOrMoreQuantifierContext(inner) => inner,
            ZeroOrOneQuantifierContext(inner) => inner,
            RangeQuantifierContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternQuantifierContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type PatternQuantifierContext<'input> =
    BaseParserRuleContext<'input, PatternQuantifierContextExt<'input>>;

#[derive(Clone)]
pub struct PatternQuantifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PatternQuantifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PatternQuantifierContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for PatternQuantifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternQuantifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}
antlr_rust::tid! {PatternQuantifierContextExt<'a>}

impl<'input> PatternQuantifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PatternQuantifierContextAll<'input>> {
        Rc::new(PatternQuantifierContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                PatternQuantifierContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait PatternQuantifierContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PatternQuantifierContextExt<'input>>
{
}

impl<'input> PatternQuantifierContextAttrs<'input> for PatternQuantifierContext<'input> {}

pub type ZeroOrMoreQuantifierContext<'input> =
    BaseParserRuleContext<'input, ZeroOrMoreQuantifierContextExt<'input>>;

pub trait ZeroOrMoreQuantifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ASTERISK
    /// Returns `None` if there is no child corresponding to token ASTERISK
    fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ASTERISK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token QUESTION_MARK
    /// Returns `None` if there is no child corresponding to token QUESTION_MARK
    fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUESTION_MARK, 0)
    }
}

impl<'input> ZeroOrMoreQuantifierContextAttrs<'input>
    for ZeroOrMoreQuantifierContext<'input>
{
}

pub struct ZeroOrMoreQuantifierContextExt<'input> {
    base: PatternQuantifierContextExt<'input>,
    pub reluctant: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ZeroOrMoreQuantifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ZeroOrMoreQuantifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ZeroOrMoreQuantifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_zeroOrMoreQuantifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for ZeroOrMoreQuantifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternQuantifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>>
    for ZeroOrMoreQuantifierContext<'input>
{
    fn borrow(&self) -> &PatternQuantifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>>
    for ZeroOrMoreQuantifierContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternQuantifierContextAttrs<'input>
    for ZeroOrMoreQuantifierContext<'input>
{
}

impl<'input> ZeroOrMoreQuantifierContextExt<'input> {
    fn new(
        ctx: &dyn PatternQuantifierContextAttrs<'input>,
    ) -> Rc<PatternQuantifierContextAll<'input>> {
        Rc::new(PatternQuantifierContextAll::ZeroOrMoreQuantifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ZeroOrMoreQuantifierContextExt {
                    reluctant: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type OneOrMoreQuantifierContext<'input> =
    BaseParserRuleContext<'input, OneOrMoreQuantifierContextExt<'input>>;

pub trait OneOrMoreQuantifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PLUS
    /// Returns `None` if there is no child corresponding to token PLUS
    fn PLUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PLUS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token QUESTION_MARK
    /// Returns `None` if there is no child corresponding to token QUESTION_MARK
    fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUESTION_MARK, 0)
    }
}

impl<'input> OneOrMoreQuantifierContextAttrs<'input>
    for OneOrMoreQuantifierContext<'input>
{
}

pub struct OneOrMoreQuantifierContextExt<'input> {
    base: PatternQuantifierContextExt<'input>,
    pub reluctant: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OneOrMoreQuantifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for OneOrMoreQuantifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for OneOrMoreQuantifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_oneOrMoreQuantifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for OneOrMoreQuantifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternQuantifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>>
    for OneOrMoreQuantifierContext<'input>
{
    fn borrow(&self) -> &PatternQuantifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>>
    for OneOrMoreQuantifierContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternQuantifierContextAttrs<'input>
    for OneOrMoreQuantifierContext<'input>
{
}

impl<'input> OneOrMoreQuantifierContextExt<'input> {
    fn new(
        ctx: &dyn PatternQuantifierContextAttrs<'input>,
    ) -> Rc<PatternQuantifierContextAll<'input>> {
        Rc::new(PatternQuantifierContextAll::OneOrMoreQuantifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                OneOrMoreQuantifierContextExt {
                    reluctant: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ZeroOrOneQuantifierContext<'input> =
    BaseParserRuleContext<'input, ZeroOrOneQuantifierContextExt<'input>>;

pub trait ZeroOrOneQuantifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves all `TerminalNode`s corresponding to token QUESTION_MARK in current rule
    fn QUESTION_MARK_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token QUESTION_MARK, starting from 0.
    /// Returns `None` if number of children corresponding to token QUESTION_MARK is less or equal than `i`.
    fn QUESTION_MARK(
        &self,
        i: usize,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUESTION_MARK, i)
    }
}

impl<'input> ZeroOrOneQuantifierContextAttrs<'input>
    for ZeroOrOneQuantifierContext<'input>
{
}

pub struct ZeroOrOneQuantifierContextExt<'input> {
    base: PatternQuantifierContextExt<'input>,
    pub reluctant: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ZeroOrOneQuantifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ZeroOrOneQuantifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ZeroOrOneQuantifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_zeroOrOneQuantifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for ZeroOrOneQuantifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternQuantifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>>
    for ZeroOrOneQuantifierContext<'input>
{
    fn borrow(&self) -> &PatternQuantifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>>
    for ZeroOrOneQuantifierContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternQuantifierContextAttrs<'input>
    for ZeroOrOneQuantifierContext<'input>
{
}

impl<'input> ZeroOrOneQuantifierContextExt<'input> {
    fn new(
        ctx: &dyn PatternQuantifierContextAttrs<'input>,
    ) -> Rc<PatternQuantifierContextAll<'input>> {
        Rc::new(PatternQuantifierContextAll::ZeroOrOneQuantifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ZeroOrOneQuantifierContextExt {
                    reluctant: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RangeQuantifierContext<'input> =
    BaseParserRuleContext<'input, RangeQuantifierContextExt<'input>>;

pub trait RangeQuantifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves all `TerminalNode`s corresponding to token INTEGER_VALUE in current rule
    fn INTEGER_VALUE_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token INTEGER_VALUE, starting from 0.
    /// Returns `None` if number of children corresponding to token INTEGER_VALUE is less or equal than `i`.
    fn INTEGER_VALUE(
        &self,
        i: usize,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER_VALUE, i)
    }
    /// Retrieves first TerminalNode corresponding to token QUESTION_MARK
    /// Returns `None` if there is no child corresponding to token QUESTION_MARK
    fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUESTION_MARK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
}

impl<'input> RangeQuantifierContextAttrs<'input> for RangeQuantifierContext<'input> {}

pub struct RangeQuantifierContextExt<'input> {
    base: PatternQuantifierContextExt<'input>,
    pub exactly: Option<TokenType<'input>>,
    pub reluctant: Option<TokenType<'input>>,
    pub atLeast: Option<TokenType<'input>>,
    pub atMost: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RangeQuantifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RangeQuantifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RangeQuantifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rangeQuantifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for RangeQuantifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_patternQuantifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>>
    for RangeQuantifierContext<'input>
{
    fn borrow(&self) -> &PatternQuantifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>>
    for RangeQuantifierContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PatternQuantifierContextAttrs<'input> for RangeQuantifierContext<'input> {}

impl<'input> RangeQuantifierContextExt<'input> {
    fn new(
        ctx: &dyn PatternQuantifierContextAttrs<'input>,
    ) -> Rc<PatternQuantifierContextAll<'input>> {
        Rc::new(PatternQuantifierContextAll::RangeQuantifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RangeQuantifierContextExt {
                    exactly: None,
                    reluctant: None,
                    atLeast: None,
                    atMost: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn patternQuantifier(
        &mut self,
    ) -> Result<Rc<PatternQuantifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PatternQuantifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 184, RULE_patternQuantifier);
        let mut _localctx: Rc<PatternQuantifierContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2847);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(379, &mut recog.base)? {
                1 => {
                    let tmp = ZeroOrMoreQuantifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2817);
                        recog.base.match_token(ASTERISK, &mut recog.err_handler)?;

                        recog.base.set_state(2819);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(372, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2818);
                                let tmp = recog
                                    .base
                                    .match_token(QUESTION_MARK, &mut recog.err_handler)?;
                                if let PatternQuantifierContextAll::ZeroOrMoreQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(&tmp); } else {unreachable!("cant cast");}
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    let tmp = OneOrMoreQuantifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2821);
                        recog.base.match_token(PLUS, &mut recog.err_handler)?;

                        recog.base.set_state(2823);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(373, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2822);
                                let tmp = recog
                                    .base
                                    .match_token(QUESTION_MARK, &mut recog.err_handler)?;
                                if let PatternQuantifierContextAll::OneOrMoreQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(&tmp); } else {unreachable!("cant cast");}
                            }

                            _ => {}
                        }
                    }
                }
                3 => {
                    let tmp = ZeroOrOneQuantifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2825);
                        recog
                            .base
                            .match_token(QUESTION_MARK, &mut recog.err_handler)?;

                        recog.base.set_state(2827);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(374, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2826);
                                let tmp = recog
                                    .base
                                    .match_token(QUESTION_MARK, &mut recog.err_handler)?;
                                if let PatternQuantifierContextAll::ZeroOrOneQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(&tmp); } else {unreachable!("cant cast");}
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    let tmp = RangeQuantifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2829);
                        recog.base.match_token(T__14, &mut recog.err_handler)?;

                        recog.base.set_state(2830);
                        let tmp = recog
                            .base
                            .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                        if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) =
                            cast_mut::<_, PatternQuantifierContextAll>(&mut _localctx)
                        {
                            ctx.exactly = Some(&tmp);
                        } else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(2831);
                        recog.base.match_token(T__15, &mut recog.err_handler)?;

                        recog.base.set_state(2833);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(375, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2832);
                                let tmp = recog
                                    .base
                                    .match_token(QUESTION_MARK, &mut recog.err_handler)?;
                                if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(&tmp); } else {unreachable!("cant cast");}
                            }

                            _ => {}
                        }
                    }
                }
                5 => {
                    let tmp = RangeQuantifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2835);
                        recog.base.match_token(T__14, &mut recog.err_handler)?;

                        recog.base.set_state(2837);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == INTEGER_VALUE {
                            {
                                recog.base.set_state(2836);
                                let tmp = recog
                                    .base
                                    .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                                if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
						ctx.atLeast = Some(&tmp); } else {unreachable!("cant cast");}
                            }
                        }

                        recog.base.set_state(2839);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(2841);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == INTEGER_VALUE {
                            {
                                recog.base.set_state(2840);
                                let tmp = recog
                                    .base
                                    .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                                if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
						ctx.atMost = Some(&tmp); } else {unreachable!("cant cast");}
                            }
                        }

                        recog.base.set_state(2843);
                        recog.base.match_token(T__15, &mut recog.err_handler)?;

                        recog.base.set_state(2845);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(378, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2844);
                                let tmp = recog
                                    .base
                                    .match_token(QUESTION_MARK, &mut recog.err_handler)?;
                                if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(&tmp); } else {unreachable!("cant cast");}
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- updateAssignment ----------------
pub type UpdateAssignmentContextAll<'input> = UpdateAssignmentContext<'input>;

pub type UpdateAssignmentContext<'input> =
    BaseParserRuleContext<'input, UpdateAssignmentContextExt<'input>>;

#[derive(Clone)]
pub struct UpdateAssignmentContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for UpdateAssignmentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for UpdateAssignmentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_updateAssignment(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_updateAssignment(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for UpdateAssignmentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_updateAssignment
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_updateAssignment }
}
antlr_rust::tid! {UpdateAssignmentContextExt<'a>}

impl<'input> UpdateAssignmentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<UpdateAssignmentContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            UpdateAssignmentContextExt { ph: PhantomData },
        ))
    }
}

pub trait UpdateAssignmentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<UpdateAssignmentContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token EQ
    /// Returns `None` if there is no child corresponding to token EQ
    fn EQ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EQ, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> UpdateAssignmentContextAttrs<'input> for UpdateAssignmentContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn updateAssignment(
        &mut self,
    ) -> Result<Rc<UpdateAssignmentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            UpdateAssignmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 186, RULE_updateAssignment);
        let mut _localctx: Rc<UpdateAssignmentContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(2849);
                recog.identifier()?;

                recog.base.set_state(2850);
                recog.base.match_token(EQ, &mut recog.err_handler)?;

                /*InvokeRule expression*/
                recog.base.set_state(2851);
                recog.expression()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- explainOption ----------------
#[derive(Debug)]
pub enum ExplainOptionContextAll<'input> {
    ExplainFormatContext(ExplainFormatContext<'input>),
    ExplainTypeContext(ExplainTypeContext<'input>),
    Error(ExplainOptionContext<'input>),
}
antlr_rust::tid! {ExplainOptionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for ExplainOptionContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for ExplainOptionContextAll<'input> {}

impl<'input> Deref for ExplainOptionContextAll<'input> {
    type Target = dyn ExplainOptionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use ExplainOptionContextAll::*;
        match self {
            ExplainFormatContext(inner) => inner,
            ExplainTypeContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ExplainOptionContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type ExplainOptionContext<'input> =
    BaseParserRuleContext<'input, ExplainOptionContextExt<'input>>;

#[derive(Clone)]
pub struct ExplainOptionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for ExplainOptionContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ExplainOptionContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for ExplainOptionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_explainOption
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_explainOption }
}
antlr_rust::tid! {ExplainOptionContextExt<'a>}

impl<'input> ExplainOptionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ExplainOptionContextAll<'input>> {
        Rc::new(ExplainOptionContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                ExplainOptionContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait ExplainOptionContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<ExplainOptionContextExt<'input>>
{
}

impl<'input> ExplainOptionContextAttrs<'input> for ExplainOptionContext<'input> {}

pub type ExplainFormatContext<'input> =
    BaseParserRuleContext<'input, ExplainFormatContextExt<'input>>;

pub trait ExplainFormatContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token FORMAT
    /// Returns `None` if there is no child corresponding to token FORMAT
    fn FORMAT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FORMAT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TEXT
    /// Returns `None` if there is no child corresponding to token TEXT
    fn TEXT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TEXT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRAPHVIZ
    /// Returns `None` if there is no child corresponding to token GRAPHVIZ
    fn GRAPHVIZ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRAPHVIZ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token JSON
    /// Returns `None` if there is no child corresponding to token JSON
    fn JSON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON, 0)
    }
}

impl<'input> ExplainFormatContextAttrs<'input> for ExplainFormatContext<'input> {}

pub struct ExplainFormatContextExt<'input> {
    base: ExplainOptionContextExt<'input>,
    pub value: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExplainFormatContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExplainFormatContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ExplainFormatContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_explainFormat(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExplainFormatContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_explainOption
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_explainOption }
}

impl<'input> Borrow<ExplainOptionContextExt<'input>> for ExplainFormatContext<'input> {
    fn borrow(&self) -> &ExplainOptionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExplainOptionContextExt<'input>> for ExplainFormatContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExplainOptionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExplainOptionContextAttrs<'input> for ExplainFormatContext<'input> {}

impl<'input> ExplainFormatContextExt<'input> {
    fn new(
        ctx: &dyn ExplainOptionContextAttrs<'input>,
    ) -> Rc<ExplainOptionContextAll<'input>> {
        Rc::new(ExplainOptionContextAll::ExplainFormatContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExplainFormatContextExt {
                    value: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ExplainTypeContext<'input> =
    BaseParserRuleContext<'input, ExplainTypeContextExt<'input>>;

pub trait ExplainTypeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token TYPE
    /// Returns `None` if there is no child corresponding to token TYPE
    fn TYPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TYPE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGICAL
    /// Returns `None` if there is no child corresponding to token LOGICAL
    fn LOGICAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGICAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DISTRIBUTED
    /// Returns `None` if there is no child corresponding to token DISTRIBUTED
    fn DISTRIBUTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DISTRIBUTED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VALIDATE
    /// Returns `None` if there is no child corresponding to token VALIDATE
    fn VALIDATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VALIDATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IO
    /// Returns `None` if there is no child corresponding to token IO
    fn IO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IO, 0)
    }
}

impl<'input> ExplainTypeContextAttrs<'input> for ExplainTypeContext<'input> {}

pub struct ExplainTypeContextExt<'input> {
    base: ExplainOptionContextExt<'input>,
    pub value: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ExplainTypeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ExplainTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ExplainTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_explainType(self);
    }
}

impl<'input> CustomRuleContext<'input> for ExplainTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_explainOption
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_explainOption }
}

impl<'input> Borrow<ExplainOptionContextExt<'input>> for ExplainTypeContext<'input> {
    fn borrow(&self) -> &ExplainOptionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExplainOptionContextExt<'input>> for ExplainTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExplainOptionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExplainOptionContextAttrs<'input> for ExplainTypeContext<'input> {}

impl<'input> ExplainTypeContextExt<'input> {
    fn new(
        ctx: &dyn ExplainOptionContextAttrs<'input>,
    ) -> Rc<ExplainOptionContextAll<'input>> {
        Rc::new(ExplainOptionContextAll::ExplainTypeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ExplainTypeContextExt {
                    value: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn explainOption(
        &mut self,
    ) -> Result<Rc<ExplainOptionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            ExplainOptionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 188, RULE_explainOption);
        let mut _localctx: Rc<ExplainOptionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2857);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                FORMAT => {
                    let tmp = ExplainFormatContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2853);
                        recog.base.match_token(FORMAT, &mut recog.err_handler)?;

                        recog.base.set_state(2854);
                        if let ExplainOptionContextAll::ExplainFormatContext(ctx) =
                            cast_mut::<_, ExplainOptionContextAll>(&mut _localctx)
                        {
                            ctx.value = recog.base.input.lt(1).cloned();
                        } else {
                            unreachable!("cant cast");
                        }
                        _la = recog.base.input.la(1);
                        if { !(_la == GRAPHVIZ || _la == JSON || _la == TEXT) } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            if let ExplainOptionContextAll::ExplainFormatContext(ctx) =
                                cast_mut::<_, ExplainOptionContextAll>(&mut _localctx)
                            {
                                ctx.value = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                TYPE => {
                    let tmp = ExplainTypeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2855);
                        recog.base.match_token(TYPE, &mut recog.err_handler)?;

                        recog.base.set_state(2856);
                        if let ExplainOptionContextAll::ExplainTypeContext(ctx) =
                            cast_mut::<_, ExplainOptionContextAll>(&mut _localctx)
                        {
                            ctx.value = recog.base.input.lt(1).cloned();
                        } else {
                            unreachable!("cant cast");
                        }
                        _la = recog.base.input.la(1);
                        if {
                            !(_la == DISTRIBUTED
                                || _la == IO
                                || _la == LOGICAL
                                || _la == VALIDATE)
                        } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            if let ExplainOptionContextAll::ExplainTypeContext(ctx) =
                                cast_mut::<_, ExplainOptionContextAll>(&mut _localctx)
                            {
                                ctx.value = Some(&tmp);
                            } else {
                                unreachable!("cant cast");
                            }
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- transactionMode ----------------
#[derive(Debug)]
pub enum TransactionModeContextAll<'input> {
    TransactionAccessModeContext(TransactionAccessModeContext<'input>),
    IsolationLevelContext(IsolationLevelContext<'input>),
    Error(TransactionModeContext<'input>),
}
antlr_rust::tid! {TransactionModeContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for TransactionModeContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for TransactionModeContextAll<'input> {}

impl<'input> Deref for TransactionModeContextAll<'input> {
    type Target = dyn TransactionModeContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use TransactionModeContextAll::*;
        match self {
            TransactionAccessModeContext(inner) => inner,
            IsolationLevelContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TransactionModeContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type TransactionModeContext<'input> =
    BaseParserRuleContext<'input, TransactionModeContextExt<'input>>;

#[derive(Clone)]
pub struct TransactionModeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for TransactionModeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TransactionModeContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for TransactionModeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_transactionMode
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_transactionMode }
}
antlr_rust::tid! {TransactionModeContextExt<'a>}

impl<'input> TransactionModeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<TransactionModeContextAll<'input>> {
        Rc::new(TransactionModeContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                TransactionModeContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait TransactionModeContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<TransactionModeContextExt<'input>>
{
}

impl<'input> TransactionModeContextAttrs<'input> for TransactionModeContext<'input> {}

pub type TransactionAccessModeContext<'input> =
    BaseParserRuleContext<'input, TransactionAccessModeContextExt<'input>>;

pub trait TransactionAccessModeContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token READ
    /// Returns `None` if there is no child corresponding to token READ
    fn READ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(READ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ONLY
    /// Returns `None` if there is no child corresponding to token ONLY
    fn ONLY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ONLY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WRITE
    /// Returns `None` if there is no child corresponding to token WRITE
    fn WRITE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WRITE, 0)
    }
}

impl<'input> TransactionAccessModeContextAttrs<'input>
    for TransactionAccessModeContext<'input>
{
}

pub struct TransactionAccessModeContextExt<'input> {
    base: TransactionModeContextExt<'input>,
    pub accessMode: Option<TokenType<'input>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TransactionAccessModeContextExt<'a>}

impl<'input> PrestoParserContext<'input> for TransactionAccessModeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for TransactionAccessModeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_transactionAccessMode(self);
    }
}

impl<'input> CustomRuleContext<'input> for TransactionAccessModeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_transactionMode
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_transactionMode }
}

impl<'input> Borrow<TransactionModeContextExt<'input>>
    for TransactionAccessModeContext<'input>
{
    fn borrow(&self) -> &TransactionModeContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<TransactionModeContextExt<'input>>
    for TransactionAccessModeContext<'input>
{
    fn borrow_mut(&mut self) -> &mut TransactionModeContextExt<'input> {
        &mut self.base
    }
}

impl<'input> TransactionModeContextAttrs<'input>
    for TransactionAccessModeContext<'input>
{
}

impl<'input> TransactionAccessModeContextExt<'input> {
    fn new(
        ctx: &dyn TransactionModeContextAttrs<'input>,
    ) -> Rc<TransactionModeContextAll<'input>> {
        Rc::new(TransactionModeContextAll::TransactionAccessModeContext(
            BaseParserRuleContext::copy_from(
                ctx,
                TransactionAccessModeContextExt {
                    accessMode: None,
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type IsolationLevelContext<'input> =
    BaseParserRuleContext<'input, IsolationLevelContextExt<'input>>;

pub trait IsolationLevelContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ISOLATION
    /// Returns `None` if there is no child corresponding to token ISOLATION
    fn ISOLATION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ISOLATION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LEVEL
    /// Returns `None` if there is no child corresponding to token LEVEL
    fn LEVEL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LEVEL, 0)
    }
    fn levelOfIsolation(&self) -> Option<Rc<LevelOfIsolationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IsolationLevelContextAttrs<'input> for IsolationLevelContext<'input> {}

pub struct IsolationLevelContextExt<'input> {
    base: TransactionModeContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IsolationLevelContextExt<'a>}

impl<'input> PrestoParserContext<'input> for IsolationLevelContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for IsolationLevelContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_isolationLevel(self);
    }
}

impl<'input> CustomRuleContext<'input> for IsolationLevelContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_transactionMode
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_transactionMode }
}

impl<'input> Borrow<TransactionModeContextExt<'input>> for IsolationLevelContext<'input> {
    fn borrow(&self) -> &TransactionModeContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<TransactionModeContextExt<'input>>
    for IsolationLevelContext<'input>
{
    fn borrow_mut(&mut self) -> &mut TransactionModeContextExt<'input> {
        &mut self.base
    }
}

impl<'input> TransactionModeContextAttrs<'input> for IsolationLevelContext<'input> {}

impl<'input> IsolationLevelContextExt<'input> {
    fn new(
        ctx: &dyn TransactionModeContextAttrs<'input>,
    ) -> Rc<TransactionModeContextAll<'input>> {
        Rc::new(TransactionModeContextAll::IsolationLevelContext(
            BaseParserRuleContext::copy_from(
                ctx,
                IsolationLevelContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn transactionMode(
        &mut self,
    ) -> Result<Rc<TransactionModeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            TransactionModeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 190, RULE_transactionMode);
        let mut _localctx: Rc<TransactionModeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2864);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ISOLATION => {
                    let tmp = IsolationLevelContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2859);
                        recog.base.match_token(ISOLATION, &mut recog.err_handler)?;

                        recog.base.set_state(2860);
                        recog.base.match_token(LEVEL, &mut recog.err_handler)?;

                        /*InvokeRule levelOfIsolation*/
                        recog.base.set_state(2861);
                        recog.levelOfIsolation()?;
                    }
                }

                READ => {
                    let tmp = TransactionAccessModeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2862);
                        recog.base.match_token(READ, &mut recog.err_handler)?;

                        recog.base.set_state(2863);
                        if let TransactionModeContextAll::TransactionAccessModeContext(
                            ctx,
                        ) = cast_mut::<_, TransactionModeContextAll>(&mut _localctx)
                        {
                            ctx.accessMode = recog.base.input.lt(1).cloned();
                        } else {
                            unreachable!("cant cast");
                        }
                        _la = recog.base.input.la(1);
                        if { !(_la == ONLY || _la == WRITE) } {
                            let tmp =
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            if let TransactionModeContextAll::TransactionAccessModeContext(ctx) = cast_mut::<_,TransactionModeContextAll >(&mut _localctx){
						ctx.accessMode = Some(&tmp); } else {unreachable!("cant cast");}
                        } else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- levelOfIsolation ----------------
#[derive(Debug)]
pub enum LevelOfIsolationContextAll<'input> {
    ReadUncommittedContext(ReadUncommittedContext<'input>),
    SerializableContext(SerializableContext<'input>),
    ReadCommittedContext(ReadCommittedContext<'input>),
    RepeatableReadContext(RepeatableReadContext<'input>),
    Error(LevelOfIsolationContext<'input>),
}
antlr_rust::tid! {LevelOfIsolationContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for LevelOfIsolationContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for LevelOfIsolationContextAll<'input> {}

impl<'input> Deref for LevelOfIsolationContextAll<'input> {
    type Target = dyn LevelOfIsolationContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use LevelOfIsolationContextAll::*;
        match self {
            ReadUncommittedContext(inner) => inner,
            SerializableContext(inner) => inner,
            ReadCommittedContext(inner) => inner,
            RepeatableReadContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for LevelOfIsolationContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type LevelOfIsolationContext<'input> =
    BaseParserRuleContext<'input, LevelOfIsolationContextExt<'input>>;

#[derive(Clone)]
pub struct LevelOfIsolationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for LevelOfIsolationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for LevelOfIsolationContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for LevelOfIsolationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_levelOfIsolation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}
antlr_rust::tid! {LevelOfIsolationContextExt<'a>}

impl<'input> LevelOfIsolationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<LevelOfIsolationContextAll<'input>> {
        Rc::new(LevelOfIsolationContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                LevelOfIsolationContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait LevelOfIsolationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<LevelOfIsolationContextExt<'input>>
{
}

impl<'input> LevelOfIsolationContextAttrs<'input> for LevelOfIsolationContext<'input> {}

pub type ReadUncommittedContext<'input> =
    BaseParserRuleContext<'input, ReadUncommittedContextExt<'input>>;

pub trait ReadUncommittedContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token READ
    /// Returns `None` if there is no child corresponding to token READ
    fn READ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(READ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNCOMMITTED
    /// Returns `None` if there is no child corresponding to token UNCOMMITTED
    fn UNCOMMITTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNCOMMITTED, 0)
    }
}

impl<'input> ReadUncommittedContextAttrs<'input> for ReadUncommittedContext<'input> {}

pub struct ReadUncommittedContextExt<'input> {
    base: LevelOfIsolationContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ReadUncommittedContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ReadUncommittedContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ReadUncommittedContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_readUncommitted(self);
    }
}

impl<'input> CustomRuleContext<'input> for ReadUncommittedContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_levelOfIsolation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>>
    for ReadUncommittedContext<'input>
{
    fn borrow(&self) -> &LevelOfIsolationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>>
    for ReadUncommittedContext<'input>
{
    fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for ReadUncommittedContext<'input> {}

impl<'input> ReadUncommittedContextExt<'input> {
    fn new(
        ctx: &dyn LevelOfIsolationContextAttrs<'input>,
    ) -> Rc<LevelOfIsolationContextAll<'input>> {
        Rc::new(LevelOfIsolationContextAll::ReadUncommittedContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ReadUncommittedContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SerializableContext<'input> =
    BaseParserRuleContext<'input, SerializableContextExt<'input>>;

pub trait SerializableContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SERIALIZABLE
    /// Returns `None` if there is no child corresponding to token SERIALIZABLE
    fn SERIALIZABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SERIALIZABLE, 0)
    }
}

impl<'input> SerializableContextAttrs<'input> for SerializableContext<'input> {}

pub struct SerializableContextExt<'input> {
    base: LevelOfIsolationContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SerializableContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SerializableContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SerializableContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_serializable(self);
    }
}

impl<'input> CustomRuleContext<'input> for SerializableContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_levelOfIsolation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>> for SerializableContext<'input> {
    fn borrow(&self) -> &LevelOfIsolationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>>
    for SerializableContext<'input>
{
    fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for SerializableContext<'input> {}

impl<'input> SerializableContextExt<'input> {
    fn new(
        ctx: &dyn LevelOfIsolationContextAttrs<'input>,
    ) -> Rc<LevelOfIsolationContextAll<'input>> {
        Rc::new(LevelOfIsolationContextAll::SerializableContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SerializableContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type ReadCommittedContext<'input> =
    BaseParserRuleContext<'input, ReadCommittedContextExt<'input>>;

pub trait ReadCommittedContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token READ
    /// Returns `None` if there is no child corresponding to token READ
    fn READ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(READ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMITTED
    /// Returns `None` if there is no child corresponding to token COMMITTED
    fn COMMITTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMITTED, 0)
    }
}

impl<'input> ReadCommittedContextAttrs<'input> for ReadCommittedContext<'input> {}

pub struct ReadCommittedContextExt<'input> {
    base: LevelOfIsolationContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ReadCommittedContextExt<'a>}

impl<'input> PrestoParserContext<'input> for ReadCommittedContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for ReadCommittedContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_readCommitted(self);
    }
}

impl<'input> CustomRuleContext<'input> for ReadCommittedContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_levelOfIsolation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>> for ReadCommittedContext<'input> {
    fn borrow(&self) -> &LevelOfIsolationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>>
    for ReadCommittedContext<'input>
{
    fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for ReadCommittedContext<'input> {}

impl<'input> ReadCommittedContextExt<'input> {
    fn new(
        ctx: &dyn LevelOfIsolationContextAttrs<'input>,
    ) -> Rc<LevelOfIsolationContextAll<'input>> {
        Rc::new(LevelOfIsolationContextAll::ReadCommittedContext(
            BaseParserRuleContext::copy_from(
                ctx,
                ReadCommittedContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RepeatableReadContext<'input> =
    BaseParserRuleContext<'input, RepeatableReadContextExt<'input>>;

pub trait RepeatableReadContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token REPEATABLE
    /// Returns `None` if there is no child corresponding to token REPEATABLE
    fn REPEATABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REPEATABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token READ
    /// Returns `None` if there is no child corresponding to token READ
    fn READ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(READ, 0)
    }
}

impl<'input> RepeatableReadContextAttrs<'input> for RepeatableReadContext<'input> {}

pub struct RepeatableReadContextExt<'input> {
    base: LevelOfIsolationContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RepeatableReadContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RepeatableReadContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RepeatableReadContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_repeatableRead(self);
    }
}

impl<'input> CustomRuleContext<'input> for RepeatableReadContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_levelOfIsolation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>>
    for RepeatableReadContext<'input>
{
    fn borrow(&self) -> &LevelOfIsolationContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>>
    for RepeatableReadContext<'input>
{
    fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> {
        &mut self.base
    }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for RepeatableReadContext<'input> {}

impl<'input> RepeatableReadContextExt<'input> {
    fn new(
        ctx: &dyn LevelOfIsolationContextAttrs<'input>,
    ) -> Rc<LevelOfIsolationContextAll<'input>> {
        Rc::new(LevelOfIsolationContextAll::RepeatableReadContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RepeatableReadContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn levelOfIsolation(
        &mut self,
    ) -> Result<Rc<LevelOfIsolationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            LevelOfIsolationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 192, RULE_levelOfIsolation);
        let mut _localctx: Rc<LevelOfIsolationContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2873);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(382, &mut recog.base)? {
                1 => {
                    let tmp = ReadUncommittedContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2866);
                        recog.base.match_token(READ, &mut recog.err_handler)?;

                        recog.base.set_state(2867);
                        recog
                            .base
                            .match_token(UNCOMMITTED, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    let tmp = ReadCommittedContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2868);
                        recog.base.match_token(READ, &mut recog.err_handler)?;

                        recog.base.set_state(2869);
                        recog.base.match_token(COMMITTED, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = RepeatableReadContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2870);
                        recog.base.match_token(REPEATABLE, &mut recog.err_handler)?;

                        recog.base.set_state(2871);
                        recog.base.match_token(READ, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    let tmp = SerializableContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2872);
                        recog
                            .base
                            .match_token(SERIALIZABLE, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- callArgument ----------------
#[derive(Debug)]
pub enum CallArgumentContextAll<'input> {
    PositionalArgumentContext(PositionalArgumentContext<'input>),
    NamedArgumentContext(NamedArgumentContext<'input>),
    Error(CallArgumentContext<'input>),
}
antlr_rust::tid! {CallArgumentContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for CallArgumentContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for CallArgumentContextAll<'input> {}

impl<'input> Deref for CallArgumentContextAll<'input> {
    type Target = dyn CallArgumentContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use CallArgumentContextAll::*;
        match self {
            PositionalArgumentContext(inner) => inner,
            NamedArgumentContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CallArgumentContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type CallArgumentContext<'input> =
    BaseParserRuleContext<'input, CallArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct CallArgumentContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for CallArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CallArgumentContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for CallArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_callArgument
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}
antlr_rust::tid! {CallArgumentContextExt<'a>}

impl<'input> CallArgumentContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<CallArgumentContextAll<'input>> {
        Rc::new(CallArgumentContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                CallArgumentContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait CallArgumentContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<CallArgumentContextExt<'input>>
{
}

impl<'input> CallArgumentContextAttrs<'input> for CallArgumentContext<'input> {}

pub type PositionalArgumentContext<'input> =
    BaseParserRuleContext<'input, PositionalArgumentContextExt<'input>>;

pub trait PositionalArgumentContextAttrs<'input>: PrestoParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> PositionalArgumentContextAttrs<'input>
    for PositionalArgumentContext<'input>
{
}

pub struct PositionalArgumentContextExt<'input> {
    base: CallArgumentContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PositionalArgumentContextExt<'a>}

impl<'input> PrestoParserContext<'input> for PositionalArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PositionalArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_positionalArgument(self);
    }
}

impl<'input> CustomRuleContext<'input> for PositionalArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_callArgument
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}

impl<'input> Borrow<CallArgumentContextExt<'input>>
    for PositionalArgumentContext<'input>
{
    fn borrow(&self) -> &CallArgumentContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<CallArgumentContextExt<'input>>
    for PositionalArgumentContext<'input>
{
    fn borrow_mut(&mut self) -> &mut CallArgumentContextExt<'input> {
        &mut self.base
    }
}

impl<'input> CallArgumentContextAttrs<'input> for PositionalArgumentContext<'input> {}

impl<'input> PositionalArgumentContextExt<'input> {
    fn new(
        ctx: &dyn CallArgumentContextAttrs<'input>,
    ) -> Rc<CallArgumentContextAll<'input>> {
        Rc::new(CallArgumentContextAll::PositionalArgumentContext(
            BaseParserRuleContext::copy_from(
                ctx,
                PositionalArgumentContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type NamedArgumentContext<'input> =
    BaseParserRuleContext<'input, NamedArgumentContextExt<'input>>;

pub trait NamedArgumentContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> NamedArgumentContextAttrs<'input> for NamedArgumentContext<'input> {}

pub struct NamedArgumentContextExt<'input> {
    base: CallArgumentContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NamedArgumentContextExt<'a>}

impl<'input> PrestoParserContext<'input> for NamedArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NamedArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namedArgument(self);
    }
}

impl<'input> CustomRuleContext<'input> for NamedArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_callArgument
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}

impl<'input> Borrow<CallArgumentContextExt<'input>> for NamedArgumentContext<'input> {
    fn borrow(&self) -> &CallArgumentContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<CallArgumentContextExt<'input>> for NamedArgumentContext<'input> {
    fn borrow_mut(&mut self) -> &mut CallArgumentContextExt<'input> {
        &mut self.base
    }
}

impl<'input> CallArgumentContextAttrs<'input> for NamedArgumentContext<'input> {}

impl<'input> NamedArgumentContextExt<'input> {
    fn new(
        ctx: &dyn CallArgumentContextAttrs<'input>,
    ) -> Rc<CallArgumentContextAll<'input>> {
        Rc::new(CallArgumentContextAll::NamedArgumentContext(
            BaseParserRuleContext::copy_from(
                ctx,
                NamedArgumentContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn callArgument(
        &mut self,
    ) -> Result<Rc<CallArgumentContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            CallArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 194, RULE_callArgument);
        let mut _localctx: Rc<CallArgumentContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2880);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(383, &mut recog.base)? {
                1 => {
                    let tmp = PositionalArgumentContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule expression*/
                        recog.base.set_state(2875);
                        recog.expression()?;
                    }
                }
                2 => {
                    let tmp = NamedArgumentContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /*InvokeRule identifier*/
                        recog.base.set_state(2876);
                        recog.identifier()?;

                        recog.base.set_state(2877);
                        recog.base.match_token(T__4, &mut recog.err_handler)?;

                        /*InvokeRule expression*/
                        recog.base.set_state(2878);
                        recog.expression()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- pathElement ----------------
#[derive(Debug)]
pub enum PathElementContextAll<'input> {
    QualifiedArgumentContext(QualifiedArgumentContext<'input>),
    UnqualifiedArgumentContext(UnqualifiedArgumentContext<'input>),
    Error(PathElementContext<'input>),
}
antlr_rust::tid! {PathElementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal
    for PathElementContextAll<'input>
{
}

impl<'input> PrestoParserContext<'input> for PathElementContextAll<'input> {}

impl<'input> Deref for PathElementContextAll<'input> {
    type Target = dyn PathElementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use PathElementContextAll::*;
        match self {
            QualifiedArgumentContext(inner) => inner,
            UnqualifiedArgumentContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PathElementContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type PathElementContext<'input> =
    BaseParserRuleContext<'input, PathElementContextExt<'input>>;

#[derive(Clone)]
pub struct PathElementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PathElementContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PathElementContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for PathElementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_pathElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_pathElement }
}
antlr_rust::tid! {PathElementContextExt<'a>}

impl<'input> PathElementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PathElementContextAll<'input>> {
        Rc::new(PathElementContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                PathElementContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait PathElementContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PathElementContextExt<'input>>
{
}

impl<'input> PathElementContextAttrs<'input> for PathElementContext<'input> {}

pub type QualifiedArgumentContext<'input> =
    BaseParserRuleContext<'input, QualifiedArgumentContextExt<'input>>;

pub trait QualifiedArgumentContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> QualifiedArgumentContextAttrs<'input> for QualifiedArgumentContext<'input> {}

pub struct QualifiedArgumentContextExt<'input> {
    base: PathElementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {QualifiedArgumentContextExt<'a>}

impl<'input> PrestoParserContext<'input> for QualifiedArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QualifiedArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_qualifiedArgument(self);
    }
}

impl<'input> CustomRuleContext<'input> for QualifiedArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_pathElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_pathElement }
}

impl<'input> Borrow<PathElementContextExt<'input>> for QualifiedArgumentContext<'input> {
    fn borrow(&self) -> &PathElementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PathElementContextExt<'input>>
    for QualifiedArgumentContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PathElementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PathElementContextAttrs<'input> for QualifiedArgumentContext<'input> {}

impl<'input> QualifiedArgumentContextExt<'input> {
    fn new(
        ctx: &dyn PathElementContextAttrs<'input>,
    ) -> Rc<PathElementContextAll<'input>> {
        Rc::new(PathElementContextAll::QualifiedArgumentContext(
            BaseParserRuleContext::copy_from(
                ctx,
                QualifiedArgumentContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type UnqualifiedArgumentContext<'input> =
    BaseParserRuleContext<'input, UnqualifiedArgumentContextExt<'input>>;

pub trait UnqualifiedArgumentContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> UnqualifiedArgumentContextAttrs<'input>
    for UnqualifiedArgumentContext<'input>
{
}

pub struct UnqualifiedArgumentContextExt<'input> {
    base: PathElementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UnqualifiedArgumentContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UnqualifiedArgumentContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for UnqualifiedArgumentContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_unqualifiedArgument(self);
    }
}

impl<'input> CustomRuleContext<'input> for UnqualifiedArgumentContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_pathElement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_pathElement }
}

impl<'input> Borrow<PathElementContextExt<'input>>
    for UnqualifiedArgumentContext<'input>
{
    fn borrow(&self) -> &PathElementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PathElementContextExt<'input>>
    for UnqualifiedArgumentContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PathElementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PathElementContextAttrs<'input> for UnqualifiedArgumentContext<'input> {}

impl<'input> UnqualifiedArgumentContextExt<'input> {
    fn new(
        ctx: &dyn PathElementContextAttrs<'input>,
    ) -> Rc<PathElementContextAll<'input>> {
        Rc::new(PathElementContextAll::UnqualifiedArgumentContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UnqualifiedArgumentContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn pathElement(
        &mut self,
    ) -> Result<Rc<PathElementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PathElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 196, RULE_pathElement);
        let mut _localctx: Rc<PathElementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2887);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(384, &mut recog.base)? {
                1 => {
                    let tmp = QualifiedArgumentContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule identifier*/
                        recog.base.set_state(2882);
                        recog.identifier()?;

                        recog.base.set_state(2883);
                        recog.base.match_token(T__0, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(2884);
                        recog.identifier()?;
                    }
                }
                2 => {
                    let tmp = UnqualifiedArgumentContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /*InvokeRule identifier*/
                        recog.base.set_state(2886);
                        recog.identifier()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- pathSpecification ----------------
pub type PathSpecificationContextAll<'input> = PathSpecificationContext<'input>;

pub type PathSpecificationContext<'input> =
    BaseParserRuleContext<'input, PathSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct PathSpecificationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PathSpecificationContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PathSpecificationContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_pathSpecification(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_pathSpecification(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for PathSpecificationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_pathSpecification
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_pathSpecification }
}
antlr_rust::tid! {PathSpecificationContextExt<'a>}

impl<'input> PathSpecificationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PathSpecificationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            PathSpecificationContextExt { ph: PhantomData },
        ))
    }
}

pub trait PathSpecificationContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PathSpecificationContextExt<'input>>
{
    fn pathElement_all(&self) -> Vec<Rc<PathElementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn pathElement(&self, i: usize) -> Option<Rc<PathElementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> PathSpecificationContextAttrs<'input> for PathSpecificationContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn pathSpecification(
        &mut self,
    ) -> Result<Rc<PathSpecificationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PathSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 198, RULE_pathSpecification);
        let mut _localctx: Rc<PathSpecificationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule pathElement*/
                recog.base.set_state(2889);
                recog.pathElement()?;

                recog.base.set_state(2894);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA {
                    {
                        {
                            recog.base.set_state(2890);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule pathElement*/
                            recog.base.set_state(2891);
                            recog.pathElement()?;
                        }
                    }
                    recog.base.set_state(2896);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- privilege ----------------
pub type PrivilegeContextAll<'input> = PrivilegeContext<'input>;

pub type PrivilegeContext<'input> =
    BaseParserRuleContext<'input, PrivilegeContextExt<'input>>;

#[derive(Clone)]
pub struct PrivilegeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PrivilegeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PrivilegeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_privilege(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_privilege(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for PrivilegeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_privilege
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_privilege }
}
antlr_rust::tid! {PrivilegeContextExt<'a>}

impl<'input> PrivilegeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PrivilegeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            PrivilegeContextExt { ph: PhantomData },
        ))
    }
}

pub trait PrivilegeContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PrivilegeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token CREATE
    /// Returns `None` if there is no child corresponding to token CREATE
    fn CREATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CREATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SELECT
    /// Returns `None` if there is no child corresponding to token SELECT
    fn SELECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SELECT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DELETE
    /// Returns `None` if there is no child corresponding to token DELETE
    fn DELETE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DELETE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INSERT
    /// Returns `None` if there is no child corresponding to token INSERT
    fn INSERT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INSERT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UPDATE
    /// Returns `None` if there is no child corresponding to token UPDATE
    fn UPDATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UPDATE, 0)
    }
}

impl<'input> PrivilegeContextAttrs<'input> for PrivilegeContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn privilege(&mut self) -> Result<Rc<PrivilegeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PrivilegeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 200, RULE_privilege);
        let mut _localctx: Rc<PrivilegeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2897);
                _la = recog.base.input.la(1);
                if {
                    !(_la == CREATE
                        || _la == DELETE
                        || _la == INSERT
                        || _la == SELECT
                        || _la == UPDATE)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- qualifiedName ----------------
pub type QualifiedNameContextAll<'input> = QualifiedNameContext<'input>;

pub type QualifiedNameContext<'input> =
    BaseParserRuleContext<'input, QualifiedNameContextExt<'input>>;

#[derive(Clone)]
pub struct QualifiedNameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QualifiedNameContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QualifiedNameContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_qualifiedName(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_qualifiedName(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for QualifiedNameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_qualifiedName
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_qualifiedName }
}
antlr_rust::tid! {QualifiedNameContextExt<'a>}

impl<'input> QualifiedNameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QualifiedNameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            QualifiedNameContextExt { ph: PhantomData },
        ))
    }
}

pub trait QualifiedNameContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QualifiedNameContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> QualifiedNameContextAttrs<'input> for QualifiedNameContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn qualifiedName(
        &mut self,
    ) -> Result<Rc<QualifiedNameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            QualifiedNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 202, RULE_qualifiedName);
        let mut _localctx: Rc<QualifiedNameContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(2899);
                recog.identifier()?;

                recog.base.set_state(2904);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(386, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(2900);
                                recog.base.match_token(T__0, &mut recog.err_handler)?;

                                /*InvokeRule identifier*/
                                recog.base.set_state(2901);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(2906);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(386, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- queryPeriod ----------------
pub type QueryPeriodContextAll<'input> = QueryPeriodContext<'input>;

pub type QueryPeriodContext<'input> =
    BaseParserRuleContext<'input, QueryPeriodContextExt<'input>>;

#[derive(Clone)]
pub struct QueryPeriodContextExt<'input> {
    pub end: Option<Rc<ValueExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for QueryPeriodContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QueryPeriodContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_queryPeriod(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_queryPeriod(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for QueryPeriodContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_queryPeriod
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_queryPeriod }
}
antlr_rust::tid! {QueryPeriodContextExt<'a>}

impl<'input> QueryPeriodContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<QueryPeriodContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            QueryPeriodContextExt {
                end: None,
                ph: PhantomData,
            },
        ))
    }
}

pub trait QueryPeriodContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<QueryPeriodContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token FOR
    /// Returns `None` if there is no child corresponding to token FOR
    fn FOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOR, 0)
    }
    fn rangeType(&self) -> Option<Rc<RangeTypeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token AS
    /// Returns `None` if there is no child corresponding to token AS
    fn AS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OF
    /// Returns `None` if there is no child corresponding to token OF
    fn OF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OF, 0)
    }
    fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> QueryPeriodContextAttrs<'input> for QueryPeriodContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn queryPeriod(
        &mut self,
    ) -> Result<Rc<QueryPeriodContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            QueryPeriodContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 204, RULE_queryPeriod);
        let mut _localctx: Rc<QueryPeriodContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2907);
                recog.base.match_token(FOR, &mut recog.err_handler)?;

                /*InvokeRule rangeType*/
                recog.base.set_state(2908);
                recog.rangeType()?;

                recog.base.set_state(2909);
                recog.base.match_token(AS, &mut recog.err_handler)?;

                recog.base.set_state(2910);
                recog.base.match_token(OF, &mut recog.err_handler)?;

                /*InvokeRule valueExpression*/
                recog.base.set_state(2911);
                let tmp = recog.valueExpression_rec(0)?;
                cast_mut::<_, QueryPeriodContext>(&mut _localctx).end = Some(tmp.clone());
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- rangeType ----------------
pub type RangeTypeContextAll<'input> = RangeTypeContext<'input>;

pub type RangeTypeContext<'input> =
    BaseParserRuleContext<'input, RangeTypeContextExt<'input>>;

#[derive(Clone)]
pub struct RangeTypeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RangeTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RangeTypeContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rangeType(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_rangeType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for RangeTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_rangeType
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_rangeType }
}
antlr_rust::tid! {RangeTypeContextExt<'a>}

impl<'input> RangeTypeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RangeTypeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            RangeTypeContextExt { ph: PhantomData },
        ))
    }
}

pub trait RangeTypeContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RangeTypeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token TIMESTAMP
    /// Returns `None` if there is no child corresponding to token TIMESTAMP
    fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIMESTAMP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VERSION
    /// Returns `None` if there is no child corresponding to token VERSION
    fn VERSION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VERSION, 0)
    }
}

impl<'input> RangeTypeContextAttrs<'input> for RangeTypeContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn rangeType(&mut self) -> Result<Rc<RangeTypeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            RangeTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 206, RULE_rangeType);
        let mut _localctx: Rc<RangeTypeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2913);
                _la = recog.base.input.la(1);
                if { !(_la == TIMESTAMP || _la == VERSION) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- grantor ----------------
#[derive(Debug)]
pub enum GrantorContextAll<'input> {
    CurrentUserGrantorContext(CurrentUserGrantorContext<'input>),
    SpecifiedPrincipalContext(SpecifiedPrincipalContext<'input>),
    CurrentRoleGrantorContext(CurrentRoleGrantorContext<'input>),
    Error(GrantorContext<'input>),
}
antlr_rust::tid! {GrantorContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for GrantorContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for GrantorContextAll<'input> {}

impl<'input> Deref for GrantorContextAll<'input> {
    type Target = dyn GrantorContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use GrantorContextAll::*;
        match self {
            CurrentUserGrantorContext(inner) => inner,
            SpecifiedPrincipalContext(inner) => inner,
            CurrentRoleGrantorContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for GrantorContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type GrantorContext<'input> =
    BaseParserRuleContext<'input, GrantorContextExt<'input>>;

#[derive(Clone)]
pub struct GrantorContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for GrantorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for GrantorContext<'input> {}

impl<'input> CustomRuleContext<'input> for GrantorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_grantor
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_grantor }
}
antlr_rust::tid! {GrantorContextExt<'a>}

impl<'input> GrantorContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<GrantorContextAll<'input>> {
        Rc::new(GrantorContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                GrantorContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait GrantorContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<GrantorContextExt<'input>>
{
}

impl<'input> GrantorContextAttrs<'input> for GrantorContext<'input> {}

pub type CurrentUserGrantorContext<'input> =
    BaseParserRuleContext<'input, CurrentUserGrantorContextExt<'input>>;

pub trait CurrentUserGrantorContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CURRENT_USER
    /// Returns `None` if there is no child corresponding to token CURRENT_USER
    fn CURRENT_USER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_USER, 0)
    }
}

impl<'input> CurrentUserGrantorContextAttrs<'input>
    for CurrentUserGrantorContext<'input>
{
}

pub struct CurrentUserGrantorContextExt<'input> {
    base: GrantorContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CurrentUserGrantorContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CurrentUserGrantorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CurrentUserGrantorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_currentUserGrantor(self);
    }
}

impl<'input> CustomRuleContext<'input> for CurrentUserGrantorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_grantor
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_grantor }
}

impl<'input> Borrow<GrantorContextExt<'input>> for CurrentUserGrantorContext<'input> {
    fn borrow(&self) -> &GrantorContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<GrantorContextExt<'input>> for CurrentUserGrantorContext<'input> {
    fn borrow_mut(&mut self) -> &mut GrantorContextExt<'input> {
        &mut self.base
    }
}

impl<'input> GrantorContextAttrs<'input> for CurrentUserGrantorContext<'input> {}

impl<'input> CurrentUserGrantorContextExt<'input> {
    fn new(ctx: &dyn GrantorContextAttrs<'input>) -> Rc<GrantorContextAll<'input>> {
        Rc::new(GrantorContextAll::CurrentUserGrantorContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CurrentUserGrantorContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type SpecifiedPrincipalContext<'input> =
    BaseParserRuleContext<'input, SpecifiedPrincipalContextExt<'input>>;

pub trait SpecifiedPrincipalContextAttrs<'input>: PrestoParserContext<'input> {
    fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SpecifiedPrincipalContextAttrs<'input>
    for SpecifiedPrincipalContext<'input>
{
}

pub struct SpecifiedPrincipalContextExt<'input> {
    base: GrantorContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SpecifiedPrincipalContextExt<'a>}

impl<'input> PrestoParserContext<'input> for SpecifiedPrincipalContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for SpecifiedPrincipalContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_specifiedPrincipal(self);
    }
}

impl<'input> CustomRuleContext<'input> for SpecifiedPrincipalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_grantor
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_grantor }
}

impl<'input> Borrow<GrantorContextExt<'input>> for SpecifiedPrincipalContext<'input> {
    fn borrow(&self) -> &GrantorContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<GrantorContextExt<'input>> for SpecifiedPrincipalContext<'input> {
    fn borrow_mut(&mut self) -> &mut GrantorContextExt<'input> {
        &mut self.base
    }
}

impl<'input> GrantorContextAttrs<'input> for SpecifiedPrincipalContext<'input> {}

impl<'input> SpecifiedPrincipalContextExt<'input> {
    fn new(ctx: &dyn GrantorContextAttrs<'input>) -> Rc<GrantorContextAll<'input>> {
        Rc::new(GrantorContextAll::SpecifiedPrincipalContext(
            BaseParserRuleContext::copy_from(
                ctx,
                SpecifiedPrincipalContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type CurrentRoleGrantorContext<'input> =
    BaseParserRuleContext<'input, CurrentRoleGrantorContextExt<'input>>;

pub trait CurrentRoleGrantorContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CURRENT_ROLE
    /// Returns `None` if there is no child corresponding to token CURRENT_ROLE
    fn CURRENT_ROLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT_ROLE, 0)
    }
}

impl<'input> CurrentRoleGrantorContextAttrs<'input>
    for CurrentRoleGrantorContext<'input>
{
}

pub struct CurrentRoleGrantorContextExt<'input> {
    base: GrantorContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CurrentRoleGrantorContextExt<'a>}

impl<'input> PrestoParserContext<'input> for CurrentRoleGrantorContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for CurrentRoleGrantorContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_currentRoleGrantor(self);
    }
}

impl<'input> CustomRuleContext<'input> for CurrentRoleGrantorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_grantor
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_grantor }
}

impl<'input> Borrow<GrantorContextExt<'input>> for CurrentRoleGrantorContext<'input> {
    fn borrow(&self) -> &GrantorContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<GrantorContextExt<'input>> for CurrentRoleGrantorContext<'input> {
    fn borrow_mut(&mut self) -> &mut GrantorContextExt<'input> {
        &mut self.base
    }
}

impl<'input> GrantorContextAttrs<'input> for CurrentRoleGrantorContext<'input> {}

impl<'input> CurrentRoleGrantorContextExt<'input> {
    fn new(ctx: &dyn GrantorContextAttrs<'input>) -> Rc<GrantorContextAll<'input>> {
        Rc::new(GrantorContextAll::CurrentRoleGrantorContext(
            BaseParserRuleContext::copy_from(
                ctx,
                CurrentRoleGrantorContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn grantor(&mut self) -> Result<Rc<GrantorContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            GrantorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_grantor);
        let mut _localctx: Rc<GrantorContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2918);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                ABSENT
                | ADD
                | ADMIN
                | AFTER
                | ALL
                | ANALYZE
                | ANY
                | ARRAY
                | ASC
                | AT
                | AUTHORIZATION
                | BERNOULLI
                | BOTH
                | CALL
                | CASCADE
                | CATALOGS
                | COLUMN
                | COLUMNS
                | COMMENT
                | COMMIT
                | COMMITTED
                | CONDITIONAL
                | COUNT
                | COPARTITION
                | CURRENT
                | DATA
                | DATE
                | DAY
                | DEFAULT
                | DEFINE
                | DEFINER
                | DENY
                | DESC
                | DESCRIPTOR
                | DISTRIBUTED
                | DOUBLE
                | EMPTY
                | ENCODING
                | ERROR
                | EXCLUDING
                | EXPLAIN
                | FETCH
                | FILTER
                | FINAL
                | FIRST
                | FOLLOWING
                | FORMAT
                | FUNCTIONS
                | GRACE
                | GRANT
                | GRANTED
                | GRANTS
                | GRAPHVIZ
                | GROUPS
                | HOUR
                | IF
                | IGNORE
                | INCLUDING
                | INITIAL
                | INPUT
                | INTERVAL
                | INVOKER
                | IO
                | ISOLATION
                | JSON
                | KEEP
                | KEY
                | KEYS
                | LAST
                | LATERAL
                | LEADING
                | LEVEL
                | LIMIT
                | LOCAL
                | LOGICAL
                | MAP
                | MATCH
                | MATCHED
                | MATCHES
                | MATCH_RECOGNIZE
                | MATERIALIZED
                | MEASURES
                | MERGE
                | MINUTE
                | MONTH
                | NEXT
                | NFC
                | NFD
                | NFKC
                | NFKD
                | NO
                | NONE
                | NULLIF
                | NULLS
                | OBJECT
                | OF
                | OFFSET
                | OMIT
                | ONE
                | ONLY
                | OPTION
                | ORDINALITY
                | OUTPUT
                | OVER
                | OVERFLOW
                | PARTITION
                | PARTITIONS
                | PASSING
                | PAST
                | PATH
                | PATTERN
                | PER
                | PERIOD
                | PERMUTE
                | POSITION
                | PRECEDING
                | PRECISION
                | PRIVILEGES
                | PROPERTIES
                | PRUNE
                | QUOTES
                | RANGE
                | READ
                | REFRESH
                | RENAME
                | REPEATABLE
                | REPLACE
                | RESET
                | RESPECT
                | RESTRICT
                | RETURNING
                | REVOKE
                | ROLE
                | ROLES
                | ROLLBACK
                | ROW
                | ROWS
                | RUNNING
                | SCALAR
                | SCHEMA
                | SCHEMAS
                | SECOND
                | SECURITY
                | SEEK
                | SERIALIZABLE
                | SESSION
                | SET
                | SETS
                | SHOW
                | SOME
                | START
                | STATS
                | SUBSET
                | SUBSTRING
                | SYSTEM
                | TABLES
                | TABLESAMPLE
                | TEXT
                | TEXT_STRING
                | TIES
                | TIME
                | TIMESTAMP
                | TO
                | TRAILING
                | TRANSACTION
                | TRUNCATE
                | TRY_CAST
                | TYPE
                | UNBOUNDED
                | UNCOMMITTED
                | UNCONDITIONAL
                | UNIQUE
                | UNKNOWN
                | UNMATCHED
                | UPDATE
                | USE
                | USER
                | UTF16
                | UTF32
                | UTF8
                | VALIDATE
                | VALUE
                | VERBOSE
                | VERSION
                | VIEW
                | WINDOW
                | WITHIN
                | WITHOUT
                | WORK
                | WRAPPER
                | WRITE
                | YEAR
                | ZONE
                | IDENTIFIER
                | DIGIT_IDENTIFIER
                | QUOTED_IDENTIFIER
                | BACKQUOTED_IDENTIFIER => {
                    let tmp = SpecifiedPrincipalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule principal*/
                        recog.base.set_state(2915);
                        recog.principal()?;
                    }
                }

                CURRENT_USER => {
                    let tmp = CurrentUserGrantorContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2916);
                        recog
                            .base
                            .match_token(CURRENT_USER, &mut recog.err_handler)?;
                    }
                }

                CURRENT_ROLE => {
                    let tmp = CurrentRoleGrantorContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2917);
                        recog
                            .base
                            .match_token(CURRENT_ROLE, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- principal ----------------
#[derive(Debug)]
pub enum PrincipalContextAll<'input> {
    UnspecifiedPrincipalContext(UnspecifiedPrincipalContext<'input>),
    UserPrincipalContext(UserPrincipalContext<'input>),
    RolePrincipalContext(RolePrincipalContext<'input>),
    Error(PrincipalContext<'input>),
}
antlr_rust::tid! {PrincipalContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PrincipalContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for PrincipalContextAll<'input> {}

impl<'input> Deref for PrincipalContextAll<'input> {
    type Target = dyn PrincipalContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use PrincipalContextAll::*;
        match self {
            UnspecifiedPrincipalContext(inner) => inner,
            UserPrincipalContext(inner) => inner,
            RolePrincipalContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PrincipalContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type PrincipalContext<'input> =
    BaseParserRuleContext<'input, PrincipalContextExt<'input>>;

#[derive(Clone)]
pub struct PrincipalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for PrincipalContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for PrincipalContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for PrincipalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_principal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}
antlr_rust::tid! {PrincipalContextExt<'a>}

impl<'input> PrincipalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<PrincipalContextAll<'input>> {
        Rc::new(PrincipalContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                PrincipalContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait PrincipalContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<PrincipalContextExt<'input>>
{
}

impl<'input> PrincipalContextAttrs<'input> for PrincipalContext<'input> {}

pub type UnspecifiedPrincipalContext<'input> =
    BaseParserRuleContext<'input, UnspecifiedPrincipalContextExt<'input>>;

pub trait UnspecifiedPrincipalContextAttrs<'input>: PrestoParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> UnspecifiedPrincipalContextAttrs<'input>
    for UnspecifiedPrincipalContext<'input>
{
}

pub struct UnspecifiedPrincipalContextExt<'input> {
    base: PrincipalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UnspecifiedPrincipalContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UnspecifiedPrincipalContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for UnspecifiedPrincipalContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_unspecifiedPrincipal(self);
    }
}

impl<'input> CustomRuleContext<'input> for UnspecifiedPrincipalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_principal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}

impl<'input> Borrow<PrincipalContextExt<'input>> for UnspecifiedPrincipalContext<'input> {
    fn borrow(&self) -> &PrincipalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrincipalContextExt<'input>>
    for UnspecifiedPrincipalContext<'input>
{
    fn borrow_mut(&mut self) -> &mut PrincipalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrincipalContextAttrs<'input> for UnspecifiedPrincipalContext<'input> {}

impl<'input> UnspecifiedPrincipalContextExt<'input> {
    fn new(ctx: &dyn PrincipalContextAttrs<'input>) -> Rc<PrincipalContextAll<'input>> {
        Rc::new(PrincipalContextAll::UnspecifiedPrincipalContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UnspecifiedPrincipalContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type UserPrincipalContext<'input> =
    BaseParserRuleContext<'input, UserPrincipalContextExt<'input>>;

pub trait UserPrincipalContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token USER
    /// Returns `None` if there is no child corresponding to token USER
    fn USER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(USER, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> UserPrincipalContextAttrs<'input> for UserPrincipalContext<'input> {}

pub struct UserPrincipalContextExt<'input> {
    base: PrincipalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UserPrincipalContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UserPrincipalContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for UserPrincipalContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_userPrincipal(self);
    }
}

impl<'input> CustomRuleContext<'input> for UserPrincipalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_principal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}

impl<'input> Borrow<PrincipalContextExt<'input>> for UserPrincipalContext<'input> {
    fn borrow(&self) -> &PrincipalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrincipalContextExt<'input>> for UserPrincipalContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrincipalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrincipalContextAttrs<'input> for UserPrincipalContext<'input> {}

impl<'input> UserPrincipalContextExt<'input> {
    fn new(ctx: &dyn PrincipalContextAttrs<'input>) -> Rc<PrincipalContextAll<'input>> {
        Rc::new(PrincipalContextAll::UserPrincipalContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UserPrincipalContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type RolePrincipalContext<'input> =
    BaseParserRuleContext<'input, RolePrincipalContextExt<'input>>;

pub trait RolePrincipalContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token ROLE
    /// Returns `None` if there is no child corresponding to token ROLE
    fn ROLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> RolePrincipalContextAttrs<'input> for RolePrincipalContext<'input> {}

pub struct RolePrincipalContextExt<'input> {
    base: PrincipalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {RolePrincipalContextExt<'a>}

impl<'input> PrestoParserContext<'input> for RolePrincipalContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for RolePrincipalContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_rolePrincipal(self);
    }
}

impl<'input> CustomRuleContext<'input> for RolePrincipalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_principal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}

impl<'input> Borrow<PrincipalContextExt<'input>> for RolePrincipalContext<'input> {
    fn borrow(&self) -> &PrincipalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<PrincipalContextExt<'input>> for RolePrincipalContext<'input> {
    fn borrow_mut(&mut self) -> &mut PrincipalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> PrincipalContextAttrs<'input> for RolePrincipalContext<'input> {}

impl<'input> RolePrincipalContextExt<'input> {
    fn new(ctx: &dyn PrincipalContextAttrs<'input>) -> Rc<PrincipalContextAll<'input>> {
        Rc::new(PrincipalContextAll::RolePrincipalContext(
            BaseParserRuleContext::copy_from(
                ctx,
                RolePrincipalContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn principal(&mut self) -> Result<Rc<PrincipalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            PrincipalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 210, RULE_principal);
        let mut _localctx: Rc<PrincipalContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2925);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(388, &mut recog.base)? {
                1 => {
                    let tmp = UnspecifiedPrincipalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /*InvokeRule identifier*/
                        recog.base.set_state(2920);
                        recog.identifier()?;
                    }
                }
                2 => {
                    let tmp = UserPrincipalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2921);
                        recog.base.match_token(USER, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(2922);
                        recog.identifier()?;
                    }
                }
                3 => {
                    let tmp = RolePrincipalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2923);
                        recog.base.match_token(ROLE, &mut recog.err_handler)?;

                        /*InvokeRule identifier*/
                        recog.base.set_state(2924);
                        recog.identifier()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- roles ----------------
pub type RolesContextAll<'input> = RolesContext<'input>;

pub type RolesContext<'input> = BaseParserRuleContext<'input, RolesContextExt<'input>>;

#[derive(Clone)]
pub struct RolesContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for RolesContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for RolesContext<'input> {
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_roles(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_roles(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for RolesContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_roles
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_roles }
}
antlr_rust::tid! {RolesContextExt<'a>}

impl<'input> RolesContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<RolesContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            RolesContextExt { ph: PhantomData },
        ))
    }
}

pub trait RolesContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<RolesContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> RolesContextAttrs<'input> for RolesContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn roles(&mut self) -> Result<Rc<RolesContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            RolesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_roles);
        let mut _localctx: Rc<RolesContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /*InvokeRule identifier*/
                recog.base.set_state(2927);
                recog.identifier()?;

                recog.base.set_state(2932);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA {
                    {
                        {
                            recog.base.set_state(2928);
                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                            /*InvokeRule identifier*/
                            recog.base.set_state(2929);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(2934);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- identifier ----------------
#[derive(Debug)]
pub enum IdentifierContextAll<'input> {
    BackQuotedIdentifierContext(BackQuotedIdentifierContext<'input>),
    QuotedIdentifierContext(QuotedIdentifierContext<'input>),
    DigitIdentifierContext(DigitIdentifierContext<'input>),
    UnquotedIdentifierContext(UnquotedIdentifierContext<'input>),
    Error(IdentifierContext<'input>),
}
antlr_rust::tid! {IdentifierContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for IdentifierContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for IdentifierContextAll<'input> {}

impl<'input> Deref for IdentifierContextAll<'input> {
    type Target = dyn IdentifierContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use IdentifierContextAll::*;
        match self {
            BackQuotedIdentifierContext(inner) => inner,
            QuotedIdentifierContext(inner) => inner,
            DigitIdentifierContext(inner) => inner,
            UnquotedIdentifierContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for IdentifierContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type IdentifierContext<'input> =
    BaseParserRuleContext<'input, IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for IdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for IdentifierContext<'input>
{
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid! {IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(IdentifierContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                IdentifierContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait IdentifierContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<IdentifierContextExt<'input>>
{
}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input> {}

pub type BackQuotedIdentifierContext<'input> =
    BaseParserRuleContext<'input, BackQuotedIdentifierContextExt<'input>>;

pub trait BackQuotedIdentifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BACKQUOTED_IDENTIFIER
    /// Returns `None` if there is no child corresponding to token BACKQUOTED_IDENTIFIER
    fn BACKQUOTED_IDENTIFIER(
        &self,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BACKQUOTED_IDENTIFIER, 0)
    }
}

impl<'input> BackQuotedIdentifierContextAttrs<'input>
    for BackQuotedIdentifierContext<'input>
{
}

pub struct BackQuotedIdentifierContextExt<'input> {
    base: IdentifierContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {BackQuotedIdentifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for BackQuotedIdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for BackQuotedIdentifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_backQuotedIdentifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for BackQuotedIdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}

impl<'input> Borrow<IdentifierContextExt<'input>>
    for BackQuotedIdentifierContext<'input>
{
    fn borrow(&self) -> &IdentifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<IdentifierContextExt<'input>>
    for BackQuotedIdentifierContext<'input>
{
    fn borrow_mut(&mut self) -> &mut IdentifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> IdentifierContextAttrs<'input> for BackQuotedIdentifierContext<'input> {}

impl<'input> BackQuotedIdentifierContextExt<'input> {
    fn new(ctx: &dyn IdentifierContextAttrs<'input>) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(IdentifierContextAll::BackQuotedIdentifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                BackQuotedIdentifierContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type QuotedIdentifierContext<'input> =
    BaseParserRuleContext<'input, QuotedIdentifierContextExt<'input>>;

pub trait QuotedIdentifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token QUOTED_IDENTIFIER
    /// Returns `None` if there is no child corresponding to token QUOTED_IDENTIFIER
    fn QUOTED_IDENTIFIER(
        &self,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUOTED_IDENTIFIER, 0)
    }
}

impl<'input> QuotedIdentifierContextAttrs<'input> for QuotedIdentifierContext<'input> {}

pub struct QuotedIdentifierContextExt<'input> {
    base: IdentifierContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {QuotedIdentifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for QuotedIdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for QuotedIdentifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_quotedIdentifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for QuotedIdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}

impl<'input> Borrow<IdentifierContextExt<'input>> for QuotedIdentifierContext<'input> {
    fn borrow(&self) -> &IdentifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<IdentifierContextExt<'input>> for QuotedIdentifierContext<'input> {
    fn borrow_mut(&mut self) -> &mut IdentifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> IdentifierContextAttrs<'input> for QuotedIdentifierContext<'input> {}

impl<'input> QuotedIdentifierContextExt<'input> {
    fn new(ctx: &dyn IdentifierContextAttrs<'input>) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(IdentifierContextAll::QuotedIdentifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                QuotedIdentifierContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DigitIdentifierContext<'input> =
    BaseParserRuleContext<'input, DigitIdentifierContextExt<'input>>;

pub trait DigitIdentifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DIGIT_IDENTIFIER
    /// Returns `None` if there is no child corresponding to token DIGIT_IDENTIFIER
    fn DIGIT_IDENTIFIER(
        &self,
    ) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DIGIT_IDENTIFIER, 0)
    }
}

impl<'input> DigitIdentifierContextAttrs<'input> for DigitIdentifierContext<'input> {}

pub struct DigitIdentifierContextExt<'input> {
    base: IdentifierContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DigitIdentifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DigitIdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DigitIdentifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_digitIdentifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for DigitIdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}

impl<'input> Borrow<IdentifierContextExt<'input>> for DigitIdentifierContext<'input> {
    fn borrow(&self) -> &IdentifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<IdentifierContextExt<'input>> for DigitIdentifierContext<'input> {
    fn borrow_mut(&mut self) -> &mut IdentifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> IdentifierContextAttrs<'input> for DigitIdentifierContext<'input> {}

impl<'input> DigitIdentifierContextExt<'input> {
    fn new(ctx: &dyn IdentifierContextAttrs<'input>) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(IdentifierContextAll::DigitIdentifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DigitIdentifierContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type UnquotedIdentifierContext<'input> =
    BaseParserRuleContext<'input, UnquotedIdentifierContextExt<'input>>;

pub trait UnquotedIdentifierContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token IDENTIFIER
    /// Returns `None` if there is no child corresponding to token IDENTIFIER
    fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IDENTIFIER, 0)
    }
    fn nonReserved(&self) -> Option<Rc<NonReservedContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> UnquotedIdentifierContextAttrs<'input>
    for UnquotedIdentifierContext<'input>
{
}

pub struct UnquotedIdentifierContextExt<'input> {
    base: IdentifierContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {UnquotedIdentifierContextExt<'a>}

impl<'input> PrestoParserContext<'input> for UnquotedIdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for UnquotedIdentifierContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_unquotedIdentifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for UnquotedIdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}

impl<'input> Borrow<IdentifierContextExt<'input>> for UnquotedIdentifierContext<'input> {
    fn borrow(&self) -> &IdentifierContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<IdentifierContextExt<'input>>
    for UnquotedIdentifierContext<'input>
{
    fn borrow_mut(&mut self) -> &mut IdentifierContextExt<'input> {
        &mut self.base
    }
}

impl<'input> IdentifierContextAttrs<'input> for UnquotedIdentifierContext<'input> {}

impl<'input> UnquotedIdentifierContextExt<'input> {
    fn new(ctx: &dyn IdentifierContextAttrs<'input>) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(IdentifierContextAll::UnquotedIdentifierContext(
            BaseParserRuleContext::copy_from(
                ctx,
                UnquotedIdentifierContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn identifier(&mut self) -> Result<Rc<IdentifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 214, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2940);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                IDENTIFIER => {
                    let tmp = UnquotedIdentifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2935);
                        recog.base.match_token(IDENTIFIER, &mut recog.err_handler)?;
                    }
                }

                QUOTED_IDENTIFIER => {
                    let tmp = QuotedIdentifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2936);
                        recog
                            .base
                            .match_token(QUOTED_IDENTIFIER, &mut recog.err_handler)?;
                    }
                }

                ABSENT | ADD | ADMIN | AFTER | ALL | ANALYZE | ANY | ARRAY | ASC | AT
                | AUTHORIZATION | BERNOULLI | BOTH | CALL | CASCADE | CATALOGS
                | COLUMN | COLUMNS | COMMENT | COMMIT | COMMITTED | CONDITIONAL
                | COUNT | COPARTITION | CURRENT | DATA | DATE | DAY | DEFAULT
                | DEFINE | DEFINER | DENY | DESC | DESCRIPTOR | DISTRIBUTED | DOUBLE
                | EMPTY | ENCODING | ERROR | EXCLUDING | EXPLAIN | FETCH | FILTER
                | FINAL | FIRST | FOLLOWING | FORMAT | FUNCTIONS | GRACE | GRANT
                | GRANTED | GRANTS | GRAPHVIZ | GROUPS | HOUR | IF | IGNORE
                | INCLUDING | INITIAL | INPUT | INTERVAL | INVOKER | IO | ISOLATION
                | JSON | KEEP | KEY | KEYS | LAST | LATERAL | LEADING | LEVEL | LIMIT
                | LOCAL | LOGICAL | MAP | MATCH | MATCHED | MATCHES | MATCH_RECOGNIZE
                | MATERIALIZED | MEASURES | MERGE | MINUTE | MONTH | NEXT | NFC | NFD
                | NFKC | NFKD | NO | NONE | NULLIF | NULLS | OBJECT | OF | OFFSET
                | OMIT | ONE | ONLY | OPTION | ORDINALITY | OUTPUT | OVER | OVERFLOW
                | PARTITION | PARTITIONS | PASSING | PAST | PATH | PATTERN | PER
                | PERIOD | PERMUTE | POSITION | PRECEDING | PRECISION | PRIVILEGES
                | PROPERTIES | PRUNE | QUOTES | RANGE | READ | REFRESH | RENAME
                | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RETURNING
                | REVOKE | ROLE | ROLES | ROLLBACK | ROW | ROWS | RUNNING | SCALAR
                | SCHEMA | SCHEMAS | SECOND | SECURITY | SEEK | SERIALIZABLE
                | SESSION | SET | SETS | SHOW | SOME | START | STATS | SUBSET
                | SUBSTRING | SYSTEM | TABLES | TABLESAMPLE | TEXT | TEXT_STRING
                | TIES | TIME | TIMESTAMP | TO | TRAILING | TRANSACTION | TRUNCATE
                | TRY_CAST | TYPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNIQUE
                | UNKNOWN | UNMATCHED | UPDATE | USE | USER | UTF16 | UTF32 | UTF8
                | VALIDATE | VALUE | VERBOSE | VERSION | VIEW | WINDOW | WITHIN
                | WITHOUT | WORK | WRAPPER | WRITE | YEAR | ZONE => {
                    let tmp = UnquotedIdentifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /*InvokeRule nonReserved*/
                        recog.base.set_state(2937);
                        recog.nonReserved()?;
                    }
                }

                BACKQUOTED_IDENTIFIER => {
                    let tmp = BackQuotedIdentifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2938);
                        recog
                            .base
                            .match_token(BACKQUOTED_IDENTIFIER, &mut recog.err_handler)?;
                    }
                }

                DIGIT_IDENTIFIER => {
                    let tmp = DigitIdentifierContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2939);
                        recog
                            .base
                            .match_token(DIGIT_IDENTIFIER, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(
                    &mut recog.base,
                )))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number ----------------
#[derive(Debug)]
pub enum NumberContextAll<'input> {
    DecimalLiteralContext(DecimalLiteralContext<'input>),
    DoubleLiteralContext(DoubleLiteralContext<'input>),
    IntegerLiteralContext(IntegerLiteralContext<'input>),
    Error(NumberContext<'input>),
}
antlr_rust::tid! {NumberContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for NumberContextAll<'input> {}

impl<'input> PrestoParserContext<'input> for NumberContextAll<'input> {}

impl<'input> Deref for NumberContextAll<'input> {
    type Target = dyn NumberContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use NumberContextAll::*;
        match self {
            DecimalLiteralContext(inner) => inner,
            DoubleLiteralContext(inner) => inner,
            IntegerLiteralContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NumberContextAll<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type NumberContext<'input> = BaseParserRuleContext<'input, NumberContextExt<'input>>;

#[derive(Clone)]
pub struct NumberContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for NumberContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a> for NumberContext<'input> {}

impl<'input> CustomRuleContext<'input> for NumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}
antlr_rust::tid! {NumberContextExt<'a>}

impl<'input> NumberContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NumberContextAll<'input>> {
        Rc::new(NumberContextAll::Error(
            BaseParserRuleContext::new_parser_ctx(
                parent,
                invoking_state,
                NumberContextExt { ph: PhantomData },
            ),
        ))
    }
}

pub trait NumberContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<NumberContextExt<'input>>
{
}

impl<'input> NumberContextAttrs<'input> for NumberContext<'input> {}

pub type DecimalLiteralContext<'input> =
    BaseParserRuleContext<'input, DecimalLiteralContextExt<'input>>;

pub trait DecimalLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DECIMAL_VALUE
    /// Returns `None` if there is no child corresponding to token DECIMAL_VALUE
    fn DECIMAL_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DECIMAL_VALUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUS
    /// Returns `None` if there is no child corresponding to token MINUS
    fn MINUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUS, 0)
    }
}

impl<'input> DecimalLiteralContextAttrs<'input> for DecimalLiteralContext<'input> {}

pub struct DecimalLiteralContextExt<'input> {
    base: NumberContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DecimalLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DecimalLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DecimalLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_decimalLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for DecimalLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}

impl<'input> Borrow<NumberContextExt<'input>> for DecimalLiteralContext<'input> {
    fn borrow(&self) -> &NumberContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<NumberContextExt<'input>> for DecimalLiteralContext<'input> {
    fn borrow_mut(&mut self) -> &mut NumberContextExt<'input> {
        &mut self.base
    }
}

impl<'input> NumberContextAttrs<'input> for DecimalLiteralContext<'input> {}

impl<'input> DecimalLiteralContextExt<'input> {
    fn new(ctx: &dyn NumberContextAttrs<'input>) -> Rc<NumberContextAll<'input>> {
        Rc::new(NumberContextAll::DecimalLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DecimalLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type DoubleLiteralContext<'input> =
    BaseParserRuleContext<'input, DoubleLiteralContextExt<'input>>;

pub trait DoubleLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DOUBLE_VALUE
    /// Returns `None` if there is no child corresponding to token DOUBLE_VALUE
    fn DOUBLE_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOUBLE_VALUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUS
    /// Returns `None` if there is no child corresponding to token MINUS
    fn MINUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUS, 0)
    }
}

impl<'input> DoubleLiteralContextAttrs<'input> for DoubleLiteralContext<'input> {}

pub struct DoubleLiteralContextExt<'input> {
    base: NumberContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DoubleLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for DoubleLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for DoubleLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_doubleLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for DoubleLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}

impl<'input> Borrow<NumberContextExt<'input>> for DoubleLiteralContext<'input> {
    fn borrow(&self) -> &NumberContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<NumberContextExt<'input>> for DoubleLiteralContext<'input> {
    fn borrow_mut(&mut self) -> &mut NumberContextExt<'input> {
        &mut self.base
    }
}

impl<'input> NumberContextAttrs<'input> for DoubleLiteralContext<'input> {}

impl<'input> DoubleLiteralContextExt<'input> {
    fn new(ctx: &dyn NumberContextAttrs<'input>) -> Rc<NumberContextAll<'input>> {
        Rc::new(NumberContextAll::DoubleLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                DoubleLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

pub type IntegerLiteralContext<'input> =
    BaseParserRuleContext<'input, IntegerLiteralContextExt<'input>>;

pub trait IntegerLiteralContextAttrs<'input>: PrestoParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
    /// Returns `None` if there is no child corresponding to token INTEGER_VALUE
    fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER_VALUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUS
    /// Returns `None` if there is no child corresponding to token MINUS
    fn MINUS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUS, 0)
    }
}

impl<'input> IntegerLiteralContextAttrs<'input> for IntegerLiteralContext<'input> {}

pub struct IntegerLiteralContextExt<'input> {
    base: NumberContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IntegerLiteralContextExt<'a>}

impl<'input> PrestoParserContext<'input> for IntegerLiteralContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for IntegerLiteralContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_integerLiteral(self);
    }
}

impl<'input> CustomRuleContext<'input> for IntegerLiteralContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}

impl<'input> Borrow<NumberContextExt<'input>> for IntegerLiteralContext<'input> {
    fn borrow(&self) -> &NumberContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<NumberContextExt<'input>> for IntegerLiteralContext<'input> {
    fn borrow_mut(&mut self) -> &mut NumberContextExt<'input> {
        &mut self.base
    }
}

impl<'input> NumberContextAttrs<'input> for IntegerLiteralContext<'input> {}

impl<'input> IntegerLiteralContextExt<'input> {
    fn new(ctx: &dyn NumberContextAttrs<'input>) -> Rc<NumberContextAll<'input>> {
        Rc::new(NumberContextAll::IntegerLiteralContext(
            BaseParserRuleContext::copy_from(
                ctx,
                IntegerLiteralContextExt {
                    base: ctx.borrow().clone(),
                    ph: PhantomData,
                },
            ),
        ))
    }
}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number(&mut self) -> Result<Rc<NumberContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            NumberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_number);
        let mut _localctx: Rc<NumberContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2954);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(394, &mut recog.base)? {
                1 => {
                    let tmp = DecimalLiteralContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2943);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == MINUS {
                            {
                                recog.base.set_state(2942);
                                recog.base.match_token(MINUS, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(2945);
                        recog
                            .base
                            .match_token(DECIMAL_VALUE, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    let tmp = DoubleLiteralContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2947);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == MINUS {
                            {
                                recog.base.set_state(2946);
                                recog.base.match_token(MINUS, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(2949);
                        recog
                            .base
                            .match_token(DOUBLE_VALUE, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = IntegerLiteralContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2951);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == MINUS {
                            {
                                recog.base.set_state(2950);
                                recog.base.match_token(MINUS, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(2953);
                        recog
                            .base
                            .match_token(INTEGER_VALUE, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- nonReserved ----------------
pub type NonReservedContextAll<'input> = NonReservedContext<'input>;

pub type NonReservedContext<'input> =
    BaseParserRuleContext<'input, NonReservedContextExt<'input>>;

#[derive(Clone)]
pub struct NonReservedContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> PrestoParserContext<'input> for NonReservedContext<'input> {}

impl<'input, 'a> Listenable<dyn PrestoListener<'input> + 'a>
    for NonReservedContext<'input>
{
    fn enter(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_nonReserved(self);
    }
    fn exit(&self, listener: &mut (dyn PrestoListener<'input> + 'a)) {
        listener.exit_nonReserved(self);
        listener.exit_every_rule(self);
    }
}

impl<'input> CustomRuleContext<'input> for NonReservedContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = PrestoParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_nonReserved
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_nonReserved }
}
antlr_rust::tid! {NonReservedContextExt<'a>}

impl<'input> NonReservedContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn PrestoParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NonReservedContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            NonReservedContextExt { ph: PhantomData },
        ))
    }
}

pub trait NonReservedContextAttrs<'input>:
    PrestoParserContext<'input> + BorrowMut<NonReservedContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token ABSENT
    /// Returns `None` if there is no child corresponding to token ABSENT
    fn ABSENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ABSENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ADD
    /// Returns `None` if there is no child corresponding to token ADD
    fn ADD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ADMIN
    /// Returns `None` if there is no child corresponding to token ADMIN
    fn ADMIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ADMIN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AFTER
    /// Returns `None` if there is no child corresponding to token AFTER
    fn AFTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AFTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ALL
    /// Returns `None` if there is no child corresponding to token ALL
    fn ALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ANALYZE
    /// Returns `None` if there is no child corresponding to token ANALYZE
    fn ANALYZE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ANALYZE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ANY
    /// Returns `None` if there is no child corresponding to token ANY
    fn ANY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ANY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ARRAY
    /// Returns `None` if there is no child corresponding to token ARRAY
    fn ARRAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ARRAY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ASC
    /// Returns `None` if there is no child corresponding to token ASC
    fn ASC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ASC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AT
    /// Returns `None` if there is no child corresponding to token AT
    fn AT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token AUTHORIZATION
    /// Returns `None` if there is no child corresponding to token AUTHORIZATION
    fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(AUTHORIZATION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BERNOULLI
    /// Returns `None` if there is no child corresponding to token BERNOULLI
    fn BERNOULLI(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BERNOULLI, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BOTH
    /// Returns `None` if there is no child corresponding to token BOTH
    fn BOTH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BOTH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CALL
    /// Returns `None` if there is no child corresponding to token CALL
    fn CALL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CALL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CASCADE
    /// Returns `None` if there is no child corresponding to token CASCADE
    fn CASCADE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CASCADE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CATALOGS
    /// Returns `None` if there is no child corresponding to token CATALOGS
    fn CATALOGS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CATALOGS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMN
    /// Returns `None` if there is no child corresponding to token COLUMN
    fn COLUMN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLUMNS
    /// Returns `None` if there is no child corresponding to token COLUMNS
    fn COLUMNS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLUMNS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMENT
    /// Returns `None` if there is no child corresponding to token COMMENT
    fn COMMENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMIT
    /// Returns `None` if there is no child corresponding to token COMMIT
    fn COMMIT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMIT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COMMITTED
    /// Returns `None` if there is no child corresponding to token COMMITTED
    fn COMMITTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMITTED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CONDITIONAL
    /// Returns `None` if there is no child corresponding to token CONDITIONAL
    fn CONDITIONAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CONDITIONAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COPARTITION
    /// Returns `None` if there is no child corresponding to token COPARTITION
    fn COPARTITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COPARTITION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COUNT
    /// Returns `None` if there is no child corresponding to token COUNT
    fn COUNT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COUNT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token CURRENT
    /// Returns `None` if there is no child corresponding to token CURRENT
    fn CURRENT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CURRENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DATA
    /// Returns `None` if there is no child corresponding to token DATA
    fn DATA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DATA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DATE
    /// Returns `None` if there is no child corresponding to token DATE
    fn DATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DAY
    /// Returns `None` if there is no child corresponding to token DAY
    fn DAY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DAY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DEFAULT
    /// Returns `None` if there is no child corresponding to token DEFAULT
    fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFAULT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DEFINE
    /// Returns `None` if there is no child corresponding to token DEFINE
    fn DEFINE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFINE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DEFINER
    /// Returns `None` if there is no child corresponding to token DEFINER
    fn DEFINER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DEFINER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DENY
    /// Returns `None` if there is no child corresponding to token DENY
    fn DENY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DENY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DESC
    /// Returns `None` if there is no child corresponding to token DESC
    fn DESC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DESCRIPTOR
    /// Returns `None` if there is no child corresponding to token DESCRIPTOR
    fn DESCRIPTOR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DESCRIPTOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DISTRIBUTED
    /// Returns `None` if there is no child corresponding to token DISTRIBUTED
    fn DISTRIBUTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DISTRIBUTED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOUBLE
    /// Returns `None` if there is no child corresponding to token DOUBLE
    fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOUBLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EMPTY
    /// Returns `None` if there is no child corresponding to token EMPTY
    fn EMPTY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EMPTY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ENCODING
    /// Returns `None` if there is no child corresponding to token ENCODING
    fn ENCODING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ENCODING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ERROR
    /// Returns `None` if there is no child corresponding to token ERROR
    fn ERROR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ERROR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXCLUDING
    /// Returns `None` if there is no child corresponding to token EXCLUDING
    fn EXCLUDING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXCLUDING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token EXPLAIN
    /// Returns `None` if there is no child corresponding to token EXPLAIN
    fn EXPLAIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EXPLAIN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FETCH
    /// Returns `None` if there is no child corresponding to token FETCH
    fn FETCH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FETCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FILTER
    /// Returns `None` if there is no child corresponding to token FILTER
    fn FILTER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FILTER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FINAL
    /// Returns `None` if there is no child corresponding to token FINAL
    fn FINAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FINAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FIRST
    /// Returns `None` if there is no child corresponding to token FIRST
    fn FIRST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FIRST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FOLLOWING
    /// Returns `None` if there is no child corresponding to token FOLLOWING
    fn FOLLOWING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FOLLOWING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FORMAT
    /// Returns `None` if there is no child corresponding to token FORMAT
    fn FORMAT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FORMAT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FUNCTIONS
    /// Returns `None` if there is no child corresponding to token FUNCTIONS
    fn FUNCTIONS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FUNCTIONS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRACE
    /// Returns `None` if there is no child corresponding to token GRACE
    fn GRACE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRACE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRANT
    /// Returns `None` if there is no child corresponding to token GRANT
    fn GRANT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRANTED
    /// Returns `None` if there is no child corresponding to token GRANTED
    fn GRANTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANTED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRANTS
    /// Returns `None` if there is no child corresponding to token GRANTS
    fn GRANTS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRANTS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GRAPHVIZ
    /// Returns `None` if there is no child corresponding to token GRAPHVIZ
    fn GRAPHVIZ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GRAPHVIZ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GROUPS
    /// Returns `None` if there is no child corresponding to token GROUPS
    fn GROUPS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GROUPS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token HOUR
    /// Returns `None` if there is no child corresponding to token HOUR
    fn HOUR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(HOUR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IF
    /// Returns `None` if there is no child corresponding to token IF
    fn IF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IGNORE
    /// Returns `None` if there is no child corresponding to token IGNORE
    fn IGNORE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IGNORE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INCLUDING
    /// Returns `None` if there is no child corresponding to token INCLUDING
    fn INCLUDING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INCLUDING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INITIAL
    /// Returns `None` if there is no child corresponding to token INITIAL
    fn INITIAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INITIAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INPUT
    /// Returns `None` if there is no child corresponding to token INPUT
    fn INPUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INPUT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTERVAL
    /// Returns `None` if there is no child corresponding to token INTERVAL
    fn INTERVAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTERVAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INVOKER
    /// Returns `None` if there is no child corresponding to token INVOKER
    fn INVOKER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INVOKER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token IO
    /// Returns `None` if there is no child corresponding to token IO
    fn IO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(IO, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ISOLATION
    /// Returns `None` if there is no child corresponding to token ISOLATION
    fn ISOLATION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ISOLATION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token JSON
    /// Returns `None` if there is no child corresponding to token JSON
    fn JSON(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(JSON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KEEP
    /// Returns `None` if there is no child corresponding to token KEEP
    fn KEEP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KEEP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KEY
    /// Returns `None` if there is no child corresponding to token KEY
    fn KEY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KEY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KEYS
    /// Returns `None` if there is no child corresponding to token KEYS
    fn KEYS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KEYS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LAST
    /// Returns `None` if there is no child corresponding to token LAST
    fn LAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LAST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LATERAL
    /// Returns `None` if there is no child corresponding to token LATERAL
    fn LATERAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LATERAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LEADING
    /// Returns `None` if there is no child corresponding to token LEADING
    fn LEADING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LEADING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LEVEL
    /// Returns `None` if there is no child corresponding to token LEVEL
    fn LEVEL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LEVEL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LIMIT
    /// Returns `None` if there is no child corresponding to token LIMIT
    fn LIMIT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LIMIT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOCAL
    /// Returns `None` if there is no child corresponding to token LOCAL
    fn LOCAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOCAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGICAL
    /// Returns `None` if there is no child corresponding to token LOGICAL
    fn LOGICAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGICAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MAP
    /// Returns `None` if there is no child corresponding to token MAP
    fn MAP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MAP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCH
    /// Returns `None` if there is no child corresponding to token MATCH
    fn MATCH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCHED
    /// Returns `None` if there is no child corresponding to token MATCHED
    fn MATCHED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCHED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCHES
    /// Returns `None` if there is no child corresponding to token MATCHES
    fn MATCHES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCHES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATCH_RECOGNIZE
    /// Returns `None` if there is no child corresponding to token MATCH_RECOGNIZE
    fn MATCH_RECOGNIZE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATCH_RECOGNIZE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MATERIALIZED
    /// Returns `None` if there is no child corresponding to token MATERIALIZED
    fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MATERIALIZED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MEASURES
    /// Returns `None` if there is no child corresponding to token MEASURES
    fn MEASURES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MEASURES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MERGE
    /// Returns `None` if there is no child corresponding to token MERGE
    fn MERGE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MERGE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MINUTE
    /// Returns `None` if there is no child corresponding to token MINUTE
    fn MINUTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MINUTE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token MONTH
    /// Returns `None` if there is no child corresponding to token MONTH
    fn MONTH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(MONTH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NEXT
    /// Returns `None` if there is no child corresponding to token NEXT
    fn NEXT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NEXT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NFC
    /// Returns `None` if there is no child corresponding to token NFC
    fn NFC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NFD
    /// Returns `None` if there is no child corresponding to token NFD
    fn NFD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NFKC
    /// Returns `None` if there is no child corresponding to token NFKC
    fn NFKC(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFKC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NFKD
    /// Returns `None` if there is no child corresponding to token NFKD
    fn NFKD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NFKD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NO
    /// Returns `None` if there is no child corresponding to token NO
    fn NO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NO, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NONE
    /// Returns `None` if there is no child corresponding to token NONE
    fn NONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NONE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULLIF
    /// Returns `None` if there is no child corresponding to token NULLIF
    fn NULLIF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULLIF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token NULLS
    /// Returns `None` if there is no child corresponding to token NULLS
    fn NULLS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(NULLS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OBJECT
    /// Returns `None` if there is no child corresponding to token OBJECT
    fn OBJECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OBJECT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OF
    /// Returns `None` if there is no child corresponding to token OF
    fn OF(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET
    /// Returns `None` if there is no child corresponding to token OFFSET
    fn OFFSET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OMIT
    /// Returns `None` if there is no child corresponding to token OMIT
    fn OMIT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OMIT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ONE
    /// Returns `None` if there is no child corresponding to token ONE
    fn ONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ONE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ONLY
    /// Returns `None` if there is no child corresponding to token ONLY
    fn ONLY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ONLY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OPTION
    /// Returns `None` if there is no child corresponding to token OPTION
    fn OPTION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OPTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ORDINALITY
    /// Returns `None` if there is no child corresponding to token ORDINALITY
    fn ORDINALITY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ORDINALITY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OUTPUT
    /// Returns `None` if there is no child corresponding to token OUTPUT
    fn OUTPUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OUTPUT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OVER
    /// Returns `None` if there is no child corresponding to token OVER
    fn OVER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OVER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OVERFLOW
    /// Returns `None` if there is no child corresponding to token OVERFLOW
    fn OVERFLOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OVERFLOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARTITION
    /// Returns `None` if there is no child corresponding to token PARTITION
    fn PARTITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARTITION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARTITIONS
    /// Returns `None` if there is no child corresponding to token PARTITIONS
    fn PARTITIONS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARTITIONS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PASSING
    /// Returns `None` if there is no child corresponding to token PASSING
    fn PASSING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PASSING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PAST
    /// Returns `None` if there is no child corresponding to token PAST
    fn PAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PAST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PATH
    /// Returns `None` if there is no child corresponding to token PATH
    fn PATH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PATH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PATTERN
    /// Returns `None` if there is no child corresponding to token PATTERN
    fn PATTERN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PATTERN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PER
    /// Returns `None` if there is no child corresponding to token PER
    fn PER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PERIOD
    /// Returns `None` if there is no child corresponding to token PERIOD
    fn PERIOD(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PERIOD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PERMUTE
    /// Returns `None` if there is no child corresponding to token PERMUTE
    fn PERMUTE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PERMUTE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token POSITION
    /// Returns `None` if there is no child corresponding to token POSITION
    fn POSITION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(POSITION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRECEDING
    /// Returns `None` if there is no child corresponding to token PRECEDING
    fn PRECEDING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRECEDING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRECISION
    /// Returns `None` if there is no child corresponding to token PRECISION
    fn PRECISION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRECISION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRIVILEGES
    /// Returns `None` if there is no child corresponding to token PRIVILEGES
    fn PRIVILEGES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRIVILEGES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PROPERTIES
    /// Returns `None` if there is no child corresponding to token PROPERTIES
    fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PROPERTIES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PRUNE
    /// Returns `None` if there is no child corresponding to token PRUNE
    fn PRUNE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PRUNE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token QUOTES
    /// Returns `None` if there is no child corresponding to token QUOTES
    fn QUOTES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(QUOTES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RANGE
    /// Returns `None` if there is no child corresponding to token RANGE
    fn RANGE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RANGE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token READ
    /// Returns `None` if there is no child corresponding to token READ
    fn READ(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(READ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token REFRESH
    /// Returns `None` if there is no child corresponding to token REFRESH
    fn REFRESH(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REFRESH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RENAME
    /// Returns `None` if there is no child corresponding to token RENAME
    fn RENAME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RENAME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token REPEATABLE
    /// Returns `None` if there is no child corresponding to token REPEATABLE
    fn REPEATABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REPEATABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token REPLACE
    /// Returns `None` if there is no child corresponding to token REPLACE
    fn REPLACE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REPLACE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESET
    /// Returns `None` if there is no child corresponding to token RESET
    fn RESET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESPECT
    /// Returns `None` if there is no child corresponding to token RESPECT
    fn RESPECT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESPECT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESTRICT
    /// Returns `None` if there is no child corresponding to token RESTRICT
    fn RESTRICT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESTRICT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RETURNING
    /// Returns `None` if there is no child corresponding to token RETURNING
    fn RETURNING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURNING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token REVOKE
    /// Returns `None` if there is no child corresponding to token REVOKE
    fn REVOKE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(REVOKE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLE
    /// Returns `None` if there is no child corresponding to token ROLE
    fn ROLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLES
    /// Returns `None` if there is no child corresponding to token ROLES
    fn ROLES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROLLBACK
    /// Returns `None` if there is no child corresponding to token ROLLBACK
    fn ROLLBACK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROLLBACK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROW
    /// Returns `None` if there is no child corresponding to token ROW
    fn ROW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ROWS
    /// Returns `None` if there is no child corresponding to token ROWS
    fn ROWS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ROWS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RUNNING
    /// Returns `None` if there is no child corresponding to token RUNNING
    fn RUNNING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RUNNING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCALAR
    /// Returns `None` if there is no child corresponding to token SCALAR
    fn SCALAR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCALAR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMA
    /// Returns `None` if there is no child corresponding to token SCHEMA
    fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SCHEMAS
    /// Returns `None` if there is no child corresponding to token SCHEMAS
    fn SCHEMAS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SCHEMAS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SECOND
    /// Returns `None` if there is no child corresponding to token SECOND
    fn SECOND(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SECOND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SECURITY
    /// Returns `None` if there is no child corresponding to token SECURITY
    fn SECURITY(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SECURITY, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SEEK
    /// Returns `None` if there is no child corresponding to token SEEK
    fn SEEK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEEK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SERIALIZABLE
    /// Returns `None` if there is no child corresponding to token SERIALIZABLE
    fn SERIALIZABLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SERIALIZABLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SESSION
    /// Returns `None` if there is no child corresponding to token SESSION
    fn SESSION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SESSION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SET
    /// Returns `None` if there is no child corresponding to token SET
    fn SET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SETS
    /// Returns `None` if there is no child corresponding to token SETS
    fn SETS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SETS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SHOW
    /// Returns `None` if there is no child corresponding to token SHOW
    fn SHOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SHOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SOME
    /// Returns `None` if there is no child corresponding to token SOME
    fn SOME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SOME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token START
    /// Returns `None` if there is no child corresponding to token START
    fn START(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(START, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STATS
    /// Returns `None` if there is no child corresponding to token STATS
    fn STATS(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STATS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SUBSET
    /// Returns `None` if there is no child corresponding to token SUBSET
    fn SUBSET(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SUBSET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SUBSTRING
    /// Returns `None` if there is no child corresponding to token SUBSTRING
    fn SUBSTRING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SUBSTRING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SYSTEM
    /// Returns `None` if there is no child corresponding to token SYSTEM
    fn SYSTEM(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SYSTEM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLES
    /// Returns `None` if there is no child corresponding to token TABLES
    fn TABLES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TABLESAMPLE
    /// Returns `None` if there is no child corresponding to token TABLESAMPLE
    fn TABLESAMPLE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TABLESAMPLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TEXT
    /// Returns `None` if there is no child corresponding to token TEXT
    fn TEXT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TEXT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TEXT_STRING
    /// Returns `None` if there is no child corresponding to token TEXT_STRING
    fn TEXT_STRING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TEXT_STRING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TIES
    /// Returns `None` if there is no child corresponding to token TIES
    fn TIES(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIES, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TIME
    /// Returns `None` if there is no child corresponding to token TIME
    fn TIME(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TIMESTAMP
    /// Returns `None` if there is no child corresponding to token TIMESTAMP
    fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TIMESTAMP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TO
    /// Returns `None` if there is no child corresponding to token TO
    fn TO(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TO, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TRAILING
    /// Returns `None` if there is no child corresponding to token TRAILING
    fn TRAILING(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRAILING, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TRANSACTION
    /// Returns `None` if there is no child corresponding to token TRANSACTION
    fn TRANSACTION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRANSACTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TRUNCATE
    /// Returns `None` if there is no child corresponding to token TRUNCATE
    fn TRUNCATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRUNCATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TRY_CAST
    /// Returns `None` if there is no child corresponding to token TRY_CAST
    fn TRY_CAST(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TRY_CAST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token TYPE
    /// Returns `None` if there is no child corresponding to token TYPE
    fn TYPE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(TYPE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNBOUNDED
    /// Returns `None` if there is no child corresponding to token UNBOUNDED
    fn UNBOUNDED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNBOUNDED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNCOMMITTED
    /// Returns `None` if there is no child corresponding to token UNCOMMITTED
    fn UNCOMMITTED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNCOMMITTED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNCONDITIONAL
    /// Returns `None` if there is no child corresponding to token UNCONDITIONAL
    fn UNCONDITIONAL(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNCONDITIONAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNIQUE
    /// Returns `None` if there is no child corresponding to token UNIQUE
    fn UNIQUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNIQUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNKNOWN
    /// Returns `None` if there is no child corresponding to token UNKNOWN
    fn UNKNOWN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNKNOWN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UNMATCHED
    /// Returns `None` if there is no child corresponding to token UNMATCHED
    fn UNMATCHED(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNMATCHED, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UPDATE
    /// Returns `None` if there is no child corresponding to token UPDATE
    fn UPDATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UPDATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token USE
    /// Returns `None` if there is no child corresponding to token USE
    fn USE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(USE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token USER
    /// Returns `None` if there is no child corresponding to token USER
    fn USER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(USER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UTF16
    /// Returns `None` if there is no child corresponding to token UTF16
    fn UTF16(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UTF16, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UTF32
    /// Returns `None` if there is no child corresponding to token UTF32
    fn UTF32(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UTF32, 0)
    }
    /// Retrieves first TerminalNode corresponding to token UTF8
    /// Returns `None` if there is no child corresponding to token UTF8
    fn UTF8(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UTF8, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VALIDATE
    /// Returns `None` if there is no child corresponding to token VALIDATE
    fn VALIDATE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VALIDATE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VALUE
    /// Returns `None` if there is no child corresponding to token VALUE
    fn VALUE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VALUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VERBOSE
    /// Returns `None` if there is no child corresponding to token VERBOSE
    fn VERBOSE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VERBOSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VERSION
    /// Returns `None` if there is no child corresponding to token VERSION
    fn VERSION(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VERSION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token VIEW
    /// Returns `None` if there is no child corresponding to token VIEW
    fn VIEW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(VIEW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WINDOW
    /// Returns `None` if there is no child corresponding to token WINDOW
    fn WINDOW(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WINDOW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITHIN
    /// Returns `None` if there is no child corresponding to token WITHIN
    fn WITHIN(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITHIN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WITHOUT
    /// Returns `None` if there is no child corresponding to token WITHOUT
    fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WITHOUT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WORK
    /// Returns `None` if there is no child corresponding to token WORK
    fn WORK(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WORK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WRAPPER
    /// Returns `None` if there is no child corresponding to token WRAPPER
    fn WRAPPER(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WRAPPER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token WRITE
    /// Returns `None` if there is no child corresponding to token WRITE
    fn WRITE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(WRITE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token YEAR
    /// Returns `None` if there is no child corresponding to token YEAR
    fn YEAR(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YEAR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token ZONE
    /// Returns `None` if there is no child corresponding to token ZONE
    fn ZONE(&self) -> Option<Rc<TerminalNode<'input, PrestoParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(ZONE, 0)
    }
}

impl<'input> NonReservedContextAttrs<'input> for NonReservedContext<'input> {}

impl<'input, I, H> PrestoParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn nonReserved(
        &mut self,
    ) -> Result<Rc<NonReservedContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx =
            NonReservedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog
            .base
            .enter_rule(_localctx.clone(), 218, RULE_nonReserved);
        let mut _localctx: Rc<NonReservedContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2956);
                _la = recog.base.input.la(1);
                if {
                    !((((_la) & !0x3f) == 0
                        && ((1usize << _la)
                            & ((1usize << ABSENT)
                                | (1usize << ADD)
                                | (1usize << ADMIN)
                                | (1usize << AFTER)
                                | (1usize << ALL)
                                | (1usize << ANALYZE)
                                | (1usize << ANY)
                                | (1usize << ARRAY)
                                | (1usize << ASC)
                                | (1usize << AT)
                                | (1usize << AUTHORIZATION)
                                | (1usize << BERNOULLI)))
                            != 0)
                        || (((_la - 33) & !0x3f) == 0
                            && ((1usize << (_la - 33))
                                & ((1usize << (BOTH - 33))
                                    | (1usize << (CALL - 33))
                                    | (1usize << (CASCADE - 33))
                                    | (1usize << (CATALOGS - 33))
                                    | (1usize << (COLUMN - 33))
                                    | (1usize << (COLUMNS - 33))
                                    | (1usize << (COMMENT - 33))
                                    | (1usize << (COMMIT - 33))
                                    | (1usize << (COMMITTED - 33))
                                    | (1usize << (CONDITIONAL - 33))
                                    | (1usize << (COUNT - 33))
                                    | (1usize << (COPARTITION - 33))
                                    | (1usize << (CURRENT - 33))
                                    | (1usize << (DATA - 33))
                                    | (1usize << (DATE - 33))
                                    | (1usize << (DAY - 33))))
                                != 0)
                        || (((_la - 66) & !0x3f) == 0
                            && ((1usize << (_la - 66))
                                & ((1usize << (DEFAULT - 66))
                                    | (1usize << (DEFINE - 66))
                                    | (1usize << (DEFINER - 66))
                                    | (1usize << (DENY - 66))
                                    | (1usize << (DESC - 66))
                                    | (1usize << (DESCRIPTOR - 66))
                                    | (1usize << (DISTRIBUTED - 66))
                                    | (1usize << (DOUBLE - 66))
                                    | (1usize << (EMPTY - 66))
                                    | (1usize << (ENCODING - 66))
                                    | (1usize << (ERROR - 66))
                                    | (1usize << (EXCLUDING - 66))
                                    | (1usize << (EXPLAIN - 66))
                                    | (1usize << (FETCH - 66))
                                    | (1usize << (FILTER - 66))
                                    | (1usize << (FINAL - 66))
                                    | (1usize << (FIRST - 66))
                                    | (1usize << (FOLLOWING - 66))
                                    | (1usize << (FORMAT - 66))))
                                != 0)
                        || (((_la - 100) & !0x3f) == 0
                            && ((1usize << (_la - 100))
                                & ((1usize << (FUNCTIONS - 100))
                                    | (1usize << (GRACE - 100))
                                    | (1usize << (GRANT - 100))
                                    | (1usize << (GRANTED - 100))
                                    | (1usize << (GRANTS - 100))
                                    | (1usize << (GRAPHVIZ - 100))
                                    | (1usize << (GROUPS - 100))
                                    | (1usize << (HOUR - 100))
                                    | (1usize << (IF - 100))
                                    | (1usize << (IGNORE - 100))
                                    | (1usize << (INCLUDING - 100))
                                    | (1usize << (INITIAL - 100))
                                    | (1usize << (INPUT - 100))
                                    | (1usize << (INTERVAL - 100))
                                    | (1usize << (INVOKER - 100))
                                    | (1usize << (IO - 100))
                                    | (1usize << (ISOLATION - 100))
                                    | (1usize << (JSON - 100))))
                                != 0)
                        || (((_la - 133) & !0x3f) == 0
                            && ((1usize << (_la - 133))
                                & ((1usize << (KEEP - 133))
                                    | (1usize << (KEY - 133))
                                    | (1usize << (KEYS - 133))
                                    | (1usize << (LAST - 133))
                                    | (1usize << (LATERAL - 133))
                                    | (1usize << (LEADING - 133))
                                    | (1usize << (LEVEL - 133))
                                    | (1usize << (LIMIT - 133))
                                    | (1usize << (LOCAL - 133))
                                    | (1usize << (LOGICAL - 133))
                                    | (1usize << (MAP - 133))
                                    | (1usize << (MATCH - 133))
                                    | (1usize << (MATCHED - 133))
                                    | (1usize << (MATCHES - 133))
                                    | (1usize << (MATCH_RECOGNIZE - 133))
                                    | (1usize << (MATERIALIZED - 133))
                                    | (1usize << (MEASURES - 133))
                                    | (1usize << (MERGE - 133))
                                    | (1usize << (MINUTE - 133))
                                    | (1usize << (MONTH - 133))
                                    | (1usize << (NEXT - 133))
                                    | (1usize << (NFC - 133))
                                    | (1usize << (NFD - 133))
                                    | (1usize << (NFKC - 133))
                                    | (1usize << (NFKD - 133))
                                    | (1usize << (NO - 133))))
                                != 0)
                        || (((_la - 165) & !0x3f) == 0
                            && ((1usize << (_la - 165))
                                & ((1usize << (NONE - 165))
                                    | (1usize << (NULLIF - 165))
                                    | (1usize << (NULLS - 165))
                                    | (1usize << (OBJECT - 165))
                                    | (1usize << (OF - 165))
                                    | (1usize << (OFFSET - 165))
                                    | (1usize << (OMIT - 165))
                                    | (1usize << (ONE - 165))
                                    | (1usize << (ONLY - 165))
                                    | (1usize << (OPTION - 165))
                                    | (1usize << (ORDINALITY - 165))
                                    | (1usize << (OUTPUT - 165))
                                    | (1usize << (OVER - 165))
                                    | (1usize << (OVERFLOW - 165))
                                    | (1usize << (PARTITION - 165))
                                    | (1usize << (PARTITIONS - 165))
                                    | (1usize << (PASSING - 165))
                                    | (1usize << (PAST - 165))
                                    | (1usize << (PATH - 165))
                                    | (1usize << (PATTERN - 165))
                                    | (1usize << (PER - 165))
                                    | (1usize << (PERIOD - 165))
                                    | (1usize << (PERMUTE - 165))
                                    | (1usize << (POSITION - 165))
                                    | (1usize << (PRECEDING - 165))))
                                != 0)
                        || (((_la - 197) & !0x3f) == 0
                            && ((1usize << (_la - 197))
                                & ((1usize << (PRECISION - 197))
                                    | (1usize << (PRIVILEGES - 197))
                                    | (1usize << (PROPERTIES - 197))
                                    | (1usize << (PRUNE - 197))
                                    | (1usize << (QUOTES - 197))
                                    | (1usize << (RANGE - 197))
                                    | (1usize << (READ - 197))
                                    | (1usize << (REFRESH - 197))
                                    | (1usize << (RENAME - 197))
                                    | (1usize << (REPEATABLE - 197))
                                    | (1usize << (REPLACE - 197))
                                    | (1usize << (RESET - 197))
                                    | (1usize << (RESPECT - 197))
                                    | (1usize << (RESTRICT - 197))
                                    | (1usize << (RETURNING - 197))
                                    | (1usize << (REVOKE - 197))
                                    | (1usize << (ROLE - 197))
                                    | (1usize << (ROLES - 197))
                                    | (1usize << (ROLLBACK - 197))
                                    | (1usize << (ROW - 197))
                                    | (1usize << (ROWS - 197))
                                    | (1usize << (RUNNING - 197))
                                    | (1usize << (SCALAR - 197))
                                    | (1usize << (SCHEMA - 197))
                                    | (1usize << (SCHEMAS - 197))
                                    | (1usize << (SECOND - 197))
                                    | (1usize << (SECURITY - 197))
                                    | (1usize << (SEEK - 197))))
                                != 0)
                        || (((_la - 230) & !0x3f) == 0
                            && ((1usize << (_la - 230))
                                & ((1usize << (SERIALIZABLE - 230))
                                    | (1usize << (SESSION - 230))
                                    | (1usize << (SET - 230))
                                    | (1usize << (SETS - 230))
                                    | (1usize << (SHOW - 230))
                                    | (1usize << (SOME - 230))
                                    | (1usize << (START - 230))
                                    | (1usize << (STATS - 230))
                                    | (1usize << (SUBSET - 230))
                                    | (1usize << (SUBSTRING - 230))
                                    | (1usize << (SYSTEM - 230))
                                    | (1usize << (TABLES - 230))
                                    | (1usize << (TABLESAMPLE - 230))
                                    | (1usize << (TEXT - 230))
                                    | (1usize << (TEXT_STRING - 230))
                                    | (1usize << (TIES - 230))
                                    | (1usize << (TIME - 230))
                                    | (1usize << (TIMESTAMP - 230))
                                    | (1usize << (TO - 230))
                                    | (1usize << (TRAILING - 230))
                                    | (1usize << (TRANSACTION - 230))
                                    | (1usize << (TRUNCATE - 230))
                                    | (1usize << (TRY_CAST - 230))
                                    | (1usize << (TYPE - 230))
                                    | (1usize << (UNBOUNDED - 230))
                                    | (1usize << (UNCOMMITTED - 230))
                                    | (1usize << (UNCONDITIONAL - 230))))
                                != 0)
                        || (((_la - 263) & !0x3f) == 0
                            && ((1usize << (_la - 263))
                                & ((1usize << (UNIQUE - 263))
                                    | (1usize << (UNKNOWN - 263))
                                    | (1usize << (UNMATCHED - 263))
                                    | (1usize << (UPDATE - 263))
                                    | (1usize << (USE - 263))
                                    | (1usize << (USER - 263))
                                    | (1usize << (UTF16 - 263))
                                    | (1usize << (UTF32 - 263))
                                    | (1usize << (UTF8 - 263))
                                    | (1usize << (VALIDATE - 263))
                                    | (1usize << (VALUE - 263))
                                    | (1usize << (VERBOSE - 263))
                                    | (1usize << (VERSION - 263))
                                    | (1usize << (VIEW - 263))
                                    | (1usize << (WINDOW - 263))
                                    | (1usize << (WITHIN - 263))
                                    | (1usize << (WITHOUT - 263))
                                    | (1usize << (WORK - 263))
                                    | (1usize << (WRAPPER - 263))
                                    | (1usize << (WRITE - 263))
                                    | (1usize << (YEAR - 263))
                                    | (1usize << (ZONE - 263))))
                                != 0))
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                } else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(
                DFA::new(_ATN.clone(), _ATN.get_decision_state(i), i as isize).into(),
            )
        }
        Arc::new(dfa)
    };
}

const _serializedATN: &'static str =
    "\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{140}\u{b91}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x03\x02\x03\x02\x03\x02\x03\
	\x03\x03\x03\x03\x03\x03\x04\x03\x04\x03\x04\x03\x05\x03\x05\x03\x05\x03\
	\x06\x03\x06\x03\x06\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{fb}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{100}\x0a\x07\x03\x07\x03\x07\x05\x07\
	\u{104}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{10a}\x0a\x07\x03\
	\x07\x03\x07\x05\x07\u{10e}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{123}\x0a\x07\x03\
	\x07\x03\x07\x05\x07\u{127}\x0a\x07\x03\x07\x03\x07\x05\x07\u{12b}\x0a\x07\
	\x03\x07\x03\x07\x05\x07\u{12f}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{137}\x0a\x07\x03\x07\x03\x07\x05\x07\u{13b}\x0a\
	\x07\x03\x07\x05\x07\u{13e}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{145}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\
	\x07\u{14c}\x0a\x07\x0c\x07\x0e\x07\u{14f}\x0b\x07\x03\x07\x03\x07\x05\x07\
	\u{153}\x0a\x07\x03\x07\x03\x07\x05\x07\u{157}\x0a\x07\x03\x07\x03\x07\x05\
	\x07\u{15b}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{161}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{168}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{171}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{17d}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{186}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{18f}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{195}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1a0}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1a8}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1b0}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{1b7}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1c1}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1c8}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1d0}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x07\x07\u{1f2}\x0a\x07\x0c\x07\x0e\x07\u{1f5}\x0b\
	\x07\x05\x07\u{1f7}\x0a\x07\x03\x07\x05\x07\u{1fa}\x0a\x07\x03\x07\x03\x07\
	\x05\x07\u{1fe}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{204}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{209}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x05\x07\u{210}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{216}\x0a\x07\x03\x07\x03\x07\x05\x07\u{21a}\x0a\x07\x03\x07\
	\x03\x07\x05\x07\u{21e}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{226}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{22c}\x0a\x07\x03\x07\x03\x07\x05\x07\u{230}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{23e}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{246}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x05\x07\u{259}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\
	\x07\u{270}\x0a\x07\x0c\x07\x0e\x07\u{273}\x0b\x07\x05\x07\u{275}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{27f}\x0a\x07\x03\x07\x03\x07\x05\x07\u{283}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x05\x07\u{28a}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x07\x07\u{292}\x0a\x07\x0c\x07\x0e\x07\u{295}\x0b\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{29a}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{29f}\x0a\x07\x03\x07\x03\x07\x05\x07\u{2a3}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x05\x07\u{2a9}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x07\x07\u{2b0}\x0a\x07\x0c\x07\x0e\x07\u{2b3}\x0b\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{2b8}\x0a\x07\x03\x07\x03\x07\x05\x07\u{2bc}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{2c3}\x0a\x07\x03\
	\x07\x03\x07\x05\x07\u{2c7}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\
	\x07\u{2cd}\x0a\x07\x0c\x07\x0e\x07\u{2d0}\x0b\x07\x03\x07\x03\x07\x05\x07\
	\u{2d4}\x0a\x07\x03\x07\x03\x07\x05\x07\u{2d8}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{2e0}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x07\x07\u{2e6}\x0a\x07\x0c\x07\x0e\x07\u{2e9}\x0b\x07\x03\x07\
	\x03\x07\x05\x07\u{2ed}\x0a\x07\x03\x07\x03\x07\x05\x07\u{2f1}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{2fb}\
	\x0a\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{300}\x0a\x07\x0c\x07\x0e\x07\
	\u{303}\x0b\x07\x03\x07\x03\x07\x05\x07\u{307}\x0a\x07\x03\x07\x03\x07\x05\
	\x07\u{30b}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x05\x07\u{315}\x0a\x07\x03\x07\x05\x07\u{318}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{31f}\x0a\x07\x0c\x07\x0e\x07\
	\u{322}\x0b\x07\x03\x07\x03\x07\x05\x07\u{326}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x05\x07\u{32c}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{344}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{34a}\x0a\x07\
	\x05\x07\u{34c}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{352}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{358}\x0a\x07\x05\x07\u{35a}\
	\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{362}\
	\x0a\x07\x05\x07\u{364}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{36a}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{370}\x0a\x07\x05\
	\x07\u{372}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{381}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{386}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x05\x07\u{38d}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{399}\x0a\
	\x07\x05\x07\u{39b}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{3a3}\x0a\x07\x05\x07\u{3a5}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x07\x07\u{3b5}\x0a\x07\x0c\x07\x0e\x07\u{3b8}\x0b\x07\x05\
	\x07\u{3ba}\x0a\x07\x03\x07\x03\x07\x05\x07\u{3be}\x0a\x07\x03\x07\x03\x07\
	\x05\x07\u{3c2}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\
	\u{3d2}\x0a\x07\x0c\x07\x0e\x07\u{3d5}\x0b\x07\x05\x07\u{3d7}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{3e7}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{3ef}\x0a\x07\x0c\x07\x0e\
	\x07\u{3f2}\x0b\x07\x03\x07\x03\x07\x05\x07\u{3f6}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{3fc}\x0a\x07\x03\x07\x05\x07\u{3ff}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x06\x07\u{406}\x0a\x07\x0d\x07\x0e\
	\x07\u{407}\x05\x07\u{40a}\x0a\x07\x03\x08\x05\x08\u{40d}\x0a\x08\x03\x08\
	\x03\x08\x03\x09\x03\x09\x05\x09\u{413}\x0a\x09\x03\x09\x03\x09\x03\x09\
	\x07\x09\u{418}\x0a\x09\x0c\x09\x0e\x09\u{41b}\x0b\x09\x03\x0a\x03\x0a\x05\
	\x0a\u{41f}\x0a\x0a\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x05\x0b\u{425}\x0a\x0b\
	\x03\x0b\x03\x0b\x05\x0b\u{429}\x0a\x0b\x03\x0b\x03\x0b\x05\x0b\u{42d}\x0a\
	\x0b\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x05\x0c\u{433}\x0a\x0c\x03\x0d\x03\
	\x0d\x03\x0d\x03\x0d\x03\x0e\x03\x0e\x03\x0e\x07\x0e\u{43c}\x0a\x0e\x0c\
	\x0e\x0e\x0e\u{43f}\x0b\x0e\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x10\x03\
	\x10\x05\x10\u{447}\x0a\x10\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\
	\x11\x07\x11\u{44f}\x0a\x11\x0c\x11\x0e\x11\u{452}\x0b\x11\x05\x11\u{454}\
	\x0a\x11\x03\x11\x03\x11\x03\x11\x05\x11\u{459}\x0a\x11\x05\x11\u{45b}\x0a\
	\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x05\x11\u{462}\x0a\x11\x03\
	\x11\x03\x11\x03\x11\x03\x11\x05\x11\u{468}\x0a\x11\x05\x11\u{46a}\x0a\x11\
	\x03\x12\x03\x12\x05\x12\u{46e}\x0a\x12\x03\x13\x03\x13\x03\x14\x03\x14\
	\x03\x14\x03\x14\x03\x14\x03\x14\x05\x14\u{478}\x0a\x14\x03\x14\x03\x14\
	\x03\x14\x03\x14\x05\x14\u{47e}\x0a\x14\x03\x14\x07\x14\u{481}\x0a\x14\x0c\
	\x14\x0e\x14\u{484}\x0b\x14\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\
	\x15\x03\x15\x07\x15\u{48d}\x0a\x15\x0c\x15\x0e\x15\u{490}\x0b\x15\x03\x15\
	\x03\x15\x03\x15\x03\x15\x05\x15\u{496}\x0a\x15\x03\x16\x03\x16\x05\x16\
	\u{49a}\x0a\x16\x03\x16\x03\x16\x05\x16\u{49e}\x0a\x16\x03\x17\x03\x17\x05\
	\x17\u{4a2}\x0a\x17\x03\x17\x03\x17\x03\x17\x03\x17\x03\x17\x07\x17\u{4a9}\
	\x0a\x17\x0c\x17\x0e\x17\u{4ac}\x0b\x17\x05\x17\u{4ae}\x0a\x17\x03\x17\x03\
	\x17\x05\x17\u{4b2}\x0a\x17\x03\x17\x03\x17\x03\x17\x05\x17\u{4b7}\x0a\x17\
	\x03\x17\x03\x17\x05\x17\u{4bb}\x0a\x17\x03\x17\x03\x17\x03\x17\x03\x17\
	\x07\x17\u{4c1}\x0a\x17\x0c\x17\x0e\x17\u{4c4}\x0b\x17\x05\x17\u{4c6}\x0a\
	\x17\x03\x18\x03\x18\x03\x18\x07\x18\u{4cb}\x0a\x18\x0c\x18\x0e\x18\u{4ce}\
	\x0b\x18\x03\x19\x05\x19\u{4d1}\x0a\x19\x03\x19\x03\x19\x03\x19\x07\x19\
	\u{4d6}\x0a\x19\x0c\x19\x0e\x19\u{4d9}\x0b\x19\x03\x1a\x03\x1a\x03\x1a\x03\
	\x1a\x03\x1a\x03\x1a\x07\x1a\u{4e1}\x0a\x1a\x0c\x1a\x0e\x1a\u{4e4}\x0b\x1a\
	\x05\x1a\u{4e6}\x0a\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\
	\x07\x1a\u{4ee}\x0a\x1a\x0c\x1a\x0e\x1a\u{4f1}\x0b\x1a\x05\x1a\u{4f3}\x0a\
	\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x07\x1a\u{4fc}\
	\x0a\x1a\x0c\x1a\x0e\x1a\u{4ff}\x0b\x1a\x03\x1a\x03\x1a\x05\x1a\u{503}\x0a\
	\x1a\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x07\x1b\u{509}\x0a\x1b\x0c\x1b\x0e\
	\x1b\u{50c}\x0b\x1b\x05\x1b\u{50e}\x0a\x1b\x03\x1b\x03\x1b\x05\x1b\u{512}\
	\x0a\x1b\x03\x1c\x03\x1c\x03\x1c\x03\x1c\x03\x1c\x03\x1c\x03\x1d\x05\x1d\
	\u{51b}\x0a\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x07\x1d\u{522}\x0a\
	\x1d\x0c\x1d\x0e\x1d\u{525}\x0b\x1d\x05\x1d\u{527}\x0a\x1d\x03\x1d\x03\x1d\
	\x03\x1d\x03\x1d\x03\x1d\x07\x1d\u{52e}\x0a\x1d\x0c\x1d\x0e\x1d\u{531}\x0b\
	\x1d\x05\x1d\u{533}\x0a\x1d\x03\x1d\x05\x1d\u{536}\x0a\x1d\x03\x1e\x03\x1e\
	\x05\x1e\u{53a}\x0a\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1f\
	\x03\x1f\x03\x20\x03\x20\x05\x20\u{545}\x0a\x20\x03\x20\x05\x20\u{548}\x0a\
	\x20\x03\x20\x03\x20\x03\x20\x03\x20\x03\x20\x05\x20\u{54f}\x0a\x20\x03\
	\x20\x05\x20\u{552}\x0a\x20\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\x03\
	\x21\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\x03\
	\x21\x03\x21\x03\x21\x05\x21\u{565}\x0a\x21\x07\x21\u{567}\x0a\x21\x0c\x21\
	\x0e\x21\u{56a}\x0b\x21\x03\x22\x05\x22\u{56d}\x0a\x22\x03\x22\x03\x22\x05\
	\x22\u{571}\x0a\x22\x03\x22\x03\x22\x05\x22\u{575}\x0a\x22\x03\x22\x03\x22\
	\x05\x22\u{579}\x0a\x22\x05\x22\u{57b}\x0a\x22\x03\x23\x03\x23\x03\x23\x03\
	\x23\x03\x23\x03\x23\x03\x23\x07\x23\u{584}\x0a\x23\x0c\x23\x0e\x23\u{587}\
	\x0b\x23\x03\x23\x03\x23\x05\x23\u{58b}\x0a\x23\x03\x24\x03\x24\x03\x24\
	\x03\x24\x03\x24\x03\x24\x03\x24\x05\x24\u{594}\x0a\x24\x03\x25\x03\x25\
	\x03\x26\x03\x26\x03\x27\x03\x27\x03\x27\x05\x27\u{59d}\x0a\x27\x03\x27\
	\x05\x27\u{5a0}\x0a\x27\x03\x28\x03\x28\x03\x28\x03\x28\x05\x28\u{5a6}\x0a\
	\x28\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x07\
	\x29\u{5b0}\x0a\x29\x0c\x29\x0e\x29\u{5b3}\x0b\x29\x05\x29\u{5b5}\x0a\x29\
	\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x07\x29\u{5bc}\x0a\x29\x0c\x29\
	\x0e\x29\u{5bf}\x0b\x29\x05\x29\u{5c1}\x0a\x29\x03\x29\x03\x29\x03\x29\x03\
	\x29\x07\x29\u{5c7}\x0a\x29\x0c\x29\x0e\x29\u{5ca}\x0b\x29\x05\x29\u{5cc}\
	\x0a\x29\x03\x29\x05\x29\u{5cf}\x0a\x29\x03\x29\x03\x29\x03\x29\x05\x29\
	\u{5d4}\x0a\x29\x03\x29\x05\x29\u{5d7}\x0a\x29\x03\x29\x03\x29\x03\x29\x03\
	\x29\x03\x29\x03\x29\x03\x29\x03\x29\x07\x29\u{5e1}\x0a\x29\x0c\x29\x0e\
	\x29\u{5e4}\x0b\x29\x05\x29\u{5e6}\x0a\x29\x03\x29\x03\x29\x03\x29\x03\x29\
	\x07\x29\u{5ec}\x0a\x29\x0c\x29\x0e\x29\u{5ef}\x0b\x29\x03\x29\x03\x29\x05\
	\x29\u{5f3}\x0a\x29\x03\x29\x03\x29\x05\x29\u{5f7}\x0a\x29\x05\x29\u{5f9}\
	\x0a\x29\x05\x29\u{5fb}\x0a\x29\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2b\
	\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x05\x2b\
	\u{60a}\x0a\x2b\x05\x2b\u{60c}\x0a\x2b\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x03\
	\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x05\x2c\u{617}\x0a\x2c\x03\x2d\x03\
	\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\
	\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x05\
	\x2d\u{62c}\x0a\x2d\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x07\
	\x2e\u{634}\x0a\x2e\x0c\x2e\x0e\x2e\u{637}\x0b\x2e\x03\x2e\x03\x2e\x03\x2f\
	\x03\x2f\x03\x2f\x03\x2f\x03\x30\x03\x30\x05\x30\u{641}\x0a\x30\x03\x30\
	\x03\x30\x05\x30\u{645}\x0a\x30\x05\x30\u{647}\x0a\x30\x03\x31\x03\x31\x03\
	\x31\x03\x31\x07\x31\u{64d}\x0a\x31\x0c\x31\x0e\x31\u{650}\x0b\x31\x03\x31\
	\x03\x31\x03\x32\x03\x32\x05\x32\u{656}\x0a\x32\x03\x32\x03\x32\x03\x32\
	\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x07\x32\u{661}\x0a\x32\
	\x0c\x32\x0e\x32\u{664}\x0b\x32\x03\x32\x03\x32\x03\x32\x05\x32\u{669}\x0a\
	\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\
	\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x05\x32\u{679}\x0a\x32\x03\
	\x33\x03\x33\x03\x33\x03\x33\x03\x33\x07\x33\u{680}\x0a\x33\x0c\x33\x0e\
	\x33\u{683}\x0b\x33\x05\x33\u{685}\x0a\x33\x03\x33\x03\x33\x03\x33\x03\x33\
	\x07\x33\u{68b}\x0a\x33\x0c\x33\x0e\x33\u{68e}\x0b\x33\x05\x33\u{690}\x0a\
	\x33\x03\x33\x03\x33\x03\x34\x03\x34\x03\x34\x05\x34\u{697}\x0a\x34\x03\
	\x34\x03\x34\x03\x34\x05\x34\u{69c}\x0a\x34\x03\x35\x03\x35\x03\x35\x03\
	\x35\x03\x35\x03\x35\x03\x35\x07\x35\u{6a5}\x0a\x35\x0c\x35\x0e\x35\u{6a8}\
	\x0b\x35\x05\x35\u{6aa}\x0a\x35\x03\x35\x03\x35\x05\x35\u{6ae}\x0a\x35\x05\
	\x35\u{6b0}\x0a\x35\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x05\
	\x35\u{6b8}\x0a\x35\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x07\
	\x35\u{6c0}\x0a\x35\x0c\x35\x0e\x35\u{6c3}\x0b\x35\x03\x35\x03\x35\x03\x35\
	\x05\x35\u{6c8}\x0a\x35\x05\x35\u{6ca}\x0a\x35\x03\x36\x03\x36\x03\x36\x03\
	\x36\x03\x36\x05\x36\u{6d1}\x0a\x36\x03\x36\x03\x36\x05\x36\u{6d5}\x0a\x36\
	\x05\x36\u{6d7}\x0a\x36\x03\x36\x03\x36\x03\x36\x03\x36\x03\x36\x05\x36\
	\u{6de}\x0a\x36\x03\x36\x03\x36\x05\x36\u{6e2}\x0a\x36\x05\x36\u{6e4}\x0a\
	\x36\x05\x36\u{6e6}\x0a\x36\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x07\
	\x37\u{6ed}\x0a\x37\x0c\x37\x0e\x37\u{6f0}\x0b\x37\x03\x37\x03\x37\x03\x37\
	\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x05\x37\u{6fa}\x0a\x37\x03\x38\
	\x03\x38\x05\x38\u{6fe}\x0a\x38\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\
	\x03\x39\x07\x39\u{706}\x0a\x39\x0c\x39\x0e\x39\u{709}\x0b\x39\x03\x39\x03\
	\x39\x03\x3a\x03\x3a\x03\x3b\x03\x3b\x03\x3b\x05\x3b\u{712}\x0a\x3b\x03\
	\x3b\x03\x3b\x05\x3b\u{716}\x0a\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x07\x3b\u{71e}\x0a\x3b\x0c\x3b\x0e\x3b\u{721}\x0b\x3b\x03\x3c\
	\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\
	\x05\x3c\u{72d}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\
	\x05\x3c\u{735}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x07\x3c\
	\u{73c}\x0a\x3c\x0c\x3c\x0e\x3c\u{73f}\x0b\x3c\x03\x3c\x03\x3c\x03\x3c\x05\
	\x3c\u{744}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x05\
	\x3c\u{74c}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{752}\x0a\x3c\
	\x03\x3c\x03\x3c\x05\x3c\u{756}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\
	\u{75b}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{760}\x0a\x3c\x03\x3d\x03\
	\x3d\x03\x3d\x03\x3d\x05\x3d\u{766}\x0a\x3d\x03\x3d\x03\x3d\x03\x3d\x03\
	\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x07\
	\x3d\u{774}\x0a\x3d\x0c\x3d\x0e\x3d\u{777}\x0b\x3d\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x06\x3e\u{792}\x0a\x3e\x0d\x3e\x0e\x3e\
	\u{793}\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\
	\u{79d}\x0a\x3e\x0c\x3e\x0e\x3e\u{7a0}\x0b\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x05\x3e\u{7a7}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{7ac}\
	\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{7b1}\x0a\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{7bc}\
	\x0a\x3e\x0c\x3e\x0e\x3e\u{7bf}\x0b\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\
	\u{7c4}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{7cb}\x0a\
	\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{7d0}\x0a\x3e\x03\x3e\x05\x3e\u{7d3}\
	\x0a\x3e\x03\x3e\x05\x3e\u{7d6}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\
	\u{7db}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{7e0}\x0a\x3e\x0c\x3e\x0e\
	\x3e\u{7e3}\x0b\x3e\x05\x3e\u{7e5}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x07\x3e\u{7ec}\x0a\x3e\x0c\x3e\x0e\x3e\u{7ef}\x0b\x3e\x05\x3e\u{7f1}\
	\x0a\x3e\x03\x3e\x03\x3e\x05\x3e\u{7f5}\x0a\x3e\x03\x3e\x05\x3e\u{7f8}\x0a\
	\x3e\x03\x3e\x05\x3e\u{7fb}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{808}\x0a\
	\x3e\x0c\x3e\x0e\x3e\u{80b}\x0b\x3e\x05\x3e\u{80d}\x0a\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x06\x3e\u{81e}\x0a\x3e\x0d\x3e\x0e\x3e\
	\u{81f}\x03\x3e\x03\x3e\x05\x3e\u{824}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x06\x3e\u{82a}\x0a\x3e\x0d\x3e\x0e\x3e\u{82b}\x03\x3e\x03\x3e\x05\x3e\
	\u{830}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{847}\x0a\x3e\x0c\x3e\
	\x0e\x3e\u{84a}\x0b\x3e\x05\x3e\u{84c}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{855}\x0a\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x05\x3e\u{85b}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\
	\x3e\u{861}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{867}\x0a\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{870}\
	\x0a\x3e\x03\x3e\x05\x3e\u{873}\x0a\x3e\x03\x3e\x05\x3e\u{876}\x0a\x3e\x03\
	\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{889}\
	\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\
	\u{892}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x07\x3e\u{8a6}\x0a\x3e\x0c\x3e\x0e\x3e\u{8a9}\x0b\x3e\x05\
	\x3e\u{8ab}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x05\x3e\u{8b5}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x03\x3e\x05\x3e\u{8be}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x05\x3e\u{8c4}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{8ca}\
	\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x05\x3e\u{8d5}\x0a\x3e\x05\x3e\u{8d7}\x0a\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x05\x3e\u{8dc}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\
	\x3e\u{8e3}\x0a\x3e\x05\x3e\u{8e5}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x05\x3e\u{8eb}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{8f1}\x0a\
	\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{8fa}\
	\x0a\x3e\x0c\x3e\x0e\x3e\u{8fd}\x0b\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x05\x3e\u{905}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\
	\u{90a}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{90f}\x0a\x3e\x05\x3e\u{911}\
	\x0a\x3e\x05\x3e\u{913}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\
	\u{919}\x0a\x3e\x05\x3e\u{91b}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x07\x3e\u{923}\x0a\x3e\x0c\x3e\x0e\x3e\u{926}\x0b\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{92e}\x0a\x3e\x05\x3e\
	\u{930}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{936}\x0a\x3e\x05\
	\x3e\u{938}\x0a\x3e\x03\x3e\x05\x3e\u{93b}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{945}\x0a\x3e\x0c\x3e\
	\x0e\x3e\u{948}\x0b\x3e\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\
	\x03\x3f\x07\x3f\u{951}\x0a\x3f\x0c\x3f\x0e\x3f\u{954}\x0b\x3f\x05\x3f\u{956}\
	\x0a\x3f\x03\x40\x03\x40\x03\x40\x05\x40\u{95b}\x0a\x40\x03\x41\x03\x41\
	\x03\x41\x05\x41\u{960}\x0a\x41\x03\x42\x03\x42\x03\x42\x03\x42\x03\x43\
	\x03\x43\x03\x44\x03\x44\x03\x44\x03\x44\x05\x44\u{96c}\x0a\x44\x03\x45\
	\x03\x45\x05\x45\u{970}\x0a\x45\x03\x45\x03\x45\x05\x45\u{974}\x0a\x45\x03\
	\x45\x05\x45\u{977}\x0a\x45\x05\x45\u{979}\x0a\x45\x03\x46\x03\x46\x03\x46\
	\x03\x46\x03\x46\x03\x46\x05\x46\u{981}\x0a\x46\x03\x47\x05\x47\u{984}\x0a\
	\x47\x03\x47\x03\x47\x03\x47\x03\x47\x03\x47\x03\x47\x03\x47\x03\x47\x05\
	\x47\u{98e}\x0a\x47\x03\x48\x03\x48\x03\x49\x03\x49\x03\x49\x03\x49\x05\
	\x49\u{996}\x0a\x49\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x05\x4a\u{99c}\x0a\x4a\
	\x05\x4a\u{99e}\x0a\x4a\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\
	\x05\x4b\u{9a6}\x0a\x4b\x03\x4c\x03\x4c\x03\x4d\x03\x4d\x03\x4e\x03\x4e\
	\x03\x4f\x03\x4f\x05\x4f\u{9b0}\x0a\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\
	\x05\x4f\u{9b6}\x0a\x4f\x03\x50\x03\x50\x03\x51\x03\x51\x03\x52\x03\x52\
	\x03\x52\x03\x52\x03\x52\x03\x52\x07\x52\u{9c2}\x0a\x52\x0c\x52\x0e\x52\
	\u{9c5}\x0b\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x05\x52\
	\u{9cd}\x0a\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x05\x52\u{9d4}\x0a\
	\x52\x03\x52\x03\x52\x03\x52\x05\x52\u{9d9}\x0a\x52\x03\x52\x03\x52\x03\
	\x52\x03\x52\x03\x52\x05\x52\u{9e0}\x0a\x52\x03\x52\x03\x52\x03\x52\x03\
	\x52\x03\x52\x03\x52\x03\x52\x03\x52\x05\x52\u{9ea}\x0a\x52\x03\x52\x03\
	\x52\x03\x52\x05\x52\u{9ef}\x0a\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\
	\x52\x05\x52\u{9f6}\x0a\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\
	\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\
	\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x07\x52\u{a0e}\
	\x0a\x52\x0c\x52\x0e\x52\u{a11}\x0b\x52\x03\x52\x03\x52\x05\x52\u{a15}\x0a\
	\x52\x05\x52\u{a17}\x0a\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x05\
	\x52\u{a1e}\x0a\x52\x07\x52\u{a20}\x0a\x52\x0c\x52\x0e\x52\u{a23}\x0b\x52\
	\x03\x53\x03\x53\x03\x53\x03\x53\x05\x53\u{a29}\x0a\x53\x03\x54\x03\x54\
	\x05\x54\u{a2d}\x0a\x54\x03\x55\x03\x55\x03\x55\x03\x55\x03\x55\x03\x56\
	\x03\x56\x03\x56\x03\x56\x03\x56\x03\x56\x03\x57\x03\x57\x03\x57\x03\x57\
	\x05\x57\u{a3e}\x0a\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\
	\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x07\x57\u{a4b}\x0a\x57\x0c\x57\
	\x0e\x57\u{a4e}\x0b\x57\x03\x57\x03\x57\x03\x57\x03\x57\x05\x57\u{a54}\x0a\
	\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x05\x57\u{a5d}\
	\x0a\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x07\x57\u{a65}\
	\x0a\x57\x0c\x57\x0e\x57\u{a68}\x0b\x57\x03\x57\x03\x57\x05\x57\u{a6c}\x0a\
	\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x07\x57\u{a73}\x0a\x57\x0c\
	\x57\x0e\x57\u{a76}\x0b\x57\x03\x57\x03\x57\x05\x57\u{a7a}\x0a\x57\x03\x58\
	\x03\x58\x03\x58\x03\x58\x03\x58\x03\x58\x05\x58\u{a82}\x0a\x58\x03\x59\
	\x03\x59\x03\x59\x03\x59\x07\x59\u{a88}\x0a\x59\x0c\x59\x0e\x59\u{a8b}\x0b\
	\x59\x05\x59\u{a8d}\x0a\x59\x03\x59\x03\x59\x03\x59\x03\x59\x05\x59\u{a93}\
	\x0a\x59\x03\x59\x05\x59\u{a96}\x0a\x59\x03\x59\x03\x59\x03\x59\x03\x59\
	\x03\x59\x05\x59\u{a9d}\x0a\x59\x03\x59\x03\x59\x03\x59\x03\x59\x07\x59\
	\u{aa3}\x0a\x59\x0c\x59\x0e\x59\u{aa6}\x0b\x59\x05\x59\u{aa8}\x0a\x59\x03\
	\x59\x03\x59\x03\x59\x03\x59\x07\x59\u{aae}\x0a\x59\x0c\x59\x0e\x59\u{ab1}\
	\x0b\x59\x05\x59\u{ab3}\x0a\x59\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\
	\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\
	\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\
	\x03\x5a\x05\x5a\u{acd}\x0a\x5a\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\
	\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x05\x5b\u{ad8}\x0a\x5b\x03\x5c\x03\x5c\
	\x03\x5c\x05\x5c\u{add}\x0a\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\
	\x07\x5c\u{ae4}\x0a\x5c\x0c\x5c\x0e\x5c\u{ae7}\x0b\x5c\x03\x5d\x03\x5d\x03\
	\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x07\x5d\u{af1}\x0a\x5d\x0c\
	\x5d\x0e\x5d\u{af4}\x0b\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\
	\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x05\x5d\u{b02}\x0a\
	\x5d\x03\x5e\x03\x5e\x05\x5e\u{b06}\x0a\x5e\x03\x5e\x03\x5e\x05\x5e\u{b0a}\
	\x0a\x5e\x03\x5e\x03\x5e\x05\x5e\u{b0e}\x0a\x5e\x03\x5e\x03\x5e\x03\x5e\
	\x03\x5e\x05\x5e\u{b14}\x0a\x5e\x03\x5e\x03\x5e\x05\x5e\u{b18}\x0a\x5e\x03\
	\x5e\x03\x5e\x05\x5e\u{b1c}\x0a\x5e\x03\x5e\x03\x5e\x05\x5e\u{b20}\x0a\x5e\
	\x05\x5e\u{b22}\x0a\x5e\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x60\x03\x60\
	\x03\x60\x03\x60\x05\x60\u{b2c}\x0a\x60\x03\x61\x03\x61\x03\x61\x03\x61\
	\x03\x61\x05\x61\u{b33}\x0a\x61\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\
	\x03\x62\x03\x62\x05\x62\u{b3c}\x0a\x62\x03\x63\x03\x63\x03\x63\x03\x63\
	\x03\x63\x05\x63\u{b43}\x0a\x63\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\
	\x05\x64\u{b4a}\x0a\x64\x03\x65\x03\x65\x03\x65\x07\x65\u{b4f}\x0a\x65\x0c\
	\x65\x0e\x65\u{b52}\x0b\x65\x03\x66\x03\x66\x03\x67\x03\x67\x03\x67\x07\
	\x67\u{b59}\x0a\x67\x0c\x67\x0e\x67\u{b5c}\x0b\x67\x03\x68\x03\x68\x03\x68\
	\x03\x68\x03\x68\x03\x68\x03\x69\x03\x69\x03\x6a\x03\x6a\x03\x6a\x05\x6a\
	\u{b69}\x0a\x6a\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x05\x6b\u{b70}\x0a\
	\x6b\x03\x6c\x03\x6c\x03\x6c\x07\x6c\u{b75}\x0a\x6c\x0c\x6c\x0e\x6c\u{b78}\
	\x0b\x6c\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x05\x6d\u{b7f}\x0a\x6d\
	\x03\x6e\x05\x6e\u{b82}\x0a\x6e\x03\x6e\x03\x6e\x05\x6e\u{b86}\x0a\x6e\x03\
	\x6e\x03\x6e\x05\x6e\u{b8a}\x0a\x6e\x03\x6e\x05\x6e\u{b8d}\x0a\x6e\x03\x6f\
	\x03\x6f\x03\x6f\x02\x09\x26\x40\x74\x78\x7a\u{a2}\u{b6}\x70\x02\x04\x06\
	\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\
	\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\
	\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\
	\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\
	\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\
	\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\
	\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\
	\u{d8}\u{da}\u{dc}\x02\x24\x04\x02\x26\x26\u{d6}\u{d6}\x04\x02\x46\x46\x7c\
	\x7c\x04\x02\u{e2}\u{e2}\u{f3}\u{f3}\x04\x02\x64\x64\x73\x73\x04\x02\x57\
	\x57\x74\x74\x03\x02\u{de}\u{df}\x04\x02\x60\x60\u{a1}\u{a1}\x04\x02\u{131}\
	\u{131}\u{135}\u{135}\x04\x02\x56\x56\u{108}\u{108}\x04\x02\x1e\x1e\x49\
	\x49\x04\x02\x60\x60\u{8a}\u{8a}\x04\x02\x17\x17\x4c\x4c\x04\x02\x21\x21\
	\u{f2}\u{f2}\x05\x02\x23\x23\u{8c}\u{8c}\u{fd}\u{fd}\x04\x02\x75\x75\u{e6}\
	\u{e6}\x03\x02\u{12b}\u{12c}\x03\x02\u{12d}\u{12f}\x04\x02\u{87}\u{87}\u{b0}\
	\u{b0}\x03\x02\u{111}\u{113}\x06\x02\x54\x54\x5c\x5c\u{100}\u{100}\u{10a}\
	\u{10a}\x04\x02\x30\x30\u{107}\u{107}\x04\x02\x5f\x5f\u{e0}\u{e0}\x03\x02\
	\u{125}\u{12a}\x05\x02\x17\x17\x1b\x1b\u{ed}\u{ed}\x04\x02\x5c\x5c\u{100}\
	\u{100}\x07\x02\x42\x42\x70\x70\u{9e}\u{9f}\u{e4}\u{e4}\u{123}\u{123}\x03\
	\x02\u{a2}\u{a5}\x04\x02\x61\x61\u{c6}\u{c6}\x05\x02\x6b\x6b\u{81}\u{81}\
	\u{f6}\u{f6}\x06\x02\x4d\x4d\x7d\x7d\u{95}\u{95}\u{114}\u{114}\x04\x02\u{b3}\
	\u{b3}\u{122}\u{122}\x07\x02\x34\x34\x47\x47\x78\x78\u{e7}\u{e7}\u{10d}\
	\u{10d}\x04\x02\u{fb}\u{fb}\u{118}\u{118}\x39\x02\x13\x17\x19\x19\x1b\x1c\
	\x1e\x21\x23\x23\x25\x26\x29\x2b\x2d\x30\x32\x33\x37\x37\x40\x42\x44\x46\
	\x48\x49\x4b\x4b\x4d\x4e\x51\x52\x54\x54\x57\x57\x5a\x5a\x5d\x61\x63\x63\
	\x66\x6b\x6e\x6e\x70\x72\x74\x75\x77\x77\x7a\x7a\x7c\x7d\x7f\x7f\u{81}\u{81}\
	\u{87}\u{8c}\u{8e}\u{8e}\u{90}\u{90}\u{92}\u{92}\u{95}\u{9f}\u{a1}\u{a7}\
	\u{ab}\u{b0}\u{b2}\u{b4}\u{b7}\u{b7}\u{b9}\u{c7}\u{c9}\u{ce}\u{d0}\u{d8}\
	\u{da}\u{dc}\u{de}\u{e6}\u{e8}\u{f2}\u{f4}\u{f7}\u{f9}\u{fe}\u{101}\u{103}\
	\u{105}\u{107}\u{109}\u{10b}\u{10d}\u{10f}\u{111}\u{115}\u{117}\u{119}\u{11c}\
	\u{11c}\u{11e}\u{124}\x02\u{d65}\x02\u{de}\x03\x02\x02\x02\x04\u{e1}\x03\
	\x02\x02\x02\x06\u{e4}\x03\x02\x02\x02\x08\u{e7}\x03\x02\x02\x02\x0a\u{ea}\
	\x03\x02\x02\x02\x0c\u{409}\x03\x02\x02\x02\x0e\u{40c}\x03\x02\x02\x02\x10\
	\u{410}\x03\x02\x02\x02\x12\u{41e}\x03\x02\x02\x02\x14\u{420}\x03\x02\x02\
	\x02\x16\u{42e}\x03\x02\x02\x02\x18\u{434}\x03\x02\x02\x02\x1a\u{438}\x03\
	\x02\x02\x02\x1c\u{440}\x03\x02\x02\x02\x1e\u{446}\x03\x02\x02\x02\x20\u{448}\
	\x03\x02\x02\x02\x22\u{46d}\x03\x02\x02\x02\x24\u{46f}\x03\x02\x02\x02\x26\
	\u{471}\x03\x02\x02\x02\x28\u{495}\x03\x02\x02\x02\x2a\u{497}\x03\x02\x02\
	\x02\x2c\u{49f}\x03\x02\x02\x02\x2e\u{4c7}\x03\x02\x02\x02\x30\u{4d0}\x03\
	\x02\x02\x02\x32\u{502}\x03\x02\x02\x02\x34\u{511}\x03\x02\x02\x02\x36\u{513}\
	\x03\x02\x02\x02\x38\u{51a}\x03\x02\x02\x02\x3a\u{537}\x03\x02\x02\x02\x3c\
	\u{540}\x03\x02\x02\x02\x3e\u{551}\x03\x02\x02\x02\x40\u{553}\x03\x02\x02\
	\x02\x42\u{57a}\x03\x02\x02\x02\x44\u{58a}\x03\x02\x02\x02\x46\u{58c}\x03\
	\x02\x02\x02\x48\u{595}\x03\x02\x02\x02\x4a\u{597}\x03\x02\x02\x02\x4c\u{59f}\
	\x03\x02\x02\x02\x4e\u{5a5}\x03\x02\x02\x02\x50\u{5a7}\x03\x02\x02\x02\x52\
	\u{5fc}\x03\x02\x02\x02\x54\u{60b}\x03\x02\x02\x02\x56\u{616}\x03\x02\x02\
	\x02\x58\u{62b}\x03\x02\x02\x02\x5a\u{62d}\x03\x02\x02\x02\x5c\u{63a}\x03\
	\x02\x02\x02\x5e\u{63e}\x03\x02\x02\x02\x60\u{648}\x03\x02\x02\x02\x62\u{678}\
	\x03\x02\x02\x02\x64\u{67a}\x03\x02\x02\x02\x66\u{696}\x03\x02\x02\x02\x68\
	\u{69d}\x03\x02\x02\x02\x6a\u{6e5}\x03\x02\x02\x02\x6c\u{6f9}\x03\x02\x02\
	\x02\x6e\u{6fb}\x03\x02\x02\x02\x70\u{6ff}\x03\x02\x02\x02\x72\u{70c}\x03\
	\x02\x02\x02\x74\u{715}\x03\x02\x02\x02\x76\u{75f}\x03\x02\x02\x02\x78\u{765}\
	\x03\x02\x02\x02\x7a\u{93a}\x03\x02\x02\x02\x7c\u{949}\x03\x02\x02\x02\x7e\
	\u{957}\x03\x02\x02\x02\u{80}\u{95c}\x03\x02\x02\x02\u{82}\u{961}\x03\x02\
	\x02\x02\u{84}\u{965}\x03\x02\x02\x02\u{86}\u{96b}\x03\x02\x02\x02\u{88}\
	\u{978}\x03\x02\x02\x02\u{8a}\u{980}\x03\x02\x02\x02\u{8c}\u{98d}\x03\x02\
	\x02\x02\u{8e}\u{98f}\x03\x02\x02\x02\u{90}\u{995}\x03\x02\x02\x02\u{92}\
	\u{99d}\x03\x02\x02\x02\u{94}\u{9a5}\x03\x02\x02\x02\u{96}\u{9a7}\x03\x02\
	\x02\x02\u{98}\u{9a9}\x03\x02\x02\x02\u{9a}\u{9ab}\x03\x02\x02\x02\u{9c}\
	\u{9ad}\x03\x02\x02\x02\u{9e}\u{9b7}\x03\x02\x02\x02\u{a0}\u{9b9}\x03\x02\
	\x02\x02\u{a2}\u{a16}\x03\x02\x02\x02\u{a4}\u{a28}\x03\x02\x02\x02\u{a6}\
	\u{a2c}\x03\x02\x02\x02\u{a8}\u{a2e}\x03\x02\x02\x02\u{aa}\u{a33}\x03\x02\
	\x02\x02\u{ac}\u{a79}\x03\x02\x02\x02\u{ae}\u{a7b}\x03\x02\x02\x02\u{b0}\
	\u{a8c}\x03\x02\x02\x02\u{b2}\u{acc}\x03\x02\x02\x02\u{b4}\u{ad7}\x03\x02\
	\x02\x02\u{b6}\u{ad9}\x03\x02\x02\x02\u{b8}\u{b01}\x03\x02\x02\x02\u{ba}\
	\u{b21}\x03\x02\x02\x02\u{bc}\u{b23}\x03\x02\x02\x02\u{be}\u{b2b}\x03\x02\
	\x02\x02\u{c0}\u{b32}\x03\x02\x02\x02\u{c2}\u{b3b}\x03\x02\x02\x02\u{c4}\
	\u{b42}\x03\x02\x02\x02\u{c6}\u{b49}\x03\x02\x02\x02\u{c8}\u{b4b}\x03\x02\
	\x02\x02\u{ca}\u{b53}\x03\x02\x02\x02\u{cc}\u{b55}\x03\x02\x02\x02\u{ce}\
	\u{b5d}\x03\x02\x02\x02\u{d0}\u{b63}\x03\x02\x02\x02\u{d2}\u{b68}\x03\x02\
	\x02\x02\u{d4}\u{b6f}\x03\x02\x02\x02\u{d6}\u{b71}\x03\x02\x02\x02\u{d8}\
	\u{b7e}\x03\x02\x02\x02\u{da}\u{b8c}\x03\x02\x02\x02\u{dc}\u{b8e}\x03\x02\
	\x02\x02\u{de}\u{df}\x05\x0c\x07\x02\u{df}\u{e0}\x07\x02\x02\x03\u{e0}\x03\
	\x03\x02\x02\x02\u{e1}\u{e2}\x05\x72\x3a\x02\u{e2}\u{e3}\x07\x02\x02\x03\
	\u{e3}\x05\x03\x02\x02\x02\u{e4}\u{e5}\x05\u{c8}\x65\x02\u{e5}\u{e6}\x07\
	\x02\x02\x03\u{e6}\x07\x03\x02\x02\x02\u{e7}\u{e8}\x05\u{a2}\x52\x02\u{e8}\
	\u{e9}\x07\x02\x02\x03\u{e9}\x09\x03\x02\x02\x02\u{ea}\u{eb}\x05\u{b6}\x5c\
	\x02\u{eb}\u{ec}\x07\x02\x02\x03\u{ec}\x0b\x03\x02\x02\x02\u{ed}\u{40a}\
	\x05\x0e\x08\x02\u{ee}\u{ef}\x07\u{10e}\x02\x02\u{ef}\u{40a}\x05\u{d8}\x6d\
	\x02\u{f0}\u{f1}\x07\u{10e}\x02\x02\u{f1}\u{f2}\x05\u{d8}\x6d\x02\u{f2}\
	\u{f3}\x07\x03\x02\x02\u{f3}\u{f4}\x05\u{d8}\x6d\x02\u{f4}\u{40a}\x03\x02\
	\x02\x02\u{f5}\u{f6}\x07\x34\x02\x02\u{f6}\u{fa}\x07\u{e2}\x02\x02\u{f7}\
	\u{f8}\x07\x71\x02\x02\u{f8}\u{f9}\x07\u{a9}\x02\x02\u{f9}\u{fb}\x07\x59\
	\x02\x02\u{fa}\u{f7}\x03\x02\x02\x02\u{fa}\u{fb}\x03\x02\x02\x02\u{fb}\u{fc}\
	\x03\x02\x02\x02\u{fc}\u{ff}\x05\u{cc}\x67\x02\u{fd}\u{fe}\x07\x20\x02\x02\
	\u{fe}\u{100}\x05\u{d4}\x6b\x02\u{ff}\u{fd}\x03\x02\x02\x02\u{ff}\u{100}\
	\x03\x02\x02\x02\u{100}\u{103}\x03\x02\x02\x02\u{101}\u{102}\x07\u{11d}\
	\x02\x02\u{102}\u{104}\x05\x18\x0d\x02\u{103}\u{101}\x03\x02\x02\x02\u{103}\
	\u{104}\x03\x02\x02\x02\u{104}\u{40a}\x03\x02\x02\x02\u{105}\u{106}\x07\
	\x4f\x02\x02\u{106}\u{109}\x07\u{e2}\x02\x02\u{107}\u{108}\x07\x71\x02\x02\
	\u{108}\u{10a}\x07\x59\x02\x02\u{109}\u{107}\x03\x02\x02\x02\u{109}\u{10a}\
	\x03\x02\x02\x02\u{10a}\u{10b}\x03\x02\x02\x02\u{10b}\u{10d}\x05\u{cc}\x67\
	\x02\u{10c}\u{10e}\x09\x02\x02\x02\u{10d}\u{10c}\x03\x02\x02\x02\u{10d}\
	\u{10e}\x03\x02\x02\x02\u{10e}\u{40a}\x03\x02\x02\x02\u{10f}\u{110}\x07\
	\x18\x02\x02\u{110}\u{111}\x07\u{e2}\x02\x02\u{111}\u{112}\x05\u{cc}\x67\
	\x02\u{112}\u{113}\x07\u{d1}\x02\x02\u{113}\u{114}\x07\u{fc}\x02\x02\u{114}\
	\u{115}\x05\u{d8}\x6d\x02\u{115}\u{40a}\x03\x02\x02\x02\u{116}\u{117}\x07\
	\x18\x02\x02\u{117}\u{118}\x07\u{e2}\x02\x02\u{118}\u{119}\x05\u{cc}\x67\
	\x02\u{119}\u{11a}\x07\u{ea}\x02\x02\u{11a}\u{11b}\x07\x20\x02\x02\u{11b}\
	\u{11c}\x05\u{d4}\x6b\x02\u{11c}\u{40a}\x03\x02\x02\x02\u{11d}\u{11e}\x07\
	\x34\x02\x02\u{11e}\u{122}\x07\u{f3}\x02\x02\u{11f}\u{120}\x07\x71\x02\x02\
	\u{120}\u{121}\x07\u{a9}\x02\x02\u{121}\u{123}\x07\x59\x02\x02\u{122}\u{11f}\
	\x03\x02\x02\x02\u{122}\u{123}\x03\x02\x02\x02\u{123}\u{124}\x03\x02\x02\
	\x02\u{124}\u{126}\x05\u{cc}\x67\x02\u{125}\u{127}\x05\x60\x31\x02\u{126}\
	\u{125}\x03\x02\x02\x02\u{126}\u{127}\x03\x02\x02\x02\u{127}\u{12a}\x03\
	\x02\x02\x02\u{128}\u{129}\x07\x2d\x02\x02\u{129}\u{12b}\x05\u{92}\x4a\x02\
	\u{12a}\u{128}\x03\x02\x02\x02\u{12a}\u{12b}\x03\x02\x02\x02\u{12b}\u{12e}\
	\x03\x02\x02\x02\u{12c}\u{12d}\x07\u{11d}\x02\x02\u{12d}\u{12f}\x05\x18\
	\x0d\x02\u{12e}\u{12c}\x03\x02\x02\x02\u{12e}\u{12f}\x03\x02\x02\x02\u{12f}\
	\u{130}\x03\x02\x02\x02\u{130}\u{136}\x07\x1d\x02\x02\u{131}\u{137}\x05\
	\x0e\x08\x02\u{132}\u{133}\x07\x04\x02\x02\u{133}\u{134}\x05\x0e\x08\x02\
	\u{134}\u{135}\x07\x05\x02\x02\u{135}\u{137}\x03\x02\x02\x02\u{136}\u{131}\
	\x03\x02\x02\x02\u{136}\u{132}\x03\x02\x02\x02\u{137}\u{13d}\x03\x02\x02\
	\x02\u{138}\u{13a}\x07\u{11d}\x02\x02\u{139}\u{13b}\x07\u{a6}\x02\x02\u{13a}\
	\u{139}\x03\x02\x02\x02\u{13a}\u{13b}\x03\x02\x02\x02\u{13b}\u{13c}\x03\
	\x02\x02\x02\u{13c}\u{13e}\x07\x40\x02\x02\u{13d}\u{138}\x03\x02\x02\x02\
	\u{13d}\u{13e}\x03\x02\x02\x02\u{13e}\u{40a}\x03\x02\x02\x02\u{13f}\u{140}\
	\x07\x34\x02\x02\u{140}\u{144}\x07\u{f3}\x02\x02\u{141}\u{142}\x07\x71\x02\
	\x02\u{142}\u{143}\x07\u{a9}\x02\x02\u{143}\u{145}\x07\x59\x02\x02\u{144}\
	\u{141}\x03\x02\x02\x02\u{144}\u{145}\x03\x02\x02\x02\u{145}\u{146}\x03\
	\x02\x02\x02\u{146}\u{152}\x05\u{cc}\x67\x02\u{147}\u{148}\x07\x04\x02\x02\
	\u{148}\u{14d}\x05\x12\x0a\x02\u{149}\u{14a}\x07\x2c\x02\x02\u{14a}\u{14c}\
	\x05\x12\x0a\x02\u{14b}\u{149}\x03\x02\x02\x02\u{14c}\u{14f}\x03\x02\x02\
	\x02\u{14d}\u{14b}\x03\x02\x02\x02\u{14d}\u{14e}\x03\x02\x02\x02\u{14e}\
	\u{150}\x03\x02\x02\x02\u{14f}\u{14d}\x03\x02\x02\x02\u{150}\u{151}\x07\
	\x05\x02\x02\u{151}\u{153}\x03\x02\x02\x02\u{152}\u{147}\x03\x02\x02\x02\
	\u{152}\u{153}\x03\x02\x02\x02\u{153}\u{156}\x03\x02\x02\x02\u{154}\u{155}\
	\x07\x2d\x02\x02\u{155}\u{157}\x05\u{92}\x4a\x02\u{156}\u{154}\x03\x02\x02\
	\x02\u{156}\u{157}\x03\x02\x02\x02\u{157}\u{15a}\x03\x02\x02\x02\u{158}\
	\u{159}\x07\u{11d}\x02\x02\u{159}\u{15b}\x05\x18\x0d\x02\u{15a}\u{158}\x03\
	\x02\x02\x02\u{15a}\u{15b}\x03\x02\x02\x02\u{15b}\u{40a}\x03\x02\x02\x02\
	\u{15c}\u{15d}\x07\x4f\x02\x02\u{15d}\u{160}\x07\u{f3}\x02\x02\u{15e}\u{15f}\
	\x07\x71\x02\x02\u{15f}\u{161}\x07\x59\x02\x02\u{160}\u{15e}\x03\x02\x02\
	\x02\u{160}\u{161}\x03\x02\x02\x02\u{161}\u{162}\x03\x02\x02\x02\u{162}\
	\u{40a}\x05\u{cc}\x67\x02\u{163}\u{164}\x07\x78\x02\x02\u{164}\u{165}\x07\
	\x7b\x02\x02\u{165}\u{167}\x05\u{cc}\x67\x02\u{166}\u{168}\x05\x60\x31\x02\
	\u{167}\u{166}\x03\x02\x02\x02\u{167}\u{168}\x03\x02\x02\x02\u{168}\u{169}\
	\x03\x02\x02\x02\u{169}\u{16a}\x05\x0e\x08\x02\u{16a}\u{40a}\x03\x02\x02\
	\x02\u{16b}\u{16c}\x07\x47\x02\x02\u{16c}\u{16d}\x07\x64\x02\x02\u{16d}\
	\u{170}\x05\u{cc}\x67\x02\u{16e}\u{16f}\x07\u{11b}\x02\x02\u{16f}\u{171}\
	\x05\x74\x3b\x02\u{170}\u{16e}\x03\x02\x02\x02\u{170}\u{171}\x03\x02\x02\
	\x02\u{171}\u{40a}\x03\x02\x02\x02\u{172}\u{173}\x07\u{101}\x02\x02\u{173}\
	\u{174}\x07\u{f3}\x02\x02\u{174}\u{40a}\x05\u{cc}\x67\x02\u{175}\u{176}\
	\x07\x2d\x02\x02\u{176}\u{177}\x07\u{b1}\x02\x02\u{177}\u{178}\x07\u{f3}\
	\x02\x02\u{178}\u{179}\x05\u{cc}\x67\x02\u{179}\u{17c}\x07\x7e\x02\x02\u{17a}\
	\u{17d}\x05\u{92}\x4a\x02\u{17b}\u{17d}\x07\u{aa}\x02\x02\u{17c}\u{17a}\
	\x03\x02\x02\x02\u{17c}\u{17b}\x03\x02\x02\x02\u{17d}\u{40a}\x03\x02\x02\
	\x02\u{17e}\u{17f}\x07\x2d\x02\x02\u{17f}\u{180}\x07\u{b1}\x02\x02\u{180}\
	\u{181}\x07\u{119}\x02\x02\u{181}\u{182}\x05\u{cc}\x67\x02\u{182}\u{185}\
	\x07\x7e\x02\x02\u{183}\u{186}\x05\u{92}\x4a\x02\u{184}\u{186}\x07\u{aa}\
	\x02\x02\u{185}\u{183}\x03\x02\x02\x02\u{185}\u{184}\x03\x02\x02\x02\u{186}\
	\u{40a}\x03\x02\x02\x02\u{187}\u{188}\x07\x2d\x02\x02\u{188}\u{189}\x07\
	\u{b1}\x02\x02\u{189}\u{18a}\x07\x2a\x02\x02\u{18a}\u{18b}\x05\u{cc}\x67\
	\x02\u{18b}\u{18e}\x07\x7e\x02\x02\u{18c}\u{18f}\x05\u{92}\x4a\x02\u{18d}\
	\u{18f}\x07\u{aa}\x02\x02\u{18e}\u{18c}\x03\x02\x02\x02\u{18e}\u{18d}\x03\
	\x02\x02\x02\u{18f}\u{40a}\x03\x02\x02\x02\u{190}\u{191}\x07\x18\x02\x02\
	\u{191}\u{194}\x07\u{f3}\x02\x02\u{192}\u{193}\x07\x71\x02\x02\u{193}\u{195}\
	\x07\x59\x02\x02\u{194}\u{192}\x03\x02\x02\x02\u{194}\u{195}\x03\x02\x02\
	\x02\u{195}\u{196}\x03\x02\x02\x02\u{196}\u{197}\x05\u{cc}\x67\x02\u{197}\
	\u{198}\x07\u{d1}\x02\x02\u{198}\u{199}\x07\u{fc}\x02\x02\u{199}\u{19a}\
	\x05\u{cc}\x67\x02\u{19a}\u{40a}\x03\x02\x02\x02\u{19b}\u{19c}\x07\x18\x02\
	\x02\u{19c}\u{19f}\x07\u{f3}\x02\x02\u{19d}\u{19e}\x07\x71\x02\x02\u{19e}\
	\u{1a0}\x07\x59\x02\x02\u{19f}\u{19d}\x03\x02\x02\x02\u{19f}\u{1a0}\x03\
	\x02\x02\x02\u{1a0}\u{1a1}\x03\x02\x02\x02\u{1a1}\u{1a2}\x05\u{cc}\x67\x02\
	\u{1a2}\u{1a3}\x07\x14\x02\x02\u{1a3}\u{1a7}\x07\x2a\x02\x02\u{1a4}\u{1a5}\
	\x07\x71\x02\x02\u{1a5}\u{1a6}\x07\u{a9}\x02\x02\u{1a6}\u{1a8}\x07\x59\x02\
	\x02\u{1a7}\u{1a4}\x03\x02\x02\x02\u{1a7}\u{1a8}\x03\x02\x02\x02\u{1a8}\
	\u{1a9}\x03\x02\x02\x02\u{1a9}\u{1aa}\x05\x14\x0b\x02\u{1aa}\u{40a}\x03\
	\x02\x02\x02\u{1ab}\u{1ac}\x07\x18\x02\x02\u{1ac}\u{1af}\x07\u{f3}\x02\x02\
	\u{1ad}\u{1ae}\x07\x71\x02\x02\u{1ae}\u{1b0}\x07\x59\x02\x02\u{1af}\u{1ad}\
	\x03\x02\x02\x02\u{1af}\u{1b0}\x03\x02\x02\x02\u{1b0}\u{1b1}\x03\x02\x02\
	\x02\u{1b1}\u{1b2}\x05\u{cc}\x67\x02\u{1b2}\u{1b3}\x07\u{d1}\x02\x02\u{1b3}\
	\u{1b6}\x07\x2a\x02\x02\u{1b4}\u{1b5}\x07\x71\x02\x02\u{1b5}\u{1b7}\x07\
	\x59\x02\x02\u{1b6}\u{1b4}\x03\x02\x02\x02\u{1b6}\u{1b7}\x03\x02\x02\x02\
	\u{1b7}\u{1b8}\x03\x02\x02\x02\u{1b8}\u{1b9}\x05\u{d8}\x6d\x02\u{1b9}\u{1ba}\
	\x07\u{fc}\x02\x02\u{1ba}\u{1bb}\x05\u{d8}\x6d\x02\u{1bb}\u{40a}\x03\x02\
	\x02\x02\u{1bc}\u{1bd}\x07\x18\x02\x02\u{1bd}\u{1c0}\x07\u{f3}\x02\x02\u{1be}\
	\u{1bf}\x07\x71\x02\x02\u{1bf}\u{1c1}\x07\x59\x02\x02\u{1c0}\u{1be}\x03\
	\x02\x02\x02\u{1c0}\u{1c1}\x03\x02\x02\x02\u{1c1}\u{1c2}\x03\x02\x02\x02\
	\u{1c2}\u{1c3}\x05\u{cc}\x67\x02\u{1c3}\u{1c4}\x07\x4f\x02\x02\u{1c4}\u{1c7}\
	\x07\x2a\x02\x02\u{1c5}\u{1c6}\x07\x71\x02\x02\u{1c6}\u{1c8}\x07\x59\x02\
	\x02\u{1c7}\u{1c5}\x03\x02\x02\x02\u{1c7}\u{1c8}\x03\x02\x02\x02\u{1c8}\
	\u{1c9}\x03\x02\x02\x02\u{1c9}\u{1ca}\x05\u{cc}\x67\x02\u{1ca}\u{40a}\x03\
	\x02\x02\x02\u{1cb}\u{1cc}\x07\x18\x02\x02\u{1cc}\u{1cf}\x07\u{f3}\x02\x02\
	\u{1cd}\u{1ce}\x07\x71\x02\x02\u{1ce}\u{1d0}\x07\x59\x02\x02\u{1cf}\u{1cd}\
	\x03\x02\x02\x02\u{1cf}\u{1d0}\x03\x02\x02\x02\u{1d0}\u{1d1}\x03\x02\x02\
	\x02\u{1d1}\u{1d2}\x05\u{cc}\x67\x02\u{1d2}\u{1d3}\x07\x18\x02\x02\u{1d3}\
	\u{1d4}\x07\x2a\x02\x02\u{1d4}\u{1d5}\x05\u{d8}\x6d\x02\u{1d5}\u{1d6}\x07\
	\u{ea}\x02\x02\u{1d6}\u{1d7}\x07\x40\x02\x02\u{1d7}\u{1d8}\x07\u{103}\x02\
	\x02\u{1d8}\u{1d9}\x05\u{a2}\x52\x02\u{1d9}\u{40a}\x03\x02\x02\x02\u{1da}\
	\u{1db}\x07\x18\x02\x02\u{1db}\u{1dc}\x07\u{f3}\x02\x02\u{1dc}\u{1dd}\x05\
	\u{cc}\x67\x02\u{1dd}\u{1de}\x07\u{ea}\x02\x02\u{1de}\u{1df}\x07\x20\x02\
	\x02\u{1df}\u{1e0}\x05\u{d4}\x6b\x02\u{1e0}\u{40a}\x03\x02\x02\x02\u{1e1}\
	\u{1e2}\x07\x18\x02\x02\u{1e2}\u{1e3}\x07\u{f3}\x02\x02\u{1e3}\u{1e4}\x05\
	\u{cc}\x67\x02\u{1e4}\u{1e5}\x07\u{ea}\x02\x02\u{1e5}\u{1e6}\x07\u{ca}\x02\
	\x02\u{1e6}\u{1e7}\x05\x1a\x0e\x02\u{1e7}\u{40a}\x03\x02\x02\x02\u{1e8}\
	\u{1e9}\x07\x18\x02\x02\u{1e9}\u{1ea}\x07\u{f3}\x02\x02\u{1ea}\u{1eb}\x05\
	\u{cc}\x67\x02\u{1eb}\u{1ec}\x07\x58\x02\x02\u{1ec}\u{1f9}\x05\u{d8}\x6d\
	\x02\u{1ed}\u{1f6}\x07\x04\x02\x02\u{1ee}\u{1f3}\x05\u{c4}\x63\x02\u{1ef}\
	\u{1f0}\x07\x2c\x02\x02\u{1f0}\u{1f2}\x05\u{c4}\x63\x02\u{1f1}\u{1ef}\x03\
	\x02\x02\x02\u{1f2}\u{1f5}\x03\x02\x02\x02\u{1f3}\u{1f1}\x03\x02\x02\x02\
	\u{1f3}\u{1f4}\x03\x02\x02\x02\u{1f4}\u{1f7}\x03\x02\x02\x02\u{1f5}\u{1f3}\
	\x03\x02\x02\x02\u{1f6}\u{1ee}\x03\x02\x02\x02\u{1f6}\u{1f7}\x03\x02\x02\
	\x02\u{1f7}\u{1f8}\x03\x02\x02\x02\u{1f8}\u{1fa}\x07\x05\x02\x02\u{1f9}\
	\u{1ed}\x03\x02\x02\x02\u{1f9}\u{1fa}\x03\x02\x02\x02\u{1fa}\u{1fd}\x03\
	\x02\x02\x02\u{1fb}\u{1fc}\x07\u{11b}\x02\x02\u{1fc}\u{1fe}\x05\x74\x3b\
	\x02\u{1fd}\u{1fb}\x03\x02\x02\x02\u{1fd}\u{1fe}\x03\x02\x02\x02\u{1fe}\
	\u{40a}\x03\x02\x02\x02\u{1ff}\u{200}\x07\x19\x02\x02\u{200}\u{203}\x05\
	\u{cc}\x67\x02\u{201}\u{202}\x07\u{11d}\x02\x02\u{202}\u{204}\x05\x18\x0d\
	\x02\u{203}\u{201}\x03\x02\x02\x02\u{203}\u{204}\x03\x02\x02\x02\u{204}\
	\u{40a}\x03\x02\x02\x02\u{205}\u{208}\x07\x34\x02\x02\u{206}\u{207}\x07\
	\u{b5}\x02\x02\u{207}\u{209}\x07\u{d3}\x02\x02\u{208}\u{206}\x03\x02\x02\
	\x02\u{208}\u{209}\x03\x02\x02\x02\u{209}\u{20a}\x03\x02\x02\x02\u{20a}\
	\u{20b}\x07\u{9b}\x02\x02\u{20b}\u{20f}\x07\u{119}\x02\x02\u{20c}\u{20d}\
	\x07\x71\x02\x02\u{20d}\u{20e}\x07\u{a9}\x02\x02\u{20e}\u{210}\x07\x59\x02\
	\x02\u{20f}\u{20c}\x03\x02\x02\x02\u{20f}\u{210}\x03\x02\x02\x02\u{210}\
	\u{211}\x03\x02\x02\x02\u{211}\u{215}\x05\u{cc}\x67\x02\u{212}\u{213}\x07\
	\x67\x02\x02\u{213}\u{214}\x07\u{c3}\x02\x02\u{214}\u{216}\x05\u{9c}\x4f\
	\x02\u{215}\u{212}\x03\x02\x02\x02\u{215}\u{216}\x03\x02\x02\x02\u{216}\
	\u{219}\x03\x02\x02\x02\u{217}\u{218}\x07\x2d\x02\x02\u{218}\u{21a}\x05\
	\u{92}\x4a\x02\u{219}\u{217}\x03\x02\x02\x02\u{219}\u{21a}\x03\x02\x02\x02\
	\u{21a}\u{21d}\x03\x02\x02\x02\u{21b}\u{21c}\x07\u{11d}\x02\x02\u{21c}\u{21e}\
	\x05\x18\x0d\x02\u{21d}\u{21b}\x03\x02\x02\x02\u{21d}\u{21e}\x03\x02\x02\
	\x02\u{21e}\u{21f}\x03\x02\x02\x02\u{21f}\u{220}\x07\x1d\x02\x02\u{220}\
	\u{221}\x05\x0e\x08\x02\u{221}\u{40a}\x03\x02\x02\x02\u{222}\u{225}\x07\
	\x34\x02\x02\u{223}\u{224}\x07\u{b5}\x02\x02\u{224}\u{226}\x07\u{d3}\x02\
	\x02\u{225}\u{223}\x03\x02\x02\x02\u{225}\u{226}\x03\x02\x02\x02\u{226}\
	\u{227}\x03\x02\x02\x02\u{227}\u{228}\x07\u{119}\x02\x02\u{228}\u{22b}\x05\
	\u{cc}\x67\x02\u{229}\u{22a}\x07\x2d\x02\x02\u{22a}\u{22c}\x05\u{92}\x4a\
	\x02\u{22b}\u{229}\x03\x02\x02\x02\u{22b}\u{22c}\x03\x02\x02\x02\u{22c}\
	\u{22f}\x03\x02\x02\x02\u{22d}\u{22e}\x07\u{e5}\x02\x02\u{22e}\u{230}\x09\
	\x03\x02\x02\u{22f}\u{22d}\x03\x02\x02\x02\u{22f}\u{230}\x03\x02\x02\x02\
	\u{230}\u{231}\x03\x02\x02\x02\u{231}\u{232}\x07\x1d\x02\x02\u{232}\u{233}\
	\x05\x0e\x08\x02\u{233}\u{40a}\x03\x02\x02\x02\u{234}\u{235}\x07\u{d0}\x02\
	\x02\u{235}\u{236}\x07\u{9b}\x02\x02\u{236}\u{237}\x07\u{119}\x02\x02\u{237}\
	\u{40a}\x05\u{cc}\x67\x02\u{238}\u{239}\x07\x4f\x02\x02\u{239}\u{23a}\x07\
	\u{9b}\x02\x02\u{23a}\u{23d}\x07\u{119}\x02\x02\u{23b}\u{23c}\x07\x71\x02\
	\x02\u{23c}\u{23e}\x07\x59\x02\x02\u{23d}\u{23b}\x03\x02\x02\x02\u{23d}\
	\u{23e}\x03\x02\x02\x02\u{23e}\u{23f}\x03\x02\x02\x02\u{23f}\u{40a}\x05\
	\u{cc}\x67\x02\u{240}\u{241}\x07\x18\x02\x02\u{241}\u{242}\x07\u{9b}\x02\
	\x02\u{242}\u{245}\x07\u{119}\x02\x02\u{243}\u{244}\x07\x71\x02\x02\u{244}\
	\u{246}\x07\x59\x02\x02\u{245}\u{243}\x03\x02\x02\x02\u{245}\u{246}\x03\
	\x02\x02\x02\u{246}\u{247}\x03\x02\x02\x02\u{247}\u{248}\x05\u{cc}\x67\x02\
	\u{248}\u{249}\x07\u{d1}\x02\x02\u{249}\u{24a}\x07\u{fc}\x02\x02\u{24a}\
	\u{24b}\x05\u{cc}\x67\x02\u{24b}\u{40a}\x03\x02\x02\x02\u{24c}\u{24d}\x07\
	\x18\x02\x02\u{24d}\u{24e}\x07\u{9b}\x02\x02\u{24e}\u{24f}\x07\u{119}\x02\
	\x02\u{24f}\u{250}\x05\u{cc}\x67\x02\u{250}\u{251}\x07\u{ea}\x02\x02\u{251}\
	\u{252}\x07\u{ca}\x02\x02\u{252}\u{253}\x05\x1a\x0e\x02\u{253}\u{40a}\x03\
	\x02\x02\x02\u{254}\u{255}\x07\x4f\x02\x02\u{255}\u{258}\x07\u{119}\x02\
	\x02\u{256}\u{257}\x07\x71\x02\x02\u{257}\u{259}\x07\x59\x02\x02\u{258}\
	\u{256}\x03\x02\x02\x02\u{258}\u{259}\x03\x02\x02\x02\u{259}\u{25a}\x03\
	\x02\x02\x02\u{25a}\u{40a}\x05\u{cc}\x67\x02\u{25b}\u{25c}\x07\x18\x02\x02\
	\u{25c}\u{25d}\x07\u{119}\x02\x02\u{25d}\u{25e}\x05\u{cc}\x67\x02\u{25e}\
	\u{25f}\x07\u{d1}\x02\x02\u{25f}\u{260}\x07\u{fc}\x02\x02\u{260}\u{261}\
	\x05\u{cc}\x67\x02\u{261}\u{40a}\x03\x02\x02\x02\u{262}\u{263}\x07\x18\x02\
	\x02\u{263}\u{264}\x07\u{119}\x02\x02\u{264}\u{265}\x05\u{cc}\x67\x02\u{265}\
	\u{266}\x07\u{ea}\x02\x02\u{266}\u{267}\x07\x20\x02\x02\u{267}\u{268}\x05\
	\u{d4}\x6b\x02\u{268}\u{40a}\x03\x02\x02\x02\u{269}\u{26a}\x07\x25\x02\x02\
	\u{26a}\u{26b}\x05\u{cc}\x67\x02\u{26b}\u{274}\x07\x04\x02\x02\u{26c}\u{271}\
	\x05\u{c4}\x63\x02\u{26d}\u{26e}\x07\x2c\x02\x02\u{26e}\u{270}\x05\u{c4}\
	\x63\x02\u{26f}\u{26d}\x03\x02\x02\x02\u{270}\u{273}\x03\x02\x02\x02\u{271}\
	\u{26f}\x03\x02\x02\x02\u{271}\u{272}\x03\x02\x02\x02\u{272}\u{275}\x03\
	\x02\x02\x02\u{273}\u{271}\x03\x02\x02\x02\u{274}\u{26c}\x03\x02\x02\x02\
	\u{274}\u{275}\x03\x02\x02\x02\u{275}\u{276}\x03\x02\x02\x02\u{276}\u{277}\
	\x07\x05\x02\x02\u{277}\u{40a}\x03\x02\x02\x02\u{278}\u{279}\x07\x34\x02\
	\x02\u{279}\u{27a}\x07\u{da}\x02\x02\u{27a}\u{27e}\x05\u{d8}\x6d\x02\u{27b}\
	\u{27c}\x07\u{11d}\x02\x02\u{27c}\u{27d}\x07\x15\x02\x02\u{27d}\u{27f}\x05\
	\u{d2}\x6a\x02\u{27e}\u{27b}\x03\x02\x02\x02\u{27e}\u{27f}\x03\x02\x02\x02\
	\u{27f}\u{282}\x03\x02\x02\x02\u{280}\u{281}\x07\x73\x02\x02\u{281}\u{283}\
	\x05\u{d8}\x6d\x02\u{282}\u{280}\x03\x02\x02\x02\u{282}\u{283}\x03\x02\x02\
	\x02\u{283}\u{40a}\x03\x02\x02\x02\u{284}\u{285}\x07\x4f\x02\x02\u{285}\
	\u{286}\x07\u{da}\x02\x02\u{286}\u{289}\x05\u{d8}\x6d\x02\u{287}\u{288}\
	\x07\x73\x02\x02\u{288}\u{28a}\x05\u{d8}\x6d\x02\u{289}\u{287}\x03\x02\x02\
	\x02\u{289}\u{28a}\x03\x02\x02\x02\u{28a}\u{40a}\x03\x02\x02\x02\u{28b}\
	\u{28c}\x07\x68\x02\x02\u{28c}\u{28d}\x05\u{d6}\x6c\x02\u{28d}\u{28e}\x07\
	\u{fc}\x02\x02\u{28e}\u{293}\x05\u{d4}\x6b\x02\u{28f}\u{290}\x07\x2c\x02\
	\x02\u{290}\u{292}\x05\u{d4}\x6b\x02\u{291}\u{28f}\x03\x02\x02\x02\u{292}\
	\u{295}\x03\x02\x02\x02\u{293}\u{291}\x03\x02\x02\x02\u{293}\u{294}\x03\
	\x02\x02\x02\u{294}\u{299}\x03\x02\x02\x02\u{295}\u{293}\x03\x02\x02\x02\
	\u{296}\u{297}\x07\u{11d}\x02\x02\u{297}\u{298}\x07\x15\x02\x02\u{298}\u{29a}\
	\x07\u{b4}\x02\x02\u{299}\u{296}\x03\x02\x02\x02\u{299}\u{29a}\x03\x02\x02\
	\x02\u{29a}\u{29e}\x03\x02\x02\x02\u{29b}\u{29c}\x07\x69\x02\x02\u{29c}\
	\u{29d}\x07\x24\x02\x02\u{29d}\u{29f}\x05\u{d2}\x6a\x02\u{29e}\u{29b}\x03\
	\x02\x02\x02\u{29e}\u{29f}\x03\x02\x02\x02\u{29f}\u{2a2}\x03\x02\x02\x02\
	\u{2a0}\u{2a1}\x07\x73\x02\x02\u{2a1}\u{2a3}\x05\u{d8}\x6d\x02\u{2a2}\u{2a0}\
	\x03\x02\x02\x02\u{2a2}\u{2a3}\x03\x02\x02\x02\u{2a3}\u{40a}\x03\x02\x02\
	\x02\u{2a4}\u{2a8}\x07\u{d8}\x02\x02\u{2a5}\u{2a6}\x07\x15\x02\x02\u{2a6}\
	\u{2a7}\x07\u{b4}\x02\x02\u{2a7}\u{2a9}\x07\x62\x02\x02\u{2a8}\u{2a5}\x03\
	\x02\x02\x02\u{2a8}\u{2a9}\x03\x02\x02\x02\u{2a9}\u{2aa}\x03\x02\x02\x02\
	\u{2aa}\u{2ab}\x05\u{d6}\x6c\x02\u{2ab}\u{2ac}\x07\x64\x02\x02\u{2ac}\u{2b1}\
	\x05\u{d4}\x6b\x02\u{2ad}\u{2ae}\x07\x2c\x02\x02\u{2ae}\u{2b0}\x05\u{d4}\
	\x6b\x02\u{2af}\u{2ad}\x03\x02\x02\x02\u{2b0}\u{2b3}\x03\x02\x02\x02\u{2b1}\
	\u{2af}\x03\x02\x02\x02\u{2b1}\u{2b2}\x03\x02\x02\x02\u{2b2}\u{2b7}\x03\
	\x02\x02\x02\u{2b3}\u{2b1}\x03\x02\x02\x02\u{2b4}\u{2b5}\x07\x69\x02\x02\
	\u{2b5}\u{2b6}\x07\x24\x02\x02\u{2b6}\u{2b8}\x05\u{d2}\x6a\x02\u{2b7}\u{2b4}\
	\x03\x02\x02\x02\u{2b7}\u{2b8}\x03\x02\x02\x02\u{2b8}\u{2bb}\x03\x02\x02\
	\x02\u{2b9}\u{2ba}\x07\x73\x02\x02\u{2ba}\u{2bc}\x05\u{d8}\x6d\x02\u{2bb}\
	\u{2b9}\x03\x02\x02\x02\u{2bb}\u{2bc}\x03\x02\x02\x02\u{2bc}\u{40a}\x03\
	\x02\x02\x02\u{2bd}\u{2be}\x07\u{ea}\x02\x02\u{2be}\u{2c2}\x07\u{da}\x02\
	\x02\u{2bf}\u{2c3}\x07\x17\x02\x02\u{2c0}\u{2c3}\x07\u{a7}\x02\x02\u{2c1}\
	\u{2c3}\x05\u{d8}\x6d\x02\u{2c2}\u{2bf}\x03\x02\x02\x02\u{2c2}\u{2c0}\x03\
	\x02\x02\x02\u{2c2}\u{2c1}\x03\x02\x02\x02\u{2c3}\u{2c6}\x03\x02\x02\x02\
	\u{2c4}\u{2c5}\x07\x73\x02\x02\u{2c5}\u{2c7}\x05\u{d8}\x6d\x02\u{2c6}\u{2c4}\
	\x03\x02\x02\x02\u{2c6}\u{2c7}\x03\x02\x02\x02\u{2c7}\u{40a}\x03\x02\x02\
	\x02\u{2c8}\u{2d3}\x07\x68\x02\x02\u{2c9}\u{2ce}\x05\u{ca}\x66\x02\u{2ca}\
	\u{2cb}\x07\x2c\x02\x02\u{2cb}\u{2cd}\x05\u{ca}\x66\x02\u{2cc}\u{2ca}\x03\
	\x02\x02\x02\u{2cd}\u{2d0}\x03\x02\x02\x02\u{2ce}\u{2cc}\x03\x02\x02\x02\
	\u{2ce}\u{2cf}\x03\x02\x02\x02\u{2cf}\u{2d4}\x03\x02\x02\x02\u{2d0}\u{2ce}\
	\x03\x02\x02\x02\u{2d1}\u{2d2}\x07\x17\x02\x02\u{2d2}\u{2d4}\x07\u{c9}\x02\
	\x02\u{2d3}\u{2c9}\x03\x02\x02\x02\u{2d3}\u{2d1}\x03\x02\x02\x02\u{2d4}\
	\u{2d5}\x03\x02\x02\x02\u{2d5}\u{2d7}\x07\u{b1}\x02\x02\u{2d6}\u{2d8}\x09\
	\x04\x02\x02\u{2d7}\u{2d6}\x03\x02\x02\x02\u{2d7}\u{2d8}\x03\x02\x02\x02\
	\u{2d8}\u{2d9}\x03\x02\x02\x02\u{2d9}\u{2da}\x05\u{cc}\x67\x02\u{2da}\u{2db}\
	\x07\u{fc}\x02\x02\u{2db}\u{2df}\x05\u{d4}\x6b\x02\u{2dc}\u{2dd}\x07\u{11d}\
	\x02\x02\u{2dd}\u{2de}\x07\x68\x02\x02\u{2de}\u{2e0}\x07\u{b4}\x02\x02\u{2df}\
	\u{2dc}\x03\x02\x02\x02\u{2df}\u{2e0}\x03\x02\x02\x02\u{2e0}\u{40a}\x03\
	\x02\x02\x02\u{2e1}\u{2ec}\x07\x48\x02\x02\u{2e2}\u{2e7}\x05\u{ca}\x66\x02\
	\u{2e3}\u{2e4}\x07\x2c\x02\x02\u{2e4}\u{2e6}\x05\u{ca}\x66\x02\u{2e5}\u{2e3}\
	\x03\x02\x02\x02\u{2e6}\u{2e9}\x03\x02\x02\x02\u{2e7}\u{2e5}\x03\x02\x02\
	\x02\u{2e7}\u{2e8}\x03\x02\x02\x02\u{2e8}\u{2ed}\x03\x02\x02\x02\u{2e9}\
	\u{2e7}\x03\x02\x02\x02\u{2ea}\u{2eb}\x07\x17\x02\x02\u{2eb}\u{2ed}\x07\
	\u{c9}\x02\x02\u{2ec}\u{2e2}\x03\x02\x02\x02\u{2ec}\u{2ea}\x03\x02\x02\x02\
	\u{2ed}\u{2ee}\x03\x02\x02\x02\u{2ee}\u{2f0}\x07\u{b1}\x02\x02\u{2ef}\u{2f1}\
	\x09\x04\x02\x02\u{2f0}\u{2ef}\x03\x02\x02\x02\u{2f0}\u{2f1}\x03\x02\x02\
	\x02\u{2f1}\u{2f2}\x03\x02\x02\x02\u{2f2}\u{2f3}\x05\u{cc}\x67\x02\u{2f3}\
	\u{2f4}\x07\u{fc}\x02\x02\u{2f4}\u{2f5}\x05\u{d4}\x6b\x02\u{2f5}\u{40a}\
	\x03\x02\x02\x02\u{2f6}\u{2fa}\x07\u{d8}\x02\x02\u{2f7}\u{2f8}\x07\x68\x02\
	\x02\u{2f8}\u{2f9}\x07\u{b4}\x02\x02\u{2f9}\u{2fb}\x07\x62\x02\x02\u{2fa}\
	\u{2f7}\x03\x02\x02\x02\u{2fa}\u{2fb}\x03\x02\x02\x02\u{2fb}\u{306}\x03\
	\x02\x02\x02\u{2fc}\u{301}\x05\u{ca}\x66\x02\u{2fd}\u{2fe}\x07\x2c\x02\x02\
	\u{2fe}\u{300}\x05\u{ca}\x66\x02\u{2ff}\u{2fd}\x03\x02\x02\x02\u{300}\u{303}\
	\x03\x02\x02\x02\u{301}\u{2ff}\x03\x02\x02\x02\u{301}\u{302}\x03\x02\x02\
	\x02\u{302}\u{307}\x03\x02\x02\x02\u{303}\u{301}\x03\x02\x02\x02\u{304}\
	\u{305}\x07\x17\x02\x02\u{305}\u{307}\x07\u{c9}\x02\x02\u{306}\u{2fc}\x03\
	\x02\x02\x02\u{306}\u{304}\x03\x02\x02\x02\u{307}\u{308}\x03\x02\x02\x02\
	\u{308}\u{30a}\x07\u{b1}\x02\x02\u{309}\u{30b}\x09\x04\x02\x02\u{30a}\u{309}\
	\x03\x02\x02\x02\u{30a}\u{30b}\x03\x02\x02\x02\u{30b}\u{30c}\x03\x02\x02\
	\x02\u{30c}\u{30d}\x05\u{cc}\x67\x02\u{30d}\u{30e}\x07\x64\x02\x02\u{30e}\
	\u{30f}\x05\u{d4}\x6b\x02\u{30f}\u{40a}\x03\x02\x02\x02\u{310}\u{311}\x07\
	\u{ec}\x02\x02\u{311}\u{317}\x07\x6a\x02\x02\u{312}\u{314}\x07\u{b1}\x02\
	\x02\u{313}\u{315}\x07\u{f3}\x02\x02\u{314}\u{313}\x03\x02\x02\x02\u{314}\
	\u{315}\x03\x02\x02\x02\u{315}\u{316}\x03\x02\x02\x02\u{316}\u{318}\x05\
	\u{cc}\x67\x02\u{317}\u{312}\x03\x02\x02\x02\u{317}\u{318}\x03\x02\x02\x02\
	\u{318}\u{40a}\x03\x02\x02\x02\u{319}\u{325}\x07\x5a\x02\x02\u{31a}\u{31b}\
	\x07\x04\x02\x02\u{31b}\u{320}\x05\u{be}\x60\x02\u{31c}\u{31d}\x07\x2c\x02\
	\x02\u{31d}\u{31f}\x05\u{be}\x60\x02\u{31e}\u{31c}\x03\x02\x02\x02\u{31f}\
	\u{322}\x03\x02\x02\x02\u{320}\u{31e}\x03\x02\x02\x02\u{320}\u{321}\x03\
	\x02\x02\x02\u{321}\u{323}\x03\x02\x02\x02\u{322}\u{320}\x03\x02\x02\x02\
	\u{323}\u{324}\x07\x05\x02\x02\u{324}\u{326}\x03\x02\x02\x02\u{325}\u{31a}\
	\x03\x02\x02\x02\u{325}\u{326}\x03\x02\x02\x02\u{326}\u{327}\x03\x02\x02\
	\x02\u{327}\u{40a}\x05\x0c\x07\x02\u{328}\u{329}\x07\x5a\x02\x02\u{329}\
	\u{32b}\x07\x19\x02\x02\u{32a}\u{32c}\x07\u{117}\x02\x02\u{32b}\u{32a}\x03\
	\x02\x02\x02\u{32b}\u{32c}\x03\x02\x02\x02\u{32c}\u{32d}\x03\x02\x02\x02\
	\u{32d}\u{40a}\x05\x0c\x07\x02\u{32e}\u{32f}\x07\u{ec}\x02\x02\u{32f}\u{330}\
	\x07\x34\x02\x02\u{330}\u{331}\x07\u{f3}\x02\x02\u{331}\u{40a}\x05\u{cc}\
	\x67\x02\u{332}\u{333}\x07\u{ec}\x02\x02\u{333}\u{334}\x07\x34\x02\x02\u{334}\
	\u{335}\x07\u{e2}\x02\x02\u{335}\u{40a}\x05\u{cc}\x67\x02\u{336}\u{337}\
	\x07\u{ec}\x02\x02\u{337}\u{338}\x07\x34\x02\x02\u{338}\u{339}\x07\u{119}\
	\x02\x02\u{339}\u{40a}\x05\u{cc}\x67\x02\u{33a}\u{33b}\x07\u{ec}\x02\x02\
	\u{33b}\u{33c}\x07\x34\x02\x02\u{33c}\u{33d}\x07\u{9b}\x02\x02\u{33d}\u{33e}\
	\x07\u{119}\x02\x02\u{33e}\u{40a}\x05\u{cc}\x67\x02\u{33f}\u{340}\x07\u{ec}\
	\x02\x02\u{340}\u{343}\x07\u{f4}\x02\x02\u{341}\u{342}\x09\x05\x02\x02\u{342}\
	\u{344}\x05\u{cc}\x67\x02\u{343}\u{341}\x03\x02\x02\x02\u{343}\u{344}\x03\
	\x02\x02\x02\u{344}\u{34b}\x03\x02\x02\x02\u{345}\u{346}\x07\u{8f}\x02\x02\
	\u{346}\u{349}\x05\u{92}\x4a\x02\u{347}\u{348}\x07\x55\x02\x02\u{348}\u{34a}\
	\x05\u{92}\x4a\x02\u{349}\u{347}\x03\x02\x02\x02\u{349}\u{34a}\x03\x02\x02\
	\x02\u{34a}\u{34c}\x03\x02\x02\x02\u{34b}\u{345}\x03\x02\x02\x02\u{34b}\
	\u{34c}\x03\x02\x02\x02\u{34c}\u{40a}\x03\x02\x02\x02\u{34d}\u{34e}\x07\
	\u{ec}\x02\x02\u{34e}\u{351}\x07\u{e3}\x02\x02\u{34f}\u{350}\x09\x05\x02\
	\x02\u{350}\u{352}\x05\u{d8}\x6d\x02\u{351}\u{34f}\x03\x02\x02\x02\u{351}\
	\u{352}\x03\x02\x02\x02\u{352}\u{359}\x03\x02\x02\x02\u{353}\u{354}\x07\
	\u{8f}\x02\x02\u{354}\u{357}\x05\u{92}\x4a\x02\u{355}\u{356}\x07\x55\x02\
	\x02\u{356}\u{358}\x05\u{92}\x4a\x02\u{357}\u{355}\x03\x02\x02\x02\u{357}\
	\u{358}\x03\x02\x02\x02\u{358}\u{35a}\x03\x02\x02\x02\u{359}\u{353}\x03\
	\x02\x02\x02\u{359}\u{35a}\x03\x02\x02\x02\u{35a}\u{40a}\x03\x02\x02\x02\
	\u{35b}\u{35c}\x07\u{ec}\x02\x02\u{35c}\u{363}\x07\x29\x02\x02\u{35d}\u{35e}\
	\x07\u{8f}\x02\x02\u{35e}\u{361}\x05\u{92}\x4a\x02\u{35f}\u{360}\x07\x55\
	\x02\x02\u{360}\u{362}\x05\u{92}\x4a\x02\u{361}\u{35f}\x03\x02\x02\x02\u{361}\
	\u{362}\x03\x02\x02\x02\u{362}\u{364}\x03\x02\x02\x02\u{363}\u{35d}\x03\
	\x02\x02\x02\u{363}\u{364}\x03\x02\x02\x02\u{364}\u{40a}\x03\x02\x02\x02\
	\u{365}\u{366}\x07\u{ec}\x02\x02\u{366}\u{367}\x07\x2b\x02\x02\u{367}\u{369}\
	\x09\x05\x02\x02\u{368}\u{36a}\x05\u{cc}\x67\x02\u{369}\u{368}\x03\x02\x02\
	\x02\u{369}\u{36a}\x03\x02\x02\x02\u{36a}\u{371}\x03\x02\x02\x02\u{36b}\
	\u{36c}\x07\u{8f}\x02\x02\u{36c}\u{36f}\x05\u{92}\x4a\x02\u{36d}\u{36e}\
	\x07\x55\x02\x02\u{36e}\u{370}\x05\u{92}\x4a\x02\u{36f}\u{36d}\x03\x02\x02\
	\x02\u{36f}\u{370}\x03\x02\x02\x02\u{370}\u{372}\x03\x02\x02\x02\u{371}\
	\u{36b}\x03\x02\x02\x02\u{371}\u{372}\x03\x02\x02\x02\u{372}\u{40a}\x03\
	\x02\x02\x02\u{373}\u{374}\x07\u{ec}\x02\x02\u{374}\u{375}\x07\u{ef}\x02\
	\x02\u{375}\u{376}\x07\x62\x02\x02\u{376}\u{40a}\x05\u{cc}\x67\x02\u{377}\
	\u{378}\x07\u{ec}\x02\x02\u{378}\u{379}\x07\u{ef}\x02\x02\u{379}\u{37a}\
	\x07\x62\x02\x02\u{37a}\u{37b}\x07\x04\x02\x02\u{37b}\u{37c}\x05\x0e\x08\
	\x02\u{37c}\u{37d}\x07\x05\x02\x02\u{37d}\u{40a}\x03\x02\x02\x02\u{37e}\
	\u{380}\x07\u{ec}\x02\x02\u{37f}\u{381}\x07\x37\x02\x02\u{380}\u{37f}\x03\
	\x02\x02\x02\u{380}\u{381}\x03\x02\x02\x02\u{381}\u{382}\x03\x02\x02\x02\
	\u{382}\u{385}\x07\u{db}\x02\x02\u{383}\u{384}\x09\x05\x02\x02\u{384}\u{386}\
	\x05\u{d8}\x6d\x02\u{385}\u{383}\x03\x02\x02\x02\u{385}\u{386}\x03\x02\x02\
	\x02\u{386}\u{40a}\x03\x02\x02\x02\u{387}\u{388}\x07\u{ec}\x02\x02\u{388}\
	\u{389}\x07\u{da}\x02\x02\u{389}\u{38c}\x07\x6a\x02\x02\u{38a}\u{38b}\x09\
	\x05\x02\x02\u{38b}\u{38d}\x05\u{d8}\x6d\x02\u{38c}\u{38a}\x03\x02\x02\x02\
	\u{38c}\u{38d}\x03\x02\x02\x02\u{38d}\u{40a}\x03\x02\x02\x02\u{38e}\u{38f}\
	\x07\x4a\x02\x02\u{38f}\u{40a}\x05\u{cc}\x67\x02\u{390}\u{391}\x07\x49\x02\
	\x02\u{391}\u{40a}\x05\u{cc}\x67\x02\u{392}\u{393}\x07\u{ec}\x02\x02\u{393}\
	\u{39a}\x07\x66\x02\x02\u{394}\u{395}\x07\u{8f}\x02\x02\u{395}\u{398}\x05\
	\u{92}\x4a\x02\u{396}\u{397}\x07\x55\x02\x02\u{397}\u{399}\x05\u{92}\x4a\
	\x02\u{398}\u{396}\x03\x02\x02\x02\u{398}\u{399}\x03\x02\x02\x02\u{399}\
	\u{39b}\x03\x02\x02\x02\u{39a}\u{394}\x03\x02\x02\x02\u{39a}\u{39b}\x03\
	\x02\x02\x02\u{39b}\u{40a}\x03\x02\x02\x02\u{39c}\u{39d}\x07\u{ec}\x02\x02\
	\u{39d}\u{3a4}\x07\u{e9}\x02\x02\u{39e}\u{39f}\x07\u{8f}\x02\x02\u{39f}\
	\u{3a2}\x05\u{92}\x4a\x02\u{3a0}\u{3a1}\x07\x55\x02\x02\u{3a1}\u{3a3}\x05\
	\u{92}\x4a\x02\u{3a2}\u{3a0}\x03\x02\x02\x02\u{3a2}\u{3a3}\x03\x02\x02\x02\
	\u{3a3}\u{3a5}\x03\x02\x02\x02\u{3a4}\u{39e}\x03\x02\x02\x02\u{3a4}\u{3a5}\
	\x03\x02\x02\x02\u{3a5}\u{40a}\x03\x02\x02\x02\u{3a6}\u{3a7}\x07\u{ea}\x02\
	\x02\u{3a7}\u{3a8}\x07\u{e9}\x02\x02\u{3a8}\u{3a9}\x05\u{cc}\x67\x02\u{3a9}\
	\u{3aa}\x07\u{125}\x02\x02\u{3aa}\u{3ab}\x05\x72\x3a\x02\u{3ab}\u{40a}\x03\
	\x02\x02\x02\u{3ac}\u{3ad}\x07\u{d4}\x02\x02\u{3ad}\u{3ae}\x07\u{e9}\x02\
	\x02\u{3ae}\u{40a}\x05\u{cc}\x67\x02\u{3af}\u{3b0}\x07\u{ee}\x02\x02\u{3b0}\
	\u{3b9}\x07\u{fe}\x02\x02\u{3b1}\u{3b6}\x05\u{c0}\x61\x02\u{3b2}\u{3b3}\
	\x07\x2c\x02\x02\u{3b3}\u{3b5}\x05\u{c0}\x61\x02\u{3b4}\u{3b2}\x03\x02\x02\
	\x02\u{3b5}\u{3b8}\x03\x02\x02\x02\u{3b6}\u{3b4}\x03\x02\x02\x02\u{3b6}\
	\u{3b7}\x03\x02\x02\x02\u{3b7}\u{3ba}\x03\x02\x02\x02\u{3b8}\u{3b6}\x03\
	\x02\x02\x02\u{3b9}\u{3b1}\x03\x02\x02\x02\u{3b9}\u{3ba}\x03\x02\x02\x02\
	\u{3ba}\u{40a}\x03\x02\x02\x02\u{3bb}\u{3bd}\x07\x2e\x02\x02\u{3bc}\u{3be}\
	\x07\u{120}\x02\x02\u{3bd}\u{3bc}\x03\x02\x02\x02\u{3bd}\u{3be}\x03\x02\
	\x02\x02\u{3be}\u{40a}\x03\x02\x02\x02\u{3bf}\u{3c1}\x07\u{dc}\x02\x02\u{3c0}\
	\u{3c2}\x07\u{120}\x02\x02\u{3c1}\u{3c0}\x03\x02\x02\x02\u{3c1}\u{3c2}\x03\
	\x02\x02\x02\u{3c2}\u{40a}\x03\x02\x02\x02\u{3c3}\u{3c4}\x07\u{c8}\x02\x02\
	\u{3c4}\u{3c5}\x05\u{d8}\x6d\x02\u{3c5}\u{3c6}\x07\x64\x02\x02\u{3c6}\u{3c7}\
	\x05\x0c\x07\x02\u{3c7}\u{40a}\x03\x02\x02\x02\u{3c8}\u{3c9}\x07\x43\x02\
	\x02\u{3c9}\u{3ca}\x07\u{c8}\x02\x02\u{3ca}\u{40a}\x05\u{d8}\x6d\x02\u{3cb}\
	\u{3cc}\x07\x58\x02\x02\u{3cc}\u{3d6}\x05\u{d8}\x6d\x02\u{3cd}\u{3ce}\x07\
	\u{110}\x02\x02\u{3ce}\u{3d3}\x05\x72\x3a\x02\u{3cf}\u{3d0}\x07\x2c\x02\
	\x02\u{3d0}\u{3d2}\x05\x72\x3a\x02\u{3d1}\u{3cf}\x03\x02\x02\x02\u{3d2}\
	\u{3d5}\x03\x02\x02\x02\u{3d3}\u{3d1}\x03\x02\x02\x02\u{3d3}\u{3d4}\x03\
	\x02\x02\x02\u{3d4}\u{3d7}\x03\x02\x02\x02\u{3d5}\u{3d3}\x03\x02\x02\x02\
	\u{3d6}\u{3cd}\x03\x02\x02\x02\u{3d6}\u{3d7}\x03\x02\x02\x02\u{3d7}\u{40a}\
	\x03\x02\x02\x02\u{3d8}\u{3d9}\x07\x4a\x02\x02\u{3d9}\u{3da}\x07\x77\x02\
	\x02\u{3da}\u{40a}\x05\u{d8}\x6d\x02\u{3db}\u{3dc}\x07\x4a\x02\x02\u{3dc}\
	\u{3dd}\x07\u{b9}\x02\x02\u{3dd}\u{40a}\x05\u{d8}\x6d\x02\u{3de}\u{3df}\
	\x07\u{ea}\x02\x02\u{3df}\u{3e0}\x07\u{c0}\x02\x02\u{3e0}\u{40a}\x05\u{c8}\
	\x65\x02\u{3e1}\u{3e2}\x07\u{ea}\x02\x02\u{3e2}\u{3e3}\x07\u{fa}\x02\x02\
	\u{3e3}\u{3e6}\x07\u{124}\x02\x02\u{3e4}\u{3e7}\x07\u{92}\x02\x02\u{3e5}\
	\u{3e7}\x05\x72\x3a\x02\u{3e6}\u{3e4}\x03\x02\x02\x02\u{3e6}\u{3e5}\x03\
	\x02\x02\x02\u{3e7}\u{40a}\x03\x02\x02\x02\u{3e8}\u{3e9}\x07\u{10d}\x02\
	\x02\u{3e9}\u{3ea}\x05\u{cc}\x67\x02\u{3ea}\u{3eb}\x07\u{ea}\x02\x02\u{3eb}\
	\u{3f0}\x05\u{bc}\x5f\x02\u{3ec}\u{3ed}\x07\x2c\x02\x02\u{3ed}\u{3ef}\x05\
	\u{bc}\x5f\x02\u{3ee}\u{3ec}\x03\x02\x02\x02\u{3ef}\u{3f2}\x03\x02\x02\x02\
	\u{3f0}\u{3ee}\x03\x02\x02\x02\u{3f0}\u{3f1}\x03\x02\x02\x02\u{3f1}\u{3f5}\
	\x03\x02\x02\x02\u{3f2}\u{3f0}\x03\x02\x02\x02\u{3f3}\u{3f4}\x07\u{11b}\
	\x02\x02\u{3f4}\u{3f6}\x05\x74\x3b\x02\u{3f5}\u{3f3}\x03\x02\x02\x02\u{3f5}\
	\u{3f6}\x03\x02\x02\x02\u{3f6}\u{40a}\x03\x02\x02\x02\u{3f7}\u{3f8}\x07\
	\u{9d}\x02\x02\u{3f8}\u{3f9}\x07\x7b\x02\x02\u{3f9}\u{3fe}\x05\u{cc}\x67\
	\x02\u{3fa}\u{3fc}\x07\x1d\x02\x02\u{3fb}\u{3fa}\x03\x02\x02\x02\u{3fb}\
	\u{3fc}\x03\x02\x02\x02\u{3fc}\u{3fd}\x03\x02\x02\x02\u{3fd}\u{3ff}\x05\
	\u{d8}\x6d\x02\u{3fe}\u{3fb}\x03\x02\x02\x02\u{3fe}\u{3ff}\x03\x02\x02\x02\
	\u{3ff}\u{400}\x03\x02\x02\x02\u{400}\u{401}\x07\u{110}\x02\x02\u{401}\u{402}\
	\x05\x40\x21\x02\u{402}\u{403}\x07\u{b1}\x02\x02\u{403}\u{405}\x05\x72\x3a\
	\x02\u{404}\u{406}\x05\u{ac}\x57\x02\u{405}\u{404}\x03\x02\x02\x02\u{406}\
	\u{407}\x03\x02\x02\x02\u{407}\u{405}\x03\x02\x02\x02\u{407}\u{408}\x03\
	\x02\x02\x02\u{408}\u{40a}\x03\x02\x02\x02\u{409}\u{ed}\x03\x02\x02\x02\
	\u{409}\u{ee}\x03\x02\x02\x02\u{409}\u{f0}\x03\x02\x02\x02\u{409}\u{f5}\
	\x03\x02\x02\x02\u{409}\u{105}\x03\x02\x02\x02\u{409}\u{10f}\x03\x02\x02\
	\x02\u{409}\u{116}\x03\x02\x02\x02\u{409}\u{11d}\x03\x02\x02\x02\u{409}\
	\u{13f}\x03\x02\x02\x02\u{409}\u{15c}\x03\x02\x02\x02\u{409}\u{163}\x03\
	\x02\x02\x02\u{409}\u{16b}\x03\x02\x02\x02\u{409}\u{172}\x03\x02\x02\x02\
	\u{409}\u{175}\x03\x02\x02\x02\u{409}\u{17e}\x03\x02\x02\x02\u{409}\u{187}\
	\x03\x02\x02\x02\u{409}\u{190}\x03\x02\x02\x02\u{409}\u{19b}\x03\x02\x02\
	\x02\u{409}\u{1ab}\x03\x02\x02\x02\u{409}\u{1bc}\x03\x02\x02\x02\u{409}\
	\u{1cb}\x03\x02\x02\x02\u{409}\u{1da}\x03\x02\x02\x02\u{409}\u{1e1}\x03\
	\x02\x02\x02\u{409}\u{1e8}\x03\x02\x02\x02\u{409}\u{1ff}\x03\x02\x02\x02\
	\u{409}\u{205}\x03\x02\x02\x02\u{409}\u{222}\x03\x02\x02\x02\u{409}\u{234}\
	\x03\x02\x02\x02\u{409}\u{238}\x03\x02\x02\x02\u{409}\u{240}\x03\x02\x02\
	\x02\u{409}\u{24c}\x03\x02\x02\x02\u{409}\u{254}\x03\x02\x02\x02\u{409}\
	\u{25b}\x03\x02\x02\x02\u{409}\u{262}\x03\x02\x02\x02\u{409}\u{269}\x03\
	\x02\x02\x02\u{409}\u{278}\x03\x02\x02\x02\u{409}\u{284}\x03\x02\x02\x02\
	\u{409}\u{28b}\x03\x02\x02\x02\u{409}\u{2a4}\x03\x02\x02\x02\u{409}\u{2bd}\
	\x03\x02\x02\x02\u{409}\u{2c8}\x03\x02\x02\x02\u{409}\u{2e1}\x03\x02\x02\
	\x02\u{409}\u{2f6}\x03\x02\x02\x02\u{409}\u{310}\x03\x02\x02\x02\u{409}\
	\u{319}\x03\x02\x02\x02\u{409}\u{328}\x03\x02\x02\x02\u{409}\u{32e}\x03\
	\x02\x02\x02\u{409}\u{332}\x03\x02\x02\x02\u{409}\u{336}\x03\x02\x02\x02\
	\u{409}\u{33a}\x03\x02\x02\x02\u{409}\u{33f}\x03\x02\x02\x02\u{409}\u{34d}\
	\x03\x02\x02\x02\u{409}\u{35b}\x03\x02\x02\x02\u{409}\u{365}\x03\x02\x02\
	\x02\u{409}\u{373}\x03\x02\x02\x02\u{409}\u{377}\x03\x02\x02\x02\u{409}\
	\u{37e}\x03\x02\x02\x02\u{409}\u{387}\x03\x02\x02\x02\u{409}\u{38e}\x03\
	\x02\x02\x02\u{409}\u{390}\x03\x02\x02\x02\u{409}\u{392}\x03\x02\x02\x02\
	\u{409}\u{39c}\x03\x02\x02\x02\u{409}\u{3a6}\x03\x02\x02\x02\u{409}\u{3ac}\
	\x03\x02\x02\x02\u{409}\u{3af}\x03\x02\x02\x02\u{409}\u{3bb}\x03\x02\x02\
	\x02\u{409}\u{3bf}\x03\x02\x02\x02\u{409}\u{3c3}\x03\x02\x02\x02\u{409}\
	\u{3c8}\x03\x02\x02\x02\u{409}\u{3cb}\x03\x02\x02\x02\u{409}\u{3d8}\x03\
	\x02\x02\x02\u{409}\u{3db}\x03\x02\x02\x02\u{409}\u{3de}\x03\x02\x02\x02\
	\u{409}\u{3e1}\x03\x02\x02\x02\u{409}\u{3e8}\x03\x02\x02\x02\u{409}\u{3f7}\
	\x03\x02\x02\x02\u{40a}\x0d\x03\x02\x02\x02\u{40b}\u{40d}\x05\x10\x09\x02\
	\u{40c}\u{40b}\x03\x02\x02\x02\u{40c}\u{40d}\x03\x02\x02\x02\u{40d}\u{40e}\
	\x03\x02\x02\x02\u{40e}\u{40f}\x05\x20\x11\x02\u{40f}\x0f\x03\x02\x02\x02\
	\u{410}\u{412}\x07\u{11d}\x02\x02\u{411}\u{413}\x07\u{cf}\x02\x02\u{412}\
	\u{411}\x03\x02\x02\x02\u{412}\u{413}\x03\x02\x02\x02\u{413}\u{414}\x03\
	\x02\x02\x02\u{414}\u{419}\x05\x3a\x1e\x02\u{415}\u{416}\x07\x2c\x02\x02\
	\u{416}\u{418}\x05\x3a\x1e\x02\u{417}\u{415}\x03\x02\x02\x02\u{418}\u{41b}\
	\x03\x02\x02\x02\u{419}\u{417}\x03\x02\x02\x02\u{419}\u{41a}\x03\x02\x02\
	\x02\u{41a}\x11\x03\x02\x02\x02\u{41b}\u{419}\x03\x02\x02\x02\u{41c}\u{41f}\
	\x05\x14\x0b\x02\u{41d}\u{41f}\x05\x16\x0c\x02\u{41e}\u{41c}\x03\x02\x02\
	\x02\u{41e}\u{41d}\x03\x02\x02\x02\u{41f}\x13\x03\x02\x02\x02\u{420}\u{421}\
	\x05\u{d8}\x6d\x02\u{421}\u{424}\x05\u{a2}\x52\x02\u{422}\u{423}\x07\u{a9}\
	\x02\x02\u{423}\u{425}\x07\u{aa}\x02\x02\u{424}\u{422}\x03\x02\x02\x02\u{424}\
	\u{425}\x03\x02\x02\x02\u{425}\u{428}\x03\x02\x02\x02\u{426}\u{427}\x07\
	\x2d\x02\x02\u{427}\u{429}\x05\u{92}\x4a\x02\u{428}\u{426}\x03\x02\x02\x02\
	\u{428}\u{429}\x03\x02\x02\x02\u{429}\u{42c}\x03\x02\x02\x02\u{42a}\u{42b}\
	\x07\u{11d}\x02\x02\u{42b}\u{42d}\x05\x18\x0d\x02\u{42c}\u{42a}\x03\x02\
	\x02\x02\u{42c}\u{42d}\x03\x02\x02\x02\u{42d}\x15\x03\x02\x02\x02\u{42e}\
	\u{42f}\x07\u{8f}\x02\x02\u{42f}\u{432}\x05\u{cc}\x67\x02\u{430}\u{431}\
	\x09\x06\x02\x02\u{431}\u{433}\x07\u{ca}\x02\x02\u{432}\u{430}\x03\x02\x02\
	\x02\u{432}\u{433}\x03\x02\x02\x02\u{433}\x17\x03\x02\x02\x02\u{434}\u{435}\
	\x07\x04\x02\x02\u{435}\u{436}\x05\x1a\x0e\x02\u{436}\u{437}\x07\x05\x02\
	\x02\u{437}\x19\x03\x02\x02\x02\u{438}\u{43d}\x05\x1c\x0f\x02\u{439}\u{43a}\
	\x07\x2c\x02\x02\u{43a}\u{43c}\x05\x1c\x0f\x02\u{43b}\u{439}\x03\x02\x02\
	\x02\u{43c}\u{43f}\x03\x02\x02\x02\u{43d}\u{43b}\x03\x02\x02\x02\u{43d}\
	\u{43e}\x03\x02\x02\x02\u{43e}\x1b\x03\x02\x02\x02\u{43f}\u{43d}\x03\x02\
	\x02\x02\u{440}\u{441}\x05\u{d8}\x6d\x02\u{441}\u{442}\x07\u{125}\x02\x02\
	\u{442}\u{443}\x05\x1e\x10\x02\u{443}\x1d\x03\x02\x02\x02\u{444}\u{447}\
	\x07\x44\x02\x02\u{445}\u{447}\x05\x72\x3a\x02\u{446}\u{444}\x03\x02\x02\
	\x02\u{446}\u{445}\x03\x02\x02\x02\u{447}\x1f\x03\x02\x02\x02\u{448}\u{453}\
	\x05\x26\x14\x02\u{449}\u{44a}\x07\u{b6}\x02\x02\u{44a}\u{44b}\x07\x24\x02\
	\x02\u{44b}\u{450}\x05\x2a\x16\x02\u{44c}\u{44d}\x07\x2c\x02\x02\u{44d}\
	\u{44f}\x05\x2a\x16\x02\u{44e}\u{44c}\x03\x02\x02\x02\u{44f}\u{452}\x03\
	\x02\x02\x02\u{450}\u{44e}\x03\x02\x02\x02\u{450}\u{451}\x03\x02\x02\x02\
	\u{451}\u{454}\x03\x02\x02\x02\u{452}\u{450}\x03\x02\x02\x02\u{453}\u{449}\
	\x03\x02\x02\x02\u{453}\u{454}\x03\x02\x02\x02\u{454}\u{45a}\x03\x02\x02\
	\x02\u{455}\u{456}\x07\u{af}\x02\x02\u{456}\u{458}\x05\x24\x13\x02\u{457}\
	\u{459}\x09\x07\x02\x02\u{458}\u{457}\x03\x02\x02\x02\u{458}\u{459}\x03\
	\x02\x02\x02\u{459}\u{45b}\x03\x02\x02\x02\u{45a}\u{455}\x03\x02\x02\x02\
	\u{45a}\u{45b}\x03\x02\x02\x02\u{45b}\u{469}\x03\x02\x02\x02\u{45c}\u{45d}\
	\x07\u{90}\x02\x02\u{45d}\u{46a}\x05\x22\x12\x02\u{45e}\u{45f}\x07\x5d\x02\
	\x02\u{45f}\u{461}\x09\x08\x02\x02\u{460}\u{462}\x05\x24\x13\x02\u{461}\
	\u{460}\x03\x02\x02\x02\u{461}\u{462}\x03\x02\x02\x02\u{462}\u{463}\x03\
	\x02\x02\x02\u{463}\u{467}\x09\x07\x02\x02\u{464}\u{468}\x07\u{b3}\x02\x02\
	\u{465}\u{466}\x07\u{11d}\x02\x02\u{466}\u{468}\x07\u{f9}\x02\x02\u{467}\
	\u{464}\x03\x02\x02\x02\u{467}\u{465}\x03\x02\x02\x02\u{468}\u{46a}\x03\
	\x02\x02\x02\u{469}\u{45c}\x03\x02\x02\x02\u{469}\u{45e}\x03\x02\x02\x02\
	\u{469}\u{46a}\x03\x02\x02\x02\u{46a}\x21\x03\x02\x02\x02\u{46b}\u{46e}\
	\x07\x17\x02\x02\u{46c}\u{46e}\x05\x24\x13\x02\u{46d}\u{46b}\x03\x02\x02\
	\x02\u{46d}\u{46c}\x03\x02\x02\x02\u{46e}\x23\x03\x02\x02\x02\u{46f}\u{470}\
	\x09\x09\x02\x02\u{470}\x25\x03\x02\x02\x02\u{471}\u{472}\x08\x14\x01\x02\
	\u{472}\u{473}\x05\x28\x15\x02\u{473}\u{482}\x03\x02\x02\x02\u{474}\u{475}\
	\x0c\x04\x02\x02\u{475}\u{477}\x07\x79\x02\x02\u{476}\u{478}\x05\x3c\x1f\
	\x02\u{477}\u{476}\x03\x02\x02\x02\u{477}\u{478}\x03\x02\x02\x02\u{478}\
	\u{479}\x03\x02\x02\x02\u{479}\u{481}\x05\x26\x14\x05\u{47a}\u{47b}\x0c\
	\x03\x02\x02\u{47b}\u{47d}\x09\x0a\x02\x02\u{47c}\u{47e}\x05\x3c\x1f\x02\
	\u{47d}\u{47c}\x03\x02\x02\x02\u{47d}\u{47e}\x03\x02\x02\x02\u{47e}\u{47f}\
	\x03\x02\x02\x02\u{47f}\u{481}\x05\x26\x14\x04\u{480}\u{474}\x03\x02\x02\
	\x02\u{480}\u{47a}\x03\x02\x02\x02\u{481}\u{484}\x03\x02\x02\x02\u{482}\
	\u{480}\x03\x02\x02\x02\u{482}\u{483}\x03\x02\x02\x02\u{483}\x27\x03\x02\
	\x02\x02\u{484}\u{482}\x03\x02\x02\x02\u{485}\u{496}\x05\x2c\x17\x02\u{486}\
	\u{487}\x07\u{f3}\x02\x02\u{487}\u{496}\x05\u{cc}\x67\x02\u{488}\u{489}\
	\x07\u{116}\x02\x02\u{489}\u{48e}\x05\x72\x3a\x02\u{48a}\u{48b}\x07\x2c\
	\x02\x02\u{48b}\u{48d}\x05\x72\x3a\x02\u{48c}\u{48a}\x03\x02\x02\x02\u{48d}\
	\u{490}\x03\x02\x02\x02\u{48e}\u{48c}\x03\x02\x02\x02\u{48e}\u{48f}\x03\
	\x02\x02\x02\u{48f}\u{496}\x03\x02\x02\x02\u{490}\u{48e}\x03\x02\x02\x02\
	\u{491}\u{492}\x07\x04\x02\x02\u{492}\u{493}\x05\x20\x11\x02\u{493}\u{494}\
	\x07\x05\x02\x02\u{494}\u{496}\x03\x02\x02\x02\u{495}\u{485}\x03\x02\x02\
	\x02\u{495}\u{486}\x03\x02\x02\x02\u{495}\u{488}\x03\x02\x02\x02\u{495}\
	\u{491}\x03\x02\x02\x02\u{496}\x29\x03\x02\x02\x02\u{497}\u{499}\x05\x72\
	\x3a\x02\u{498}\u{49a}\x09\x0b\x02\x02\u{499}\u{498}\x03\x02\x02\x02\u{499}\
	\u{49a}\x03\x02\x02\x02\u{49a}\u{49d}\x03\x02\x02\x02\u{49b}\u{49c}\x07\
	\u{ac}\x02\x02\u{49c}\u{49e}\x09\x0c\x02\x02\u{49d}\u{49b}\x03\x02\x02\x02\
	\u{49d}\u{49e}\x03\x02\x02\x02\u{49e}\x2b\x03\x02\x02\x02\u{49f}\u{4a1}\
	\x07\u{e7}\x02\x02\u{4a0}\u{4a2}\x05\x3c\x1f\x02\u{4a1}\u{4a0}\x03\x02\x02\
	\x02\u{4a1}\u{4a2}\x03\x02\x02\x02\u{4a2}\u{4a3}\x03\x02\x02\x02\u{4a3}\
	\u{4ad}\x05\x2e\x18\x02\u{4a4}\u{4a5}\x07\x64\x02\x02\u{4a5}\u{4aa}\x05\
	\x40\x21\x02\u{4a6}\u{4a7}\x07\x2c\x02\x02\u{4a7}\u{4a9}\x05\x40\x21\x02\
	\u{4a8}\u{4a6}\x03\x02\x02\x02\u{4a9}\u{4ac}\x03\x02\x02\x02\u{4aa}\u{4a8}\
	\x03\x02\x02\x02\u{4aa}\u{4ab}\x03\x02\x02\x02\u{4ab}\u{4ae}\x03\x02\x02\
	\x02\u{4ac}\u{4aa}\x03\x02\x02\x02\u{4ad}\u{4a4}\x03\x02\x02\x02\u{4ad}\
	\u{4ae}\x03\x02\x02\x02\u{4ae}\u{4b1}\x03\x02\x02\x02\u{4af}\u{4b0}\x07\
	\u{11b}\x02\x02\u{4b0}\u{4b2}\x05\x74\x3b\x02\u{4b1}\u{4af}\x03\x02\x02\
	\x02\u{4b1}\u{4b2}\x03\x02\x02\x02\u{4b2}\u{4b6}\x03\x02\x02\x02\u{4b3}\
	\u{4b4}\x07\x6c\x02\x02\u{4b4}\u{4b5}\x07\x24\x02\x02\u{4b5}\u{4b7}\x05\
	\x30\x19\x02\u{4b6}\u{4b3}\x03\x02\x02\x02\u{4b6}\u{4b7}\x03\x02\x02\x02\
	\u{4b7}\u{4ba}\x03\x02\x02\x02\u{4b8}\u{4b9}\x07\x6f\x02\x02\u{4b9}\u{4bb}\
	\x05\x74\x3b\x02\u{4ba}\u{4b8}\x03\x02\x02\x02\u{4ba}\u{4bb}\x03\x02\x02\
	\x02\u{4bb}\u{4c5}\x03\x02\x02\x02\u{4bc}\u{4bd}\x07\u{11c}\x02\x02\u{4bd}\
	\u{4c2}\x05\x36\x1c\x02\u{4be}\u{4bf}\x07\x2c\x02\x02\u{4bf}\u{4c1}\x05\
	\x36\x1c\x02\u{4c0}\u{4be}\x03\x02\x02\x02\u{4c1}\u{4c4}\x03\x02\x02\x02\
	\u{4c2}\u{4c0}\x03\x02\x02\x02\u{4c2}\u{4c3}\x03\x02\x02\x02\u{4c3}\u{4c6}\
	\x03\x02\x02\x02\u{4c4}\u{4c2}\x03\x02\x02\x02\u{4c5}\u{4bc}\x03\x02\x02\
	\x02\u{4c5}\u{4c6}\x03\x02\x02\x02\u{4c6}\x2d\x03\x02\x02\x02\u{4c7}\u{4cc}\
	\x05\x3e\x20\x02\u{4c8}\u{4c9}\x07\x2c\x02\x02\u{4c9}\u{4cb}\x05\x3e\x20\
	\x02\u{4ca}\u{4c8}\x03\x02\x02\x02\u{4cb}\u{4ce}\x03\x02\x02\x02\u{4cc}\
	\u{4ca}\x03\x02\x02\x02\u{4cc}\u{4cd}\x03\x02\x02\x02\u{4cd}\x2f\x03\x02\
	\x02\x02\u{4ce}\u{4cc}\x03\x02\x02\x02\u{4cf}\u{4d1}\x05\x3c\x1f\x02\u{4d0}\
	\u{4cf}\x03\x02\x02\x02\u{4d0}\u{4d1}\x03\x02\x02\x02\u{4d1}\u{4d2}\x03\
	\x02\x02\x02\u{4d2}\u{4d7}\x05\x32\x1a\x02\u{4d3}\u{4d4}\x07\x2c\x02\x02\
	\u{4d4}\u{4d6}\x05\x32\x1a\x02\u{4d5}\u{4d3}\x03\x02\x02\x02\u{4d6}\u{4d9}\
	\x03\x02\x02\x02\u{4d7}\u{4d5}\x03\x02\x02\x02\u{4d7}\u{4d8}\x03\x02\x02\
	\x02\u{4d8}\x31\x03\x02\x02\x02\u{4d9}\u{4d7}\x03\x02\x02\x02\u{4da}\u{503}\
	\x05\x34\x1b\x02\u{4db}\u{4dc}\x07\u{dd}\x02\x02\u{4dc}\u{4e5}\x07\x04\x02\
	\x02\u{4dd}\u{4e2}\x05\x72\x3a\x02\u{4de}\u{4df}\x07\x2c\x02\x02\u{4df}\
	\u{4e1}\x05\x72\x3a\x02\u{4e0}\u{4de}\x03\x02\x02\x02\u{4e1}\u{4e4}\x03\
	\x02\x02\x02\u{4e2}\u{4e0}\x03\x02\x02\x02\u{4e2}\u{4e3}\x03\x02\x02\x02\
	\u{4e3}\u{4e6}\x03\x02\x02\x02\u{4e4}\u{4e2}\x03\x02\x02\x02\u{4e5}\u{4dd}\
	\x03\x02\x02\x02\u{4e5}\u{4e6}\x03\x02\x02\x02\u{4e6}\u{4e7}\x03\x02\x02\
	\x02\u{4e7}\u{503}\x07\x05\x02\x02\u{4e8}\u{4e9}\x07\x36\x02\x02\u{4e9}\
	\u{4f2}\x07\x04\x02\x02\u{4ea}\u{4ef}\x05\x72\x3a\x02\u{4eb}\u{4ec}\x07\
	\x2c\x02\x02\u{4ec}\u{4ee}\x05\x72\x3a\x02\u{4ed}\u{4eb}\x03\x02\x02\x02\
	\u{4ee}\u{4f1}\x03\x02\x02\x02\u{4ef}\u{4ed}\x03\x02\x02\x02\u{4ef}\u{4f0}\
	\x03\x02\x02\x02\u{4f0}\u{4f3}\x03\x02\x02\x02\u{4f1}\u{4ef}\x03\x02\x02\
	\x02\u{4f2}\u{4ea}\x03\x02\x02\x02\u{4f2}\u{4f3}\x03\x02\x02\x02\u{4f3}\
	\u{4f4}\x03\x02\x02\x02\u{4f4}\u{503}\x07\x05\x02\x02\u{4f5}\u{4f6}\x07\
	\x6d\x02\x02\u{4f6}\u{4f7}\x07\u{eb}\x02\x02\u{4f7}\u{4f8}\x07\x04\x02\x02\
	\u{4f8}\u{4fd}\x05\x34\x1b\x02\u{4f9}\u{4fa}\x07\x2c\x02\x02\u{4fa}\u{4fc}\
	\x05\x34\x1b\x02\u{4fb}\u{4f9}\x03\x02\x02\x02\u{4fc}\u{4ff}\x03\x02\x02\
	\x02\u{4fd}\u{4fb}\x03\x02\x02\x02\u{4fd}\u{4fe}\x03\x02\x02\x02\u{4fe}\
	\u{500}\x03\x02\x02\x02\u{4ff}\u{4fd}\x03\x02\x02\x02\u{500}\u{501}\x07\
	\x05\x02\x02\u{501}\u{503}\x03\x02\x02\x02\u{502}\u{4da}\x03\x02\x02\x02\
	\u{502}\u{4db}\x03\x02\x02\x02\u{502}\u{4e8}\x03\x02\x02\x02\u{502}\u{4f5}\
	\x03\x02\x02\x02\u{503}\x33\x03\x02\x02\x02\u{504}\u{50d}\x07\x04\x02\x02\
	\u{505}\u{50a}\x05\x72\x3a\x02\u{506}\u{507}\x07\x2c\x02\x02\u{507}\u{509}\
	\x05\x72\x3a\x02\u{508}\u{506}\x03\x02\x02\x02\u{509}\u{50c}\x03\x02\x02\
	\x02\u{50a}\u{508}\x03\x02\x02\x02\u{50a}\u{50b}\x03\x02\x02\x02\u{50b}\
	\u{50e}\x03\x02\x02\x02\u{50c}\u{50a}\x03\x02\x02\x02\u{50d}\u{505}\x03\
	\x02\x02\x02\u{50d}\u{50e}\x03\x02\x02\x02\u{50e}\u{50f}\x03\x02\x02\x02\
	\u{50f}\u{512}\x07\x05\x02\x02\u{510}\u{512}\x05\x72\x3a\x02\u{511}\u{504}\
	\x03\x02\x02\x02\u{511}\u{510}\x03\x02\x02\x02\u{512}\x35\x03\x02\x02\x02\
	\u{513}\u{514}\x05\u{d8}\x6d\x02\u{514}\u{515}\x07\x1d\x02\x02\u{515}\u{516}\
	\x07\x04\x02\x02\u{516}\u{517}\x05\x38\x1d\x02\u{517}\u{518}\x07\x05\x02\
	\x02\u{518}\x37\x03\x02\x02\x02\u{519}\u{51b}\x05\u{d8}\x6d\x02\u{51a}\u{519}\
	\x03\x02\x02\x02\u{51a}\u{51b}\x03\x02\x02\x02\u{51b}\u{526}\x03\x02\x02\
	\x02\u{51c}\u{51d}\x07\u{bc}\x02\x02\u{51d}\u{51e}\x07\x24\x02\x02\u{51e}\
	\u{523}\x05\x72\x3a\x02\u{51f}\u{520}\x07\x2c\x02\x02\u{520}\u{522}\x05\
	\x72\x3a\x02\u{521}\u{51f}\x03\x02\x02\x02\u{522}\u{525}\x03\x02\x02\x02\
	\u{523}\u{521}\x03\x02\x02\x02\u{523}\u{524}\x03\x02\x02\x02\u{524}\u{527}\
	\x03\x02\x02\x02\u{525}\u{523}\x03\x02\x02\x02\u{526}\u{51c}\x03\x02\x02\
	\x02\u{526}\u{527}\x03\x02\x02\x02\u{527}\u{532}\x03\x02\x02\x02\u{528}\
	\u{529}\x07\u{b6}\x02\x02\u{529}\u{52a}\x07\x24\x02\x02\u{52a}\u{52f}\x05\
	\x2a\x16\x02\u{52b}\u{52c}\x07\x2c\x02\x02\u{52c}\u{52e}\x05\x2a\x16\x02\
	\u{52d}\u{52b}\x03\x02\x02\x02\u{52e}\u{531}\x03\x02\x02\x02\u{52f}\u{52d}\
	\x03\x02\x02\x02\u{52f}\u{530}\x03\x02\x02\x02\u{530}\u{533}\x03\x02\x02\
	\x02\u{531}\u{52f}\x03\x02\x02\x02\u{532}\u{528}\x03\x02\x02\x02\u{532}\
	\u{533}\x03\x02\x02\x02\u{533}\u{535}\x03\x02\x02\x02\u{534}\u{536}\x05\
	\u{b0}\x59\x02\u{535}\u{534}\x03\x02\x02\x02\u{535}\u{536}\x03\x02\x02\x02\
	\u{536}\x39\x03\x02\x02\x02\u{537}\u{539}\x05\u{d8}\x6d\x02\u{538}\u{53a}\
	\x05\x60\x31\x02\u{539}\u{538}\x03\x02\x02\x02\u{539}\u{53a}\x03\x02\x02\
	\x02\u{53a}\u{53b}\x03\x02\x02\x02\u{53b}\u{53c}\x07\x1d\x02\x02\u{53c}\
	\u{53d}\x07\x04\x02\x02\u{53d}\u{53e}\x05\x0e\x08\x02\u{53e}\u{53f}\x07\
	\x05\x02\x02\u{53f}\x3b\x03\x02\x02\x02\u{540}\u{541}\x09\x0d\x02\x02\u{541}\
	\x3d\x03\x02\x02\x02\u{542}\u{547}\x05\x72\x3a\x02\u{543}\u{545}\x07\x1d\
	\x02\x02\u{544}\u{543}\x03\x02\x02\x02\u{544}\u{545}\x03\x02\x02\x02\u{545}\
	\u{546}\x03\x02\x02\x02\u{546}\u{548}\x05\u{d8}\x6d\x02\u{547}\u{544}\x03\
	\x02\x02\x02\u{547}\u{548}\x03\x02\x02\x02\u{548}\u{552}\x03\x02\x02\x02\
	\u{549}\u{54a}\x05\x7a\x3e\x02\u{54a}\u{54b}\x07\x03\x02\x02\u{54b}\u{54e}\
	\x07\u{12d}\x02\x02\u{54c}\u{54d}\x07\x1d\x02\x02\u{54d}\u{54f}\x05\x60\
	\x31\x02\u{54e}\u{54c}\x03\x02\x02\x02\u{54e}\u{54f}\x03\x02\x02\x02\u{54f}\
	\u{552}\x03\x02\x02\x02\u{550}\u{552}\x07\u{12d}\x02\x02\u{551}\u{542}\x03\
	\x02\x02\x02\u{551}\u{549}\x03\x02\x02\x02\u{551}\u{550}\x03\x02\x02\x02\
	\u{552}\x3f\x03\x02\x02\x02\u{553}\u{554}\x08\x21\x01\x02\u{554}\u{555}\
	\x05\x46\x24\x02\u{555}\u{568}\x03\x02\x02\x02\u{556}\u{564}\x0c\x04\x02\
	\x02\u{557}\u{558}\x07\x35\x02\x02\u{558}\u{559}\x07\u{80}\x02\x02\u{559}\
	\u{565}\x05\x46\x24\x02\u{55a}\u{55b}\x05\x42\x22\x02\u{55b}\u{55c}\x07\
	\u{80}\x02\x02\u{55c}\u{55d}\x05\x40\x21\x02\u{55d}\u{55e}\x05\x44\x23\x02\
	\u{55e}\u{565}\x03\x02\x02\x02\u{55f}\u{560}\x07\u{a0}\x02\x02\u{560}\u{561}\
	\x05\x42\x22\x02\u{561}\u{562}\x07\u{80}\x02\x02\u{562}\u{563}\x05\x46\x24\
	\x02\u{563}\u{565}\x03\x02\x02\x02\u{564}\u{557}\x03\x02\x02\x02\u{564}\
	\u{55a}\x03\x02\x02\x02\u{564}\u{55f}\x03\x02\x02\x02\u{565}\u{567}\x03\
	\x02\x02\x02\u{566}\u{556}\x03\x02\x02\x02\u{567}\u{56a}\x03\x02\x02\x02\
	\u{568}\u{566}\x03\x02\x02\x02\u{568}\u{569}\x03\x02\x02\x02\u{569}\x41\
	\x03\x02\x02\x02\u{56a}\u{568}\x03\x02\x02\x02\u{56b}\u{56d}\x07\x76\x02\
	\x02\u{56c}\u{56b}\x03\x02\x02\x02\u{56c}\u{56d}\x03\x02\x02\x02\u{56d}\
	\u{57b}\x03\x02\x02\x02\u{56e}\u{570}\x07\u{8d}\x02\x02\u{56f}\u{571}\x07\
	\u{b8}\x02\x02\u{570}\u{56f}\x03\x02\x02\x02\u{570}\u{571}\x03\x02\x02\x02\
	\u{571}\u{57b}\x03\x02\x02\x02\u{572}\u{574}\x07\u{d9}\x02\x02\u{573}\u{575}\
	\x07\u{b8}\x02\x02\u{574}\u{573}\x03\x02\x02\x02\u{574}\u{575}\x03\x02\x02\
	\x02\u{575}\u{57b}\x03\x02\x02\x02\u{576}\u{578}\x07\x65\x02\x02\u{577}\
	\u{579}\x07\u{b8}\x02\x02\u{578}\u{577}\x03\x02\x02\x02\u{578}\u{579}\x03\
	\x02\x02\x02\u{579}\u{57b}\x03\x02\x02\x02\u{57a}\u{56c}\x03\x02\x02\x02\
	\u{57a}\u{56e}\x03\x02\x02\x02\u{57a}\u{572}\x03\x02\x02\x02\u{57a}\u{576}\
	\x03\x02\x02\x02\u{57b}\x43\x03\x02\x02\x02\u{57c}\u{57d}\x07\u{b1}\x02\
	\x02\u{57d}\u{58b}\x05\x74\x3b\x02\u{57e}\u{57f}\x07\u{110}\x02\x02\u{57f}\
	\u{580}\x07\x04\x02\x02\u{580}\u{585}\x05\u{d8}\x6d\x02\u{581}\u{582}\x07\
	\x2c\x02\x02\u{582}\u{584}\x05\u{d8}\x6d\x02\u{583}\u{581}\x03\x02\x02\x02\
	\u{584}\u{587}\x03\x02\x02\x02\u{585}\u{583}\x03\x02\x02\x02\u{585}\u{586}\
	\x03\x02\x02\x02\u{586}\u{588}\x03\x02\x02\x02\u{587}\u{585}\x03\x02\x02\
	\x02\u{588}\u{589}\x07\x05\x02\x02\u{589}\u{58b}\x03\x02\x02\x02\u{58a}\
	\u{57c}\x03\x02\x02\x02\u{58a}\u{57e}\x03\x02\x02\x02\u{58b}\x45\x03\x02\
	\x02\x02\u{58c}\u{593}\x05\x50\x29\x02\u{58d}\u{58e}\x07\u{f5}\x02\x02\u{58e}\
	\u{58f}\x05\x48\x25\x02\u{58f}\u{590}\x07\x04\x02\x02\u{590}\u{591}\x05\
	\x72\x3a\x02\u{591}\u{592}\x07\x05\x02\x02\u{592}\u{594}\x03\x02\x02\x02\
	\u{593}\u{58d}\x03\x02\x02\x02\u{593}\u{594}\x03\x02\x02\x02\u{594}\x47\
	\x03\x02\x02\x02\u{595}\u{596}\x09\x0e\x02\x02\u{596}\x49\x03\x02\x02\x02\
	\u{597}\u{598}\x09\x0f\x02\x02\u{598}\x4b\x03\x02\x02\x02\u{599}\u{5a0}\
	\x07\x54\x02\x02\u{59a}\u{59c}\x07\u{101}\x02\x02\u{59b}\u{59d}\x05\u{92}\
	\x4a\x02\u{59c}\u{59b}\x03\x02\x02\x02\u{59c}\u{59d}\x03\x02\x02\x02\u{59d}\
	\u{59e}\x03\x02\x02\x02\u{59e}\u{5a0}\x05\x4e\x28\x02\u{59f}\u{599}\x03\
	\x02\x02\x02\u{59f}\u{59a}\x03\x02\x02\x02\u{5a0}\x4d\x03\x02\x02\x02\u{5a1}\
	\u{5a2}\x07\u{11d}\x02\x02\u{5a2}\u{5a6}\x07\x32\x02\x02\u{5a3}\u{5a4}\x07\
	\u{11f}\x02\x02\u{5a4}\u{5a6}\x07\x32\x02\x02\u{5a5}\u{5a1}\x03\x02\x02\
	\x02\u{5a5}\u{5a3}\x03\x02\x02\x02\u{5a6}\x4f\x03\x02\x02\x02\u{5a7}\u{5fa}\
	\x05\x5e\x30\x02\u{5a8}\u{5a9}\x07\u{9a}\x02\x02\u{5a9}\u{5b4}\x07\x04\x02\
	\x02\u{5aa}\u{5ab}\x07\u{bc}\x02\x02\u{5ab}\u{5ac}\x07\x24\x02\x02\u{5ac}\
	\u{5b1}\x05\x72\x3a\x02\u{5ad}\u{5ae}\x07\x2c\x02\x02\u{5ae}\u{5b0}\x05\
	\x72\x3a\x02\u{5af}\u{5ad}\x03\x02\x02\x02\u{5b0}\u{5b3}\x03\x02\x02\x02\
	\u{5b1}\u{5af}\x03\x02\x02\x02\u{5b1}\u{5b2}\x03\x02\x02\x02\u{5b2}\u{5b5}\
	\x03\x02\x02\x02\u{5b3}\u{5b1}\x03\x02\x02\x02\u{5b4}\u{5aa}\x03\x02\x02\
	\x02\u{5b4}\u{5b5}\x03\x02\x02\x02\u{5b5}\u{5c0}\x03\x02\x02\x02\u{5b6}\
	\u{5b7}\x07\u{b6}\x02\x02\u{5b7}\u{5b8}\x07\x24\x02\x02\u{5b8}\u{5bd}\x05\
	\x2a\x16\x02\u{5b9}\u{5ba}\x07\x2c\x02\x02\u{5ba}\u{5bc}\x05\x2a\x16\x02\
	\u{5bb}\u{5b9}\x03\x02\x02\x02\u{5bc}\u{5bf}\x03\x02\x02\x02\u{5bd}\u{5bb}\
	\x03\x02\x02\x02\u{5bd}\u{5be}\x03\x02\x02\x02\u{5be}\u{5c1}\x03\x02\x02\
	\x02\u{5bf}\u{5bd}\x03\x02\x02\x02\u{5c0}\u{5b6}\x03\x02\x02\x02\u{5c0}\
	\u{5c1}\x03\x02\x02\x02\u{5c1}\u{5cb}\x03\x02\x02\x02\u{5c2}\u{5c3}\x07\
	\u{9c}\x02\x02\u{5c3}\u{5c8}\x05\x52\x2a\x02\u{5c4}\u{5c5}\x07\x2c\x02\x02\
	\u{5c5}\u{5c7}\x05\x52\x2a\x02\u{5c6}\u{5c4}\x03\x02\x02\x02\u{5c7}\u{5ca}\
	\x03\x02\x02\x02\u{5c8}\u{5c6}\x03\x02\x02\x02\u{5c8}\u{5c9}\x03\x02\x02\
	\x02\u{5c9}\u{5cc}\x03\x02\x02\x02\u{5ca}\u{5c8}\x03\x02\x02\x02\u{5cb}\
	\u{5c2}\x03\x02\x02\x02\u{5cb}\u{5cc}\x03\x02\x02\x02\u{5cc}\u{5ce}\x03\
	\x02\x02\x02\u{5cd}\u{5cf}\x05\x54\x2b\x02\u{5ce}\u{5cd}\x03\x02\x02\x02\
	\u{5ce}\u{5cf}\x03\x02\x02\x02\u{5cf}\u{5d3}\x03\x02\x02\x02\u{5d0}\u{5d1}\
	\x07\x16\x02\x02\u{5d1}\u{5d2}\x07\u{97}\x02\x02\u{5d2}\u{5d4}\x05\x58\x2d\
	\x02\u{5d3}\u{5d0}\x03\x02\x02\x02\u{5d3}\u{5d4}\x03\x02\x02\x02\u{5d4}\
	\u{5d6}\x03\x02\x02\x02\u{5d5}\u{5d7}\x09\x10\x02\x02\u{5d6}\u{5d5}\x03\
	\x02\x02\x02\u{5d6}\u{5d7}\x03\x02\x02\x02\u{5d7}\u{5d8}\x03\x02\x02\x02\
	\u{5d8}\u{5d9}\x07\u{c1}\x02\x02\u{5d9}\u{5da}\x07\x04\x02\x02\u{5da}\u{5db}\
	\x05\u{b6}\x5c\x02\u{5db}\u{5e5}\x07\x05\x02\x02\u{5dc}\u{5dd}\x07\u{f0}\
	\x02\x02\u{5dd}\u{5e2}\x05\x5a\x2e\x02\u{5de}\u{5df}\x07\x2c\x02\x02\u{5df}\
	\u{5e1}\x05\x5a\x2e\x02\u{5e0}\u{5de}\x03\x02\x02\x02\u{5e1}\u{5e4}\x03\
	\x02\x02\x02\u{5e2}\u{5e0}\x03\x02\x02\x02\u{5e2}\u{5e3}\x03\x02\x02\x02\
	\u{5e3}\u{5e6}\x03\x02\x02\x02\u{5e4}\u{5e2}\x03\x02\x02\x02\u{5e5}\u{5dc}\
	\x03\x02\x02\x02\u{5e5}\u{5e6}\x03\x02\x02\x02\u{5e6}\u{5e7}\x03\x02\x02\
	\x02\u{5e7}\u{5e8}\x07\x45\x02\x02\u{5e8}\u{5ed}\x05\x5c\x2f\x02\u{5e9}\
	\u{5ea}\x07\x2c\x02\x02\u{5ea}\u{5ec}\x05\x5c\x2f\x02\u{5eb}\u{5e9}\x03\
	\x02\x02\x02\u{5ec}\u{5ef}\x03\x02\x02\x02\u{5ed}\u{5eb}\x03\x02\x02\x02\
	\u{5ed}\u{5ee}\x03\x02\x02\x02\u{5ee}\u{5f0}\x03\x02\x02\x02\u{5ef}\u{5ed}\
	\x03\x02\x02\x02\u{5f0}\u{5f8}\x07\x05\x02\x02\u{5f1}\u{5f3}\x07\x1d\x02\
	\x02\u{5f2}\u{5f1}\x03\x02\x02\x02\u{5f2}\u{5f3}\x03\x02\x02\x02\u{5f3}\
	\u{5f4}\x03\x02\x02\x02\u{5f4}\u{5f6}\x05\u{d8}\x6d\x02\u{5f5}\u{5f7}\x05\
	\x60\x31\x02\u{5f6}\u{5f5}\x03\x02\x02\x02\u{5f6}\u{5f7}\x03\x02\x02\x02\
	\u{5f7}\u{5f9}\x03\x02\x02\x02\u{5f8}\u{5f2}\x03\x02\x02\x02\u{5f8}\u{5f9}\
	\x03\x02\x02\x02\u{5f9}\u{5fb}\x03\x02\x02\x02\u{5fa}\u{5a8}\x03\x02\x02\
	\x02\u{5fa}\u{5fb}\x03\x02\x02\x02\u{5fb}\x51\x03\x02\x02\x02\u{5fc}\u{5fd}\
	\x05\x72\x3a\x02\u{5fd}\u{5fe}\x07\x1d\x02\x02\u{5fe}\u{5ff}\x05\u{d8}\x6d\
	\x02\u{5ff}\x53\x03\x02\x02\x02\u{600}\u{601}\x07\u{b2}\x02\x02\u{601}\u{602}\
	\x07\u{de}\x02\x02\u{602}\u{603}\x07\u{c2}\x02\x02\u{603}\u{60c}\x07\u{97}\
	\x02\x02\u{604}\u{605}\x07\x17\x02\x02\u{605}\u{606}\x07\u{df}\x02\x02\u{606}\
	\u{607}\x07\u{c2}\x02\x02\u{607}\u{609}\x07\u{97}\x02\x02\u{608}\u{60a}\
	\x05\x56\x2c\x02\u{609}\u{608}\x03\x02\x02\x02\u{609}\u{60a}\x03\x02\x02\
	\x02\u{60a}\u{60c}\x03\x02\x02\x02\u{60b}\u{600}\x03\x02\x02\x02\u{60b}\
	\u{604}\x03\x02\x02\x02\u{60c}\x55\x03\x02\x02\x02\u{60d}\u{60e}\x07\u{ec}\
	\x02\x02\u{60e}\u{60f}\x07\x51\x02\x02\u{60f}\u{617}\x07\u{99}\x02\x02\u{610}\
	\u{611}\x07\u{b0}\x02\x02\u{611}\u{612}\x07\x51\x02\x02\u{612}\u{617}\x07\
	\u{99}\x02\x02\u{613}\u{614}\x07\u{11d}\x02\x02\u{614}\u{615}\x07\u{10b}\
	\x02\x02\u{615}\u{617}\x07\u{df}\x02\x02\u{616}\u{60d}\x03\x02\x02\x02\u{616}\
	\u{610}\x03\x02\x02\x02\u{616}\u{613}\x03\x02\x02\x02\u{617}\x57\x03\x02\
	\x02\x02\u{618}\u{619}\x07\x06\x02\x02\u{619}\u{61a}\x07\u{fc}\x02\x02\u{61a}\
	\u{61b}\x07\u{a1}\x02\x02\u{61b}\u{62c}\x07\u{de}\x02\x02\u{61c}\u{61d}\
	\x07\x06\x02\x02\u{61d}\u{61e}\x07\u{bf}\x02\x02\u{61e}\u{61f}\x07\u{8a}\
	\x02\x02\u{61f}\u{62c}\x07\u{de}\x02\x02\u{620}\u{621}\x07\x06\x02\x02\u{621}\
	\u{622}\x07\u{fc}\x02\x02\u{622}\u{623}\x07\x60\x02\x02\u{623}\u{62c}\x05\
	\u{d8}\x6d\x02\u{624}\u{625}\x07\x06\x02\x02\u{625}\u{626}\x07\u{fc}\x02\
	\x02\u{626}\u{627}\x07\u{8a}\x02\x02\u{627}\u{62c}\x05\u{d8}\x6d\x02\u{628}\
	\u{629}\x07\x06\x02\x02\u{629}\u{62a}\x07\u{fc}\x02\x02\u{62a}\u{62c}\x05\
	\u{d8}\x6d\x02\u{62b}\u{618}\x03\x02\x02\x02\u{62b}\u{61c}\x03\x02\x02\x02\
	\u{62b}\u{620}\x03\x02\x02\x02\u{62b}\u{624}\x03\x02\x02\x02\u{62b}\u{628}\
	\x03\x02\x02\x02\u{62c}\x59\x03\x02\x02\x02\u{62d}\u{62e}\x05\u{d8}\x6d\
	\x02\u{62e}\u{62f}\x07\u{125}\x02\x02\u{62f}\u{630}\x07\x04\x02\x02\u{630}\
	\u{635}\x05\u{d8}\x6d\x02\u{631}\u{632}\x07\x2c\x02\x02\u{632}\u{634}\x05\
	\u{d8}\x6d\x02\u{633}\u{631}\x03\x02\x02\x02\u{634}\u{637}\x03\x02\x02\x02\
	\u{635}\u{633}\x03\x02\x02\x02\u{635}\u{636}\x03\x02\x02\x02\u{636}\u{638}\
	\x03\x02\x02\x02\u{637}\u{635}\x03\x02\x02\x02\u{638}\u{639}\x07\x05\x02\
	\x02\u{639}\x5b\x03\x02\x02\x02\u{63a}\u{63b}\x05\u{d8}\x6d\x02\u{63b}\u{63c}\
	\x07\x1d\x02\x02\u{63c}\u{63d}\x05\x72\x3a\x02\u{63d}\x5d\x03\x02\x02\x02\
	\u{63e}\u{646}\x05\x62\x32\x02\u{63f}\u{641}\x07\x1d\x02\x02\u{640}\u{63f}\
	\x03\x02\x02\x02\u{640}\u{641}\x03\x02\x02\x02\u{641}\u{642}\x03\x02\x02\
	\x02\u{642}\u{644}\x05\u{d8}\x6d\x02\u{643}\u{645}\x05\x60\x31\x02\u{644}\
	\u{643}\x03\x02\x02\x02\u{644}\u{645}\x03\x02\x02\x02\u{645}\u{647}\x03\
	\x02\x02\x02\u{646}\u{640}\x03\x02\x02\x02\u{646}\u{647}\x03\x02\x02\x02\
	\u{647}\x5f\x03\x02\x02\x02\u{648}\u{649}\x07\x04\x02\x02\u{649}\u{64e}\
	\x05\u{d8}\x6d\x02\u{64a}\u{64b}\x07\x2c\x02\x02\u{64b}\u{64d}\x05\u{d8}\
	\x6d\x02\u{64c}\u{64a}\x03\x02\x02\x02\u{64d}\u{650}\x03\x02\x02\x02\u{64e}\
	\u{64c}\x03\x02\x02\x02\u{64e}\u{64f}\x03\x02\x02\x02\u{64f}\u{651}\x03\
	\x02\x02\x02\u{650}\u{64e}\x03\x02\x02\x02\u{651}\u{652}\x07\x05\x02\x02\
	\u{652}\x61\x03\x02\x02\x02\u{653}\u{655}\x05\u{cc}\x67\x02\u{654}\u{656}\
	\x05\u{ce}\x68\x02\u{655}\u{654}\x03\x02\x02\x02\u{655}\u{656}\x03\x02\x02\
	\x02\u{656}\u{679}\x03\x02\x02\x02\u{657}\u{658}\x07\x04\x02\x02\u{658}\
	\u{659}\x05\x0e\x08\x02\u{659}\u{65a}\x07\x05\x02\x02\u{65a}\u{679}\x03\
	\x02\x02\x02\u{65b}\u{65c}\x07\u{10c}\x02\x02\u{65c}\u{65d}\x07\x04\x02\
	\x02\u{65d}\u{662}\x05\x72\x3a\x02\u{65e}\u{65f}\x07\x2c\x02\x02\u{65f}\
	\u{661}\x05\x72\x3a\x02\u{660}\u{65e}\x03\x02\x02\x02\u{661}\u{664}\x03\
	\x02\x02\x02\u{662}\u{660}\x03\x02\x02\x02\u{662}\u{663}\x03\x02\x02\x02\
	\u{663}\u{665}\x03\x02\x02\x02\u{664}\u{662}\x03\x02\x02\x02\u{665}\u{668}\
	\x07\x05\x02\x02\u{666}\u{667}\x07\u{11d}\x02\x02\u{667}\u{669}\x07\u{b7}\
	\x02\x02\u{668}\u{666}\x03\x02\x02\x02\u{668}\u{669}\x03\x02\x02\x02\u{669}\
	\u{679}\x03\x02\x02\x02\u{66a}\u{66b}\x07\u{8b}\x02\x02\u{66b}\u{66c}\x07\
	\x04\x02\x02\u{66c}\u{66d}\x05\x0e\x08\x02\u{66d}\u{66e}\x07\x05\x02\x02\
	\u{66e}\u{679}\x03\x02\x02\x02\u{66f}\u{670}\x07\u{f3}\x02\x02\u{670}\u{671}\
	\x07\x04\x02\x02\u{671}\u{672}\x05\x64\x33\x02\u{672}\u{673}\x07\x05\x02\
	\x02\u{673}\u{679}\x03\x02\x02\x02\u{674}\u{675}\x07\x04\x02\x02\u{675}\
	\u{676}\x05\x40\x21\x02\u{676}\u{677}\x07\x05\x02\x02\u{677}\u{679}\x03\
	\x02\x02\x02\u{678}\u{653}\x03\x02\x02\x02\u{678}\u{657}\x03\x02\x02\x02\
	\u{678}\u{65b}\x03\x02\x02\x02\u{678}\u{66a}\x03\x02\x02\x02\u{678}\u{66f}\
	\x03\x02\x02\x02\u{678}\u{674}\x03\x02\x02\x02\u{679}\x63\x03\x02\x02\x02\
	\u{67a}\u{67b}\x05\u{cc}\x67\x02\u{67b}\u{684}\x07\x04\x02\x02\u{67c}\u{681}\
	\x05\x66\x34\x02\u{67d}\u{67e}\x07\x2c\x02\x02\u{67e}\u{680}\x05\x66\x34\
	\x02\u{67f}\u{67d}\x03\x02\x02\x02\u{680}\u{683}\x03\x02\x02\x02\u{681}\
	\u{67f}\x03\x02\x02\x02\u{681}\u{682}\x03\x02\x02\x02\u{682}\u{685}\x03\
	\x02\x02\x02\u{683}\u{681}\x03\x02\x02\x02\u{684}\u{67c}\x03\x02\x02\x02\
	\u{684}\u{685}\x03\x02\x02\x02\u{685}\u{68f}\x03\x02\x02\x02\u{686}\u{687}\
	\x07\x33\x02\x02\u{687}\u{68c}\x05\x70\x39\x02\u{688}\u{689}\x07\x2c\x02\
	\x02\u{689}\u{68b}\x05\x70\x39\x02\u{68a}\u{688}\x03\x02\x02\x02\u{68b}\
	\u{68e}\x03\x02\x02\x02\u{68c}\u{68a}\x03\x02\x02\x02\u{68c}\u{68d}\x03\
	\x02\x02\x02\u{68d}\u{690}\x03\x02\x02\x02\u{68e}\u{68c}\x03\x02\x02\x02\
	\u{68f}\u{686}\x03\x02\x02\x02\u{68f}\u{690}\x03\x02\x02\x02\u{690}\u{691}\
	\x03\x02\x02\x02\u{691}\u{692}\x07\x05\x02\x02\u{692}\x65\x03\x02\x02\x02\
	\u{693}\u{694}\x05\u{d8}\x6d\x02\u{694}\u{695}\x07\x07\x02\x02\u{695}\u{697}\
	\x03\x02\x02\x02\u{696}\u{693}\x03\x02\x02\x02\u{696}\u{697}\x03\x02\x02\
	\x02\u{697}\u{69b}\x03\x02\x02\x02\u{698}\u{69c}\x05\x68\x35\x02\u{699}\
	\u{69c}\x05\x6c\x37\x02\u{69a}\u{69c}\x05\x72\x3a\x02\u{69b}\u{698}\x03\
	\x02\x02\x02\u{69b}\u{699}\x03\x02\x02\x02\u{69b}\u{69a}\x03\x02\x02\x02\
	\u{69c}\x67\x03\x02\x02\x02\u{69d}\u{6af}\x05\x6a\x36\x02\u{69e}\u{69f}\
	\x07\u{bc}\x02\x02\u{69f}\u{6ad}\x07\x24\x02\x02\u{6a0}\u{6a9}\x07\x04\x02\
	\x02\u{6a1}\u{6a6}\x05\x72\x3a\x02\u{6a2}\u{6a3}\x07\x2c\x02\x02\u{6a3}\
	\u{6a5}\x05\x72\x3a\x02\u{6a4}\u{6a2}\x03\x02\x02\x02\u{6a5}\u{6a8}\x03\
	\x02\x02\x02\u{6a6}\u{6a4}\x03\x02\x02\x02\u{6a6}\u{6a7}\x03\x02\x02\x02\
	\u{6a7}\u{6aa}\x03\x02\x02\x02\u{6a8}\u{6a6}\x03\x02\x02\x02\u{6a9}\u{6a1}\
	\x03\x02\x02\x02\u{6a9}\u{6aa}\x03\x02\x02\x02\u{6aa}\u{6ab}\x03\x02\x02\
	\x02\u{6ab}\u{6ae}\x07\x05\x02\x02\u{6ac}\u{6ae}\x05\x72\x3a\x02\u{6ad}\
	\u{6a0}\x03\x02\x02\x02\u{6ad}\u{6ac}\x03\x02\x02\x02\u{6ae}\u{6b0}\x03\
	\x02\x02\x02\u{6af}\u{69e}\x03\x02\x02\x02\u{6af}\u{6b0}\x03\x02\x02\x02\
	\u{6b0}\u{6b7}\x03\x02\x02\x02\u{6b1}\u{6b2}\x07\u{cb}\x02\x02\u{6b2}\u{6b3}\
	\x07\u{11a}\x02\x02\u{6b3}\u{6b8}\x07\x51\x02\x02\u{6b4}\u{6b5}\x07\u{87}\
	\x02\x02\u{6b5}\u{6b6}\x07\u{11a}\x02\x02\u{6b6}\u{6b8}\x07\x51\x02\x02\
	\u{6b7}\u{6b1}\x03\x02\x02\x02\u{6b7}\u{6b4}\x03\x02\x02\x02\u{6b7}\u{6b8}\
	\x03\x02\x02\x02\u{6b8}\u{6c9}\x03\x02\x02\x02\u{6b9}\u{6ba}\x07\u{b6}\x02\
	\x02\u{6ba}\u{6c7}\x07\x24\x02\x02\u{6bb}\u{6bc}\x07\x04\x02\x02\u{6bc}\
	\u{6c1}\x05\x2a\x16\x02\u{6bd}\u{6be}\x07\x2c\x02\x02\u{6be}\u{6c0}\x05\
	\x2a\x16\x02\u{6bf}\u{6bd}\x03\x02\x02\x02\u{6c0}\u{6c3}\x03\x02\x02\x02\
	\u{6c1}\u{6bf}\x03\x02\x02\x02\u{6c1}\u{6c2}\x03\x02\x02\x02\u{6c2}\u{6c4}\
	\x03\x02\x02\x02\u{6c3}\u{6c1}\x03\x02\x02\x02\u{6c4}\u{6c5}\x07\x05\x02\
	\x02\u{6c5}\u{6c8}\x03\x02\x02\x02\u{6c6}\u{6c8}\x05\x2a\x16\x02\u{6c7}\
	\u{6bb}\x03\x02\x02\x02\u{6c7}\u{6c6}\x03\x02\x02\x02\u{6c8}\u{6ca}\x03\
	\x02\x02\x02\u{6c9}\u{6b9}\x03\x02\x02\x02\u{6c9}\u{6ca}\x03\x02\x02\x02\
	\u{6ca}\x69\x03\x02\x02\x02\u{6cb}\u{6cc}\x07\u{f3}\x02\x02\u{6cc}\u{6cd}\
	\x07\x04\x02\x02\u{6cd}\u{6ce}\x05\u{cc}\x67\x02\u{6ce}\u{6d6}\x07\x05\x02\
	\x02\u{6cf}\u{6d1}\x07\x1d\x02\x02\u{6d0}\u{6cf}\x03\x02\x02\x02\u{6d0}\
	\u{6d1}\x03\x02\x02\x02\u{6d1}\u{6d2}\x03\x02\x02\x02\u{6d2}\u{6d4}\x05\
	\u{d8}\x6d\x02\u{6d3}\u{6d5}\x05\x60\x31\x02\u{6d4}\u{6d3}\x03\x02\x02\x02\
	\u{6d4}\u{6d5}\x03\x02\x02\x02\u{6d5}\u{6d7}\x03\x02\x02\x02\u{6d6}\u{6d0}\
	\x03\x02\x02\x02\u{6d6}\u{6d7}\x03\x02\x02\x02\u{6d7}\u{6e6}\x03\x02\x02\
	\x02\u{6d8}\u{6d9}\x07\u{f3}\x02\x02\u{6d9}\u{6da}\x07\x04\x02\x02\u{6da}\
	\u{6db}\x05\x0e\x08\x02\u{6db}\u{6e3}\x07\x05\x02\x02\u{6dc}\u{6de}\x07\
	\x1d\x02\x02\u{6dd}\u{6dc}\x03\x02\x02\x02\u{6dd}\u{6de}\x03\x02\x02\x02\
	\u{6de}\u{6df}\x03\x02\x02\x02\u{6df}\u{6e1}\x05\u{d8}\x6d\x02\u{6e0}\u{6e2}\
	\x05\x60\x31\x02\u{6e1}\u{6e0}\x03\x02\x02\x02\u{6e1}\u{6e2}\x03\x02\x02\
	\x02\u{6e2}\u{6e4}\x03\x02\x02\x02\u{6e3}\u{6dd}\x03\x02\x02\x02\u{6e3}\
	\u{6e4}\x03\x02\x02\x02\u{6e4}\u{6e6}\x03\x02\x02\x02\u{6e5}\u{6cb}\x03\
	\x02\x02\x02\u{6e5}\u{6d8}\x03\x02\x02\x02\u{6e6}\x6b\x03\x02\x02\x02\u{6e7}\
	\u{6e8}\x07\x4b\x02\x02\u{6e8}\u{6e9}\x07\x04\x02\x02\u{6e9}\u{6ee}\x05\
	\x6e\x38\x02\u{6ea}\u{6eb}\x07\x2c\x02\x02\u{6eb}\u{6ed}\x05\x6e\x38\x02\
	\u{6ec}\u{6ea}\x03\x02\x02\x02\u{6ed}\u{6f0}\x03\x02\x02\x02\u{6ee}\u{6ec}\
	\x03\x02\x02\x02\u{6ee}\u{6ef}\x03\x02\x02\x02\u{6ef}\u{6f1}\x03\x02\x02\
	\x02\u{6f0}\u{6ee}\x03\x02\x02\x02\u{6f1}\u{6f2}\x07\x05\x02\x02\u{6f2}\
	\u{6fa}\x03\x02\x02\x02\u{6f3}\u{6f4}\x07\x28\x02\x02\u{6f4}\u{6f5}\x07\
	\x04\x02\x02\u{6f5}\u{6f6}\x07\u{aa}\x02\x02\u{6f6}\u{6f7}\x07\x1d\x02\x02\
	\u{6f7}\u{6f8}\x07\x4b\x02\x02\u{6f8}\u{6fa}\x07\x05\x02\x02\u{6f9}\u{6e7}\
	\x03\x02\x02\x02\u{6f9}\u{6f3}\x03\x02\x02\x02\u{6fa}\x6d\x03\x02\x02\x02\
	\u{6fb}\u{6fd}\x05\u{d8}\x6d\x02\u{6fc}\u{6fe}\x05\u{a2}\x52\x02\u{6fd}\
	\u{6fc}\x03\x02\x02\x02\u{6fd}\u{6fe}\x03\x02\x02\x02\u{6fe}\x6f\x03\x02\
	\x02\x02\u{6ff}\u{700}\x07\x04\x02\x02\u{700}\u{701}\x05\u{cc}\x67\x02\u{701}\
	\u{702}\x07\x2c\x02\x02\u{702}\u{707}\x05\u{cc}\x67\x02\u{703}\u{704}\x07\
	\x2c\x02\x02\u{704}\u{706}\x05\u{cc}\x67\x02\u{705}\u{703}\x03\x02\x02\x02\
	\u{706}\u{709}\x03\x02\x02\x02\u{707}\u{705}\x03\x02\x02\x02\u{707}\u{708}\
	\x03\x02\x02\x02\u{708}\u{70a}\x03\x02\x02\x02\u{709}\u{707}\x03\x02\x02\
	\x02\u{70a}\u{70b}\x07\x05\x02\x02\u{70b}\x71\x03\x02\x02\x02\u{70c}\u{70d}\
	\x05\x74\x3b\x02\u{70d}\x73\x03\x02\x02\x02\u{70e}\u{70f}\x08\x3b\x01\x02\
	\u{70f}\u{711}\x05\x78\x3d\x02\u{710}\u{712}\x05\x76\x3c\x02\u{711}\u{710}\
	\x03\x02\x02\x02\u{711}\u{712}\x03\x02\x02\x02\u{712}\u{716}\x03\x02\x02\
	\x02\u{713}\u{714}\x07\u{a9}\x02\x02\u{714}\u{716}\x05\x74\x3b\x05\u{715}\
	\u{70e}\x03\x02\x02\x02\u{715}\u{713}\x03\x02\x02\x02\u{716}\u{71f}\x03\
	\x02\x02\x02\u{717}\u{718}\x0c\x04\x02\x02\u{718}\u{719}\x07\x1a\x02\x02\
	\u{719}\u{71e}\x05\x74\x3b\x05\u{71a}\u{71b}\x0c\x03\x02\x02\u{71b}\u{71c}\
	\x07\u{b5}\x02\x02\u{71c}\u{71e}\x05\x74\x3b\x04\u{71d}\u{717}\x03\x02\x02\
	\x02\u{71d}\u{71a}\x03\x02\x02\x02\u{71e}\u{721}\x03\x02\x02\x02\u{71f}\
	\u{71d}\x03\x02\x02\x02\u{71f}\u{720}\x03\x02\x02\x02\u{720}\x75\x03\x02\
	\x02\x02\u{721}\u{71f}\x03\x02\x02\x02\u{722}\u{723}\x05\u{96}\x4c\x02\u{723}\
	\u{724}\x05\x78\x3d\x02\u{724}\u{760}\x03\x02\x02\x02\u{725}\u{726}\x05\
	\u{96}\x4c\x02\u{726}\u{727}\x05\u{98}\x4d\x02\u{727}\u{728}\x07\x04\x02\
	\x02\u{728}\u{729}\x05\x0e\x08\x02\u{729}\u{72a}\x07\x05\x02\x02\u{72a}\
	\u{760}\x03\x02\x02\x02\u{72b}\u{72d}\x07\u{a9}\x02\x02\u{72c}\u{72b}\x03\
	\x02\x02\x02\u{72c}\u{72d}\x03\x02\x02\x02\u{72d}\u{72e}\x03\x02\x02\x02\
	\u{72e}\u{72f}\x07\x22\x02\x02\u{72f}\u{730}\x05\x78\x3d\x02\u{730}\u{731}\
	\x07\x1a\x02\x02\u{731}\u{732}\x05\x78\x3d\x02\u{732}\u{760}\x03\x02\x02\
	\x02\u{733}\u{735}\x07\u{a9}\x02\x02\u{734}\u{733}\x03\x02\x02\x02\u{734}\
	\u{735}\x03\x02\x02\x02\u{735}\u{736}\x03\x02\x02\x02\u{736}\u{737}\x07\
	\x73\x02\x02\u{737}\u{738}\x07\x04\x02\x02\u{738}\u{73d}\x05\x72\x3a\x02\
	\u{739}\u{73a}\x07\x2c\x02\x02\u{73a}\u{73c}\x05\x72\x3a\x02\u{73b}\u{739}\
	\x03\x02\x02\x02\u{73c}\u{73f}\x03\x02\x02\x02\u{73d}\u{73b}\x03\x02\x02\
	\x02\u{73d}\u{73e}\x03\x02\x02\x02\u{73e}\u{740}\x03\x02\x02\x02\u{73f}\
	\u{73d}\x03\x02\x02\x02\u{740}\u{741}\x07\x05\x02\x02\u{741}\u{760}\x03\
	\x02\x02\x02\u{742}\u{744}\x07\u{a9}\x02\x02\u{743}\u{742}\x03\x02\x02\x02\
	\u{743}\u{744}\x03\x02\x02\x02\u{744}\u{745}\x03\x02\x02\x02\u{745}\u{746}\
	\x07\x73\x02\x02\u{746}\u{747}\x07\x04\x02\x02\u{747}\u{748}\x05\x0e\x08\
	\x02\u{748}\u{749}\x07\x05\x02\x02\u{749}\u{760}\x03\x02\x02\x02\u{74a}\
	\u{74c}\x07\u{a9}\x02\x02\u{74b}\u{74a}\x03\x02\x02\x02\u{74b}\u{74c}\x03\
	\x02\x02\x02\u{74c}\u{74d}\x03\x02\x02\x02\u{74d}\u{74e}\x07\u{8f}\x02\x02\
	\u{74e}\u{751}\x05\x78\x3d\x02\u{74f}\u{750}\x07\x55\x02\x02\u{750}\u{752}\
	\x05\x78\x3d\x02\u{751}\u{74f}\x03\x02\x02\x02\u{751}\u{752}\x03\x02\x02\
	\x02\u{752}\u{760}\x03\x02\x02\x02\u{753}\u{755}\x07\x7e\x02\x02\u{754}\
	\u{756}\x07\u{a9}\x02\x02\u{755}\u{754}\x03\x02\x02\x02\u{755}\u{756}\x03\
	\x02\x02\x02\u{756}\u{757}\x03\x02\x02\x02\u{757}\u{760}\x07\u{aa}\x02\x02\
	\u{758}\u{75a}\x07\x7e\x02\x02\u{759}\u{75b}\x07\u{a9}\x02\x02\u{75a}\u{759}\
	\x03\x02\x02\x02\u{75a}\u{75b}\x03\x02\x02\x02\u{75b}\u{75c}\x03\x02\x02\
	\x02\u{75c}\u{75d}\x07\x4c\x02\x02\u{75d}\u{75e}\x07\x64\x02\x02\u{75e}\
	\u{760}\x05\x78\x3d\x02\u{75f}\u{722}\x03\x02\x02\x02\u{75f}\u{725}\x03\
	\x02\x02\x02\u{75f}\u{72c}\x03\x02\x02\x02\u{75f}\u{734}\x03\x02\x02\x02\
	\u{75f}\u{743}\x03\x02\x02\x02\u{75f}\u{74b}\x03\x02\x02\x02\u{75f}\u{753}\
	\x03\x02\x02\x02\u{75f}\u{758}\x03\x02\x02\x02\u{760}\x77\x03\x02\x02\x02\
	\u{761}\u{762}\x08\x3d\x01\x02\u{762}\u{766}\x05\x7a\x3e\x02\u{763}\u{764}\
	\x09\x11\x02\x02\u{764}\u{766}\x05\x78\x3d\x06\u{765}\u{761}\x03\x02\x02\
	\x02\u{765}\u{763}\x03\x02\x02\x02\u{766}\u{775}\x03\x02\x02\x02\u{767}\
	\u{768}\x0c\x05\x02\x02\u{768}\u{769}\x09\x12\x02\x02\u{769}\u{774}\x05\
	\x78\x3d\x06\u{76a}\u{76b}\x0c\x04\x02\x02\u{76b}\u{76c}\x09\x11\x02\x02\
	\u{76c}\u{774}\x05\x78\x3d\x05\u{76d}\u{76e}\x0c\x03\x02\x02\u{76e}\u{76f}\
	\x07\u{130}\x02\x02\u{76f}\u{774}\x05\x78\x3d\x04\u{770}\u{771}\x0c\x07\
	\x02\x02\u{771}\u{772}\x07\x1f\x02\x02\u{772}\u{774}\x05\u{94}\x4b\x02\u{773}\
	\u{767}\x03\x02\x02\x02\u{773}\u{76a}\x03\x02\x02\x02\u{773}\u{76d}\x03\
	\x02\x02\x02\u{773}\u{770}\x03\x02\x02\x02\u{774}\u{777}\x03\x02\x02\x02\
	\u{775}\u{773}\x03\x02\x02\x02\u{775}\u{776}\x03\x02\x02\x02\u{776}\x79\
	\x03\x02\x02\x02\u{777}\u{775}\x03\x02\x02\x02\u{778}\u{779}\x08\x3e\x01\
	\x02\u{779}\u{93b}\x07\u{aa}\x02\x02\u{77a}\u{93b}\x05\u{9c}\x4f\x02\u{77b}\
	\u{77c}\x05\u{d8}\x6d\x02\u{77c}\u{77d}\x05\u{92}\x4a\x02\u{77d}\u{93b}\
	\x03\x02\x02\x02\u{77e}\u{77f}\x07\x4e\x02\x02\u{77f}\u{780}\x07\u{c7}\x02\
	\x02\u{780}\u{93b}\x05\u{92}\x4a\x02\u{781}\u{93b}\x05\u{da}\x6e\x02\u{782}\
	\u{93b}\x05\u{9a}\x4e\x02\u{783}\u{93b}\x05\u{92}\x4a\x02\u{784}\u{93b}\
	\x07\u{134}\x02\x02\u{785}\u{93b}\x07\u{131}\x02\x02\u{786}\u{787}\x07\u{c5}\
	\x02\x02\u{787}\u{788}\x07\x04\x02\x02\u{788}\u{789}\x05\x78\x3d\x02\u{789}\
	\u{78a}\x07\x73\x02\x02\u{78a}\u{78b}\x05\x78\x3d\x02\u{78b}\u{78c}\x07\
	\x05\x02\x02\u{78c}\u{93b}\x03\x02\x02\x02\u{78d}\u{78e}\x07\x04\x02\x02\
	\u{78e}\u{791}\x05\x72\x3a\x02\u{78f}\u{790}\x07\x2c\x02\x02\u{790}\u{792}\
	\x05\x72\x3a\x02\u{791}\u{78f}\x03\x02\x02\x02\u{792}\u{793}\x03\x02\x02\
	\x02\u{793}\u{791}\x03\x02\x02\x02\u{793}\u{794}\x03\x02\x02\x02\u{794}\
	\u{795}\x03\x02\x02\x02\u{795}\u{796}\x07\x05\x02\x02\u{796}\u{93b}\x03\
	\x02\x02\x02\u{797}\u{798}\x07\u{de}\x02\x02\u{798}\u{799}\x07\x04\x02\x02\
	\u{799}\u{79e}\x05\x72\x3a\x02\u{79a}\u{79b}\x07\x2c\x02\x02\u{79b}\u{79d}\
	\x05\x72\x3a\x02\u{79c}\u{79a}\x03\x02\x02\x02\u{79d}\u{7a0}\x03\x02\x02\
	\x02\u{79e}\u{79c}\x03\x02\x02\x02\u{79e}\u{79f}\x03\x02\x02\x02\u{79f}\
	\u{7a1}\x03\x02\x02\x02\u{7a0}\u{79e}\x03\x02\x02\x02\u{7a1}\u{7a2}\x07\
	\x05\x02\x02\u{7a2}\u{93b}\x03\x02\x02\x02\u{7a3}\u{7a4}\x07\u{91}\x02\x02\
	\u{7a4}\u{7a6}\x07\x04\x02\x02\u{7a5}\u{7a7}\x05\x3c\x1f\x02\u{7a6}\u{7a5}\
	\x03\x02\x02\x02\u{7a6}\u{7a7}\x03\x02\x02\x02\u{7a7}\u{7a8}\x03\x02\x02\
	\x02\u{7a8}\u{7ab}\x05\x72\x3a\x02\u{7a9}\u{7aa}\x07\x2c\x02\x02\u{7aa}\
	\u{7ac}\x05\u{92}\x4a\x02\u{7ab}\u{7a9}\x03\x02\x02\x02\u{7ab}\u{7ac}\x03\
	\x02\x02\x02\u{7ac}\u{7b0}\x03\x02\x02\x02\u{7ad}\u{7ae}\x07\u{b1}\x02\x02\
	\u{7ae}\u{7af}\x07\u{bb}\x02\x02\u{7af}\u{7b1}\x05\x4c\x27\x02\u{7b0}\u{7ad}\
	\x03\x02\x02\x02\u{7b0}\u{7b1}\x03\x02\x02\x02\u{7b1}\u{7b2}\x03\x02\x02\
	\x02\u{7b2}\u{7b3}\x07\x05\x02\x02\u{7b3}\u{7b4}\x07\u{11e}\x02\x02\u{7b4}\
	\u{7b5}\x07\x6c\x02\x02\u{7b5}\u{7b6}\x07\x04\x02\x02\u{7b6}\u{7b7}\x07\
	\u{b6}\x02\x02\u{7b7}\u{7b8}\x07\x24\x02\x02\u{7b8}\u{7bd}\x05\x2a\x16\x02\
	\u{7b9}\u{7ba}\x07\x2c\x02\x02\u{7ba}\u{7bc}\x05\x2a\x16\x02\u{7bb}\u{7b9}\
	\x03\x02\x02\x02\u{7bc}\u{7bf}\x03\x02\x02\x02\u{7bd}\u{7bb}\x03\x02\x02\
	\x02\u{7bd}\u{7be}\x03\x02\x02\x02\u{7be}\u{7c0}\x03\x02\x02\x02\u{7bf}\
	\u{7bd}\x03\x02\x02\x02\u{7c0}\u{7c1}\x07\x05\x02\x02\u{7c1}\u{93b}\x03\
	\x02\x02\x02\u{7c2}\u{7c4}\x05\u{8e}\x48\x02\u{7c3}\u{7c2}\x03\x02\x02\x02\
	\u{7c3}\u{7c4}\x03\x02\x02\x02\u{7c4}\u{7c5}\x03\x02\x02\x02\u{7c5}\u{7c6}\
	\x05\u{cc}\x67\x02\u{7c6}\u{7ca}\x07\x04\x02\x02\u{7c7}\u{7c8}\x05\u{d8}\
	\x6d\x02\u{7c8}\u{7c9}\x07\x03\x02\x02\u{7c9}\u{7cb}\x03\x02\x02\x02\u{7ca}\
	\u{7c7}\x03\x02\x02\x02\u{7ca}\u{7cb}\x03\x02\x02\x02\u{7cb}\u{7cc}\x03\
	\x02\x02\x02\u{7cc}\u{7cd}\x07\u{12d}\x02\x02\u{7cd}\u{7cf}\x07\x05\x02\
	\x02\u{7ce}\u{7d0}\x05\u{aa}\x56\x02\u{7cf}\u{7ce}\x03\x02\x02\x02\u{7cf}\
	\u{7d0}\x03\x02\x02\x02\u{7d0}\u{7d2}\x03\x02\x02\x02\u{7d1}\u{7d3}\x05\
	\u{ae}\x58\x02\u{7d2}\u{7d1}\x03\x02\x02\x02\u{7d2}\u{7d3}\x03\x02\x02\x02\
	\u{7d3}\u{93b}\x03\x02\x02\x02\u{7d4}\u{7d6}\x05\u{8e}\x48\x02\u{7d5}\u{7d4}\
	\x03\x02\x02\x02\u{7d5}\u{7d6}\x03\x02\x02\x02\u{7d6}\u{7d7}\x03\x02\x02\
	\x02\u{7d7}\u{7d8}\x05\u{cc}\x67\x02\u{7d8}\u{7e4}\x07\x04\x02\x02\u{7d9}\
	\u{7db}\x05\x3c\x1f\x02\u{7da}\u{7d9}\x03\x02\x02\x02\u{7da}\u{7db}\x03\
	\x02\x02\x02\u{7db}\u{7dc}\x03\x02\x02\x02\u{7dc}\u{7e1}\x05\x72\x3a\x02\
	\u{7dd}\u{7de}\x07\x2c\x02\x02\u{7de}\u{7e0}\x05\x72\x3a\x02\u{7df}\u{7dd}\
	\x03\x02\x02\x02\u{7e0}\u{7e3}\x03\x02\x02\x02\u{7e1}\u{7df}\x03\x02\x02\
	\x02\u{7e1}\u{7e2}\x03\x02\x02\x02\u{7e2}\u{7e5}\x03\x02\x02\x02\u{7e3}\
	\u{7e1}\x03\x02\x02\x02\u{7e4}\u{7da}\x03\x02\x02\x02\u{7e4}\u{7e5}\x03\
	\x02\x02\x02\u{7e5}\u{7f0}\x03\x02\x02\x02\u{7e6}\u{7e7}\x07\u{b6}\x02\x02\
	\u{7e7}\u{7e8}\x07\x24\x02\x02\u{7e8}\u{7ed}\x05\x2a\x16\x02\u{7e9}\u{7ea}\
	\x07\x2c\x02\x02\u{7ea}\u{7ec}\x05\x2a\x16\x02\u{7eb}\u{7e9}\x03\x02\x02\
	\x02\u{7ec}\u{7ef}\x03\x02\x02\x02\u{7ed}\u{7eb}\x03\x02\x02\x02\u{7ed}\
	\u{7ee}\x03\x02\x02\x02\u{7ee}\u{7f1}\x03\x02\x02\x02\u{7ef}\u{7ed}\x03\
	\x02\x02\x02\u{7f0}\u{7e6}\x03\x02\x02\x02\u{7f0}\u{7f1}\x03\x02\x02\x02\
	\u{7f1}\u{7f2}\x03\x02\x02\x02\u{7f2}\u{7f4}\x07\x05\x02\x02\u{7f3}\u{7f5}\
	\x05\u{aa}\x56\x02\u{7f4}\u{7f3}\x03\x02\x02\x02\u{7f4}\u{7f5}\x03\x02\x02\
	\x02\u{7f5}\u{7fa}\x03\x02\x02\x02\u{7f6}\u{7f8}\x05\u{90}\x49\x02\u{7f7}\
	\u{7f6}\x03\x02\x02\x02\u{7f7}\u{7f8}\x03\x02\x02\x02\u{7f8}\u{7f9}\x03\
	\x02\x02\x02\u{7f9}\u{7fb}\x05\u{ae}\x58\x02\u{7fa}\u{7f7}\x03\x02\x02\x02\
	\u{7fa}\u{7fb}\x03\x02\x02\x02\u{7fb}\u{93b}\x03\x02\x02\x02\u{7fc}\u{7fd}\
	\x05\u{d8}\x6d\x02\u{7fd}\u{7fe}\x05\u{ae}\x58\x02\u{7fe}\u{93b}\x03\x02\
	\x02\x02\u{7ff}\u{800}\x05\u{d8}\x6d\x02\u{800}\u{801}\x07\x08\x02\x02\u{801}\
	\u{802}\x05\x72\x3a\x02\u{802}\u{93b}\x03\x02\x02\x02\u{803}\u{80c}\x07\
	\x04\x02\x02\u{804}\u{809}\x05\u{d8}\x6d\x02\u{805}\u{806}\x07\x2c\x02\x02\
	\u{806}\u{808}\x05\u{d8}\x6d\x02\u{807}\u{805}\x03\x02\x02\x02\u{808}\u{80b}\
	\x03\x02\x02\x02\u{809}\u{807}\x03\x02\x02\x02\u{809}\u{80a}\x03\x02\x02\
	\x02\u{80a}\u{80d}\x03\x02\x02\x02\u{80b}\u{809}\x03\x02\x02\x02\u{80c}\
	\u{804}\x03\x02\x02\x02\u{80c}\u{80d}\x03\x02\x02\x02\u{80d}\u{80e}\x03\
	\x02\x02\x02\u{80e}\u{80f}\x07\x05\x02\x02\u{80f}\u{810}\x07\x08\x02\x02\
	\u{810}\u{93b}\x05\x72\x3a\x02\u{811}\u{812}\x07\x04\x02\x02\u{812}\u{813}\
	\x05\x0e\x08\x02\u{813}\u{814}\x07\x05\x02\x02\u{814}\u{93b}\x03\x02\x02\
	\x02\u{815}\u{816}\x07\x59\x02\x02\u{816}\u{817}\x07\x04\x02\x02\u{817}\
	\u{818}\x05\x0e\x08\x02\u{818}\u{819}\x07\x05\x02\x02\u{819}\u{93b}\x03\
	\x02\x02\x02\u{81a}\u{81b}\x07\x27\x02\x02\u{81b}\u{81d}\x05\x72\x3a\x02\
	\u{81c}\u{81e}\x05\u{a8}\x55\x02\u{81d}\u{81c}\x03\x02\x02\x02\u{81e}\u{81f}\
	\x03\x02\x02\x02\u{81f}\u{81d}\x03\x02\x02\x02\u{81f}\u{820}\x03\x02\x02\
	\x02\u{820}\u{823}\x03\x02\x02\x02\u{821}\u{822}\x07\x50\x02\x02\u{822}\
	\u{824}\x05\x72\x3a\x02\u{823}\u{821}\x03\x02\x02\x02\u{823}\u{824}\x03\
	\x02\x02\x02\u{824}\u{825}\x03\x02\x02\x02\u{825}\u{826}\x07\x53\x02\x02\
	\u{826}\u{93b}\x03\x02\x02\x02\u{827}\u{829}\x07\x27\x02\x02\u{828}\u{82a}\
	\x05\u{a8}\x55\x02\u{829}\u{828}\x03\x02\x02\x02\u{82a}\u{82b}\x03\x02\x02\
	\x02\u{82b}\u{829}\x03\x02\x02\x02\u{82b}\u{82c}\x03\x02\x02\x02\u{82c}\
	\u{82f}\x03\x02\x02\x02\u{82d}\u{82e}\x07\x50\x02\x02\u{82e}\u{830}\x05\
	\x72\x3a\x02\u{82f}\u{82d}\x03\x02\x02\x02\u{82f}\u{830}\x03\x02\x02\x02\
	\u{830}\u{831}\x03\x02\x02\x02\u{831}\u{832}\x07\x53\x02\x02\u{832}\u{93b}\
	\x03\x02\x02\x02\u{833}\u{834}\x07\x28\x02\x02\u{834}\u{835}\x07\x04\x02\
	\x02\u{835}\u{836}\x05\x72\x3a\x02\u{836}\u{837}\x07\x1d\x02\x02\u{837}\
	\u{838}\x05\u{a2}\x52\x02\u{838}\u{839}\x07\x05\x02\x02\u{839}\u{93b}\x03\
	\x02\x02\x02\u{83a}\u{83b}\x07\u{102}\x02\x02\u{83b}\u{83c}\x07\x04\x02\
	\x02\u{83c}\u{83d}\x05\x72\x3a\x02\u{83d}\u{83e}\x07\x1d\x02\x02\u{83e}\
	\u{83f}\x05\u{a2}\x52\x02\u{83f}\u{840}\x07\x05\x02\x02\u{840}\u{93b}\x03\
	\x02\x02\x02\u{841}\u{842}\x07\x1c\x02\x02\u{842}\u{84b}\x07\x09\x02\x02\
	\u{843}\u{848}\x05\x72\x3a\x02\u{844}\u{845}\x07\x2c\x02\x02\u{845}\u{847}\
	\x05\x72\x3a\x02\u{846}\u{844}\x03\x02\x02\x02\u{847}\u{84a}\x03\x02\x02\
	\x02\u{848}\u{846}\x03\x02\x02\x02\u{848}\u{849}\x03\x02\x02\x02\u{849}\
	\u{84c}\x03\x02\x02\x02\u{84a}\u{848}\x03\x02\x02\x02\u{84b}\u{843}\x03\
	\x02\x02\x02\u{84b}\u{84c}\x03\x02\x02\x02\u{84c}\u{84d}\x03\x02\x02\x02\
	\u{84d}\u{93b}\x07\x0a\x02\x02\u{84e}\u{93b}\x05\u{d8}\x6d\x02\u{84f}\u{93b}\
	\x07\x39\x02\x02\u{850}\u{854}\x07\x3d\x02\x02\u{851}\u{852}\x07\x04\x02\
	\x02\u{852}\u{853}\x07\u{135}\x02\x02\u{853}\u{855}\x07\x05\x02\x02\u{854}\
	\u{851}\x03\x02\x02\x02\u{854}\u{855}\x03\x02\x02\x02\u{855}\u{93b}\x03\
	\x02\x02\x02\u{856}\u{85a}\x07\x3e\x02\x02\u{857}\u{858}\x07\x04\x02\x02\
	\u{858}\u{859}\x07\u{135}\x02\x02\u{859}\u{85b}\x07\x05\x02\x02\u{85a}\u{857}\
	\x03\x02\x02\x02\u{85a}\u{85b}\x03\x02\x02\x02\u{85b}\u{93b}\x03\x02\x02\
	\x02\u{85c}\u{860}\x07\u{93}\x02\x02\u{85d}\u{85e}\x07\x04\x02\x02\u{85e}\
	\u{85f}\x07\u{135}\x02\x02\u{85f}\u{861}\x07\x05\x02\x02\u{860}\u{85d}\x03\
	\x02\x02\x02\u{860}\u{861}\x03\x02\x02\x02\u{861}\u{93b}\x03\x02\x02\x02\
	\u{862}\u{866}\x07\u{94}\x02\x02\u{863}\u{864}\x07\x04\x02\x02\u{864}\u{865}\
	\x07\u{135}\x02\x02\u{865}\u{867}\x07\x05\x02\x02\u{866}\u{863}\x03\x02\
	\x02\x02\u{866}\u{867}\x03\x02\x02\x02\u{867}\u{93b}\x03\x02\x02\x02\u{868}\
	\u{93b}\x07\x3f\x02\x02\u{869}\u{93b}\x07\x38\x02\x02\u{86a}\u{93b}\x07\
	\x3c\x02\x02\u{86b}\u{93b}\x07\x3a\x02\x02\u{86c}\u{86d}\x07\u{ff}\x02\x02\
	\u{86d}\u{875}\x07\x04\x02\x02\u{86e}\u{870}\x05\x4a\x26\x02\u{86f}\u{86e}\
	\x03\x02\x02\x02\u{86f}\u{870}\x03\x02\x02\x02\u{870}\u{872}\x03\x02\x02\
	\x02\u{871}\u{873}\x05\x78\x3d\x02\u{872}\u{871}\x03\x02\x02\x02\u{872}\
	\u{873}\x03\x02\x02\x02\u{873}\u{874}\x03\x02\x02\x02\u{874}\u{876}\x07\
	\x64\x02\x02\u{875}\u{86f}\x03\x02\x02\x02\u{875}\u{876}\x03\x02\x02\x02\
	\u{876}\u{877}\x03\x02\x02\x02\u{877}\u{878}\x05\x78\x3d\x02\u{878}\u{879}\
	\x07\x05\x02\x02\u{879}\u{93b}\x03\x02\x02\x02\u{87a}\u{87b}\x07\u{ff}\x02\
	\x02\u{87b}\u{87c}\x07\x04\x02\x02\u{87c}\u{87d}\x05\x78\x3d\x02\u{87d}\
	\u{87e}\x07\x2c\x02\x02\u{87e}\u{87f}\x05\x78\x3d\x02\u{87f}\u{880}\x07\
	\x05\x02\x02\u{880}\u{93b}\x03\x02\x02\x02\u{881}\u{882}\x07\u{f1}\x02\x02\
	\u{882}\u{883}\x07\x04\x02\x02\u{883}\u{884}\x05\x78\x3d\x02\u{884}\u{885}\
	\x07\x64\x02\x02\u{885}\u{888}\x05\x78\x3d\x02\u{886}\u{887}\x07\x62\x02\
	\x02\u{887}\u{889}\x05\x78\x3d\x02\u{888}\u{886}\x03\x02\x02\x02\u{888}\
	\u{889}\x03\x02\x02\x02\u{889}\u{88a}\x03\x02\x02\x02\u{88a}\u{88b}\x07\
	\x05\x02\x02\u{88b}\u{93b}\x03\x02\x02\x02\u{88c}\u{88d}\x07\u{a8}\x02\x02\
	\u{88d}\u{88e}\x07\x04\x02\x02\u{88e}\u{891}\x05\x78\x3d\x02\u{88f}\u{890}\
	\x07\x2c\x02\x02\u{890}\u{892}\x05\u{a0}\x51\x02\u{891}\u{88f}\x03\x02\x02\
	\x02\u{891}\u{892}\x03\x02\x02\x02\u{892}\u{893}\x03\x02\x02\x02\u{893}\
	\u{894}\x07\x05\x02\x02\u{894}\u{93b}\x03\x02\x02\x02\u{895}\u{896}\x07\
	\x5b\x02\x02\u{896}\u{897}\x07\x04\x02\x02\u{897}\u{898}\x05\u{d8}\x6d\x02\
	\u{898}\u{899}\x07\x64\x02\x02\u{899}\u{89a}\x05\x78\x3d\x02\u{89a}\u{89b}\
	\x07\x05\x02\x02\u{89b}\u{93b}\x03\x02\x02\x02\u{89c}\u{89d}\x07\x04\x02\
	\x02\u{89d}\u{89e}\x05\x72\x3a\x02\u{89e}\u{89f}\x07\x05\x02\x02\u{89f}\
	\u{93b}\x03\x02\x02\x02\u{8a0}\u{8a1}\x07\x6d\x02\x02\u{8a1}\u{8aa}\x07\
	\x04\x02\x02\u{8a2}\u{8a7}\x05\u{cc}\x67\x02\u{8a3}\u{8a4}\x07\x2c\x02\x02\
	\u{8a4}\u{8a6}\x05\u{cc}\x67\x02\u{8a5}\u{8a3}\x03\x02\x02\x02\u{8a6}\u{8a9}\
	\x03\x02\x02\x02\u{8a7}\u{8a5}\x03\x02\x02\x02\u{8a7}\u{8a8}\x03\x02\x02\
	\x02\u{8a8}\u{8ab}\x03\x02\x02\x02\u{8a9}\u{8a7}\x03\x02\x02\x02\u{8aa}\
	\u{8a2}\x03\x02\x02\x02\u{8aa}\u{8ab}\x03\x02\x02\x02\u{8ab}\u{8ac}\x03\
	\x02\x02\x02\u{8ac}\u{93b}\x07\x05\x02\x02\u{8ad}\u{8ae}\x07\u{83}\x02\x02\
	\u{8ae}\u{8af}\x07\x04\x02\x02\u{8af}\u{8b4}\x05\x7c\x3f\x02\u{8b0}\u{8b1}\
	\x05\u{84}\x43\x02\u{8b1}\u{8b2}\x07\u{b1}\x02\x02\u{8b2}\u{8b3}\x07\x54\
	\x02\x02\u{8b3}\u{8b5}\x03\x02\x02\x02\u{8b4}\u{8b0}\x03\x02\x02\x02\u{8b4}\
	\u{8b5}\x03\x02\x02\x02\u{8b5}\u{8b6}\x03\x02\x02\x02\u{8b6}\u{8b7}\x07\
	\x05\x02\x02\u{8b7}\u{93b}\x03\x02\x02\x02\u{8b8}\u{8b9}\x07\u{86}\x02\x02\
	\u{8b9}\u{8ba}\x07\x04\x02\x02\u{8ba}\u{8bd}\x05\x7c\x3f\x02\u{8bb}\u{8bc}\
	\x07\u{d7}\x02\x02\u{8bc}\u{8be}\x05\u{a2}\x52\x02\u{8bd}\u{8bb}\x03\x02\
	\x02\x02\u{8bd}\u{8be}\x03\x02\x02\x02\u{8be}\u{8c3}\x03\x02\x02\x02\u{8bf}\
	\u{8c0}\x05\u{86}\x44\x02\u{8c0}\u{8c1}\x07\u{b1}\x02\x02\u{8c1}\u{8c2}\
	\x07\x51\x02\x02\u{8c2}\u{8c4}\x03\x02\x02\x02\u{8c3}\u{8bf}\x03\x02\x02\
	\x02\u{8c3}\u{8c4}\x03\x02\x02\x02\u{8c4}\u{8c9}\x03\x02\x02\x02\u{8c5}\
	\u{8c6}\x05\u{86}\x44\x02\u{8c6}\u{8c7}\x07\u{b1}\x02\x02\u{8c7}\u{8c8}\
	\x07\x54\x02\x02\u{8c8}\u{8ca}\x03\x02\x02\x02\u{8c9}\u{8c5}\x03\x02\x02\
	\x02\u{8c9}\u{8ca}\x03\x02\x02\x02\u{8ca}\u{8cb}\x03\x02\x02\x02\u{8cb}\
	\u{8cc}\x07\x05\x02\x02\u{8cc}\u{93b}\x03\x02\x02\x02\u{8cd}\u{8ce}\x07\
	\u{85}\x02\x02\u{8ce}\u{8cf}\x07\x04\x02\x02\u{8cf}\u{8d6}\x05\x7c\x3f\x02\
	\u{8d0}\u{8d1}\x07\u{d7}\x02\x02\u{8d1}\u{8d4}\x05\u{a2}\x52\x02\u{8d2}\
	\u{8d3}\x07\x63\x02\x02\u{8d3}\u{8d5}\x05\u{80}\x41\x02\u{8d4}\u{8d2}\x03\
	\x02\x02\x02\u{8d4}\u{8d5}\x03\x02\x02\x02\u{8d5}\u{8d7}\x03\x02\x02\x02\
	\u{8d6}\u{8d0}\x03\x02\x02\x02\u{8d6}\u{8d7}\x03\x02\x02\x02\u{8d7}\u{8db}\
	\x03\x02\x02\x02\u{8d8}\u{8d9}\x05\u{88}\x45\x02\u{8d9}\u{8da}\x07\u{121}\
	\x02\x02\u{8da}\u{8dc}\x03\x02\x02\x02\u{8db}\u{8d8}\x03\x02\x02\x02\u{8db}\
	\u{8dc}\x03\x02\x02\x02\u{8dc}\u{8e4}\x03\x02\x02\x02\u{8dd}\u{8de}\x09\
	\x13\x02\x02\u{8de}\u{8e2}\x07\u{cc}\x02\x02\u{8df}\u{8e0}\x07\u{b1}\x02\
	\x02\u{8e0}\u{8e1}\x07\u{e1}\x02\x02\u{8e1}\u{8e3}\x07\u{f7}\x02\x02\u{8e2}\
	\u{8df}\x03\x02\x02\x02\u{8e2}\u{8e3}\x03\x02\x02\x02\u{8e3}\u{8e5}\x03\
	\x02\x02\x02\u{8e4}\u{8dd}\x03\x02\x02\x02\u{8e4}\u{8e5}\x03\x02\x02\x02\
	\u{8e5}\u{8ea}\x03\x02\x02\x02\u{8e6}\u{8e7}\x05\u{8a}\x46\x02\u{8e7}\u{8e8}\
	\x07\u{b1}\x02\x02\u{8e8}\u{8e9}\x07\x51\x02\x02\u{8e9}\u{8eb}\x03\x02\x02\
	\x02\u{8ea}\u{8e6}\x03\x02\x02\x02\u{8ea}\u{8eb}\x03\x02\x02\x02\u{8eb}\
	\u{8f0}\x03\x02\x02\x02\u{8ec}\u{8ed}\x05\u{8a}\x46\x02\u{8ed}\u{8ee}\x07\
	\u{b1}\x02\x02\u{8ee}\u{8ef}\x07\x54\x02\x02\u{8ef}\u{8f1}\x03\x02\x02\x02\
	\u{8f0}\u{8ec}\x03\x02\x02\x02\u{8f0}\u{8f1}\x03\x02\x02\x02\u{8f1}\u{8f2}\
	\x03\x02\x02\x02\u{8f2}\u{8f3}\x07\x05\x02\x02\u{8f3}\u{93b}\x03\x02\x02\
	\x02\u{8f4}\u{8f5}\x07\u{84}\x02\x02\u{8f5}\u{912}\x07\x04\x02\x02\u{8f6}\
	\u{8fb}\x05\u{8c}\x47\x02\u{8f7}\u{8f8}\x07\x2c\x02\x02\u{8f8}\u{8fa}\x05\
	\u{8c}\x47\x02\u{8f9}\u{8f7}\x03\x02\x02\x02\u{8fa}\u{8fd}\x03\x02\x02\x02\
	\u{8fb}\u{8f9}\x03\x02\x02\x02\u{8fb}\u{8fc}\x03\x02\x02\x02\u{8fc}\u{904}\
	\x03\x02\x02\x02\u{8fd}\u{8fb}\x03\x02\x02\x02\u{8fe}\u{8ff}\x07\u{aa}\x02\
	\x02\u{8ff}\u{900}\x07\u{b1}\x02\x02\u{900}\u{905}\x07\u{aa}\x02\x02\u{901}\
	\u{902}\x07\x13\x02\x02\u{902}\u{903}\x07\u{b1}\x02\x02\u{903}\u{905}\x07\
	\u{aa}\x02\x02\u{904}\u{8fe}\x03\x02\x02\x02\u{904}\u{901}\x03\x02\x02\x02\
	\u{904}\u{905}\x03\x02\x02\x02\u{905}\u{910}\x03\x02\x02\x02\u{906}\u{907}\
	\x07\u{11d}\x02\x02\u{907}\u{909}\x07\u{109}\x02\x02\u{908}\u{90a}\x07\u{89}\
	\x02\x02\u{909}\u{908}\x03\x02\x02\x02\u{909}\u{90a}\x03\x02\x02\x02\u{90a}\
	\u{911}\x03\x02\x02\x02\u{90b}\u{90c}\x07\u{11f}\x02\x02\u{90c}\u{90e}\x07\
	\u{109}\x02\x02\u{90d}\u{90f}\x07\u{89}\x02\x02\u{90e}\u{90d}\x03\x02\x02\
	\x02\u{90e}\u{90f}\x03\x02\x02\x02\u{90f}\u{911}\x03\x02\x02\x02\u{910}\
	\u{906}\x03\x02\x02\x02\u{910}\u{90b}\x03\x02\x02\x02\u{910}\u{911}\x03\
	\x02\x02\x02\u{911}\u{913}\x03\x02\x02\x02\u{912}\u{8f6}\x03\x02\x02\x02\
	\u{912}\u{913}\x03\x02\x02\x02\u{913}\u{91a}\x03\x02\x02\x02\u{914}\u{915}\
	\x07\u{d7}\x02\x02\u{915}\u{918}\x05\u{a2}\x52\x02\u{916}\u{917}\x07\x63\
	\x02\x02\u{917}\u{919}\x05\u{80}\x41\x02\u{918}\u{916}\x03\x02\x02\x02\u{918}\
	\u{919}\x03\x02\x02\x02\u{919}\u{91b}\x03\x02\x02\x02\u{91a}\u{914}\x03\
	\x02\x02\x02\u{91a}\u{91b}\x03\x02\x02\x02\u{91b}\u{91c}\x03\x02\x02\x02\
	\u{91c}\u{93b}\x07\x05\x02\x02\u{91d}\u{91e}\x07\u{82}\x02\x02\u{91e}\u{92f}\
	\x07\x04\x02\x02\u{91f}\u{924}\x05\x7e\x40\x02\u{920}\u{921}\x07\x2c\x02\
	\x02\u{921}\u{923}\x05\x7e\x40\x02\u{922}\u{920}\x03\x02\x02\x02\u{923}\
	\u{926}\x03\x02\x02\x02\u{924}\u{922}\x03\x02\x02\x02\u{924}\u{925}\x03\
	\x02\x02\x02\u{925}\u{92d}\x03\x02\x02\x02\u{926}\u{924}\x03\x02\x02\x02\
	\u{927}\u{928}\x07\u{aa}\x02\x02\u{928}\u{929}\x07\u{b1}\x02\x02\u{929}\
	\u{92e}\x07\u{aa}\x02\x02\u{92a}\u{92b}\x07\x13\x02\x02\u{92b}\u{92c}\x07\
	\u{b1}\x02\x02\u{92c}\u{92e}\x07\u{aa}\x02\x02\u{92d}\u{927}\x03\x02\x02\
	\x02\u{92d}\u{92a}\x03\x02\x02\x02\u{92d}\u{92e}\x03\x02\x02\x02\u{92e}\
	\u{930}\x03\x02\x02\x02\u{92f}\u{91f}\x03\x02\x02\x02\u{92f}\u{930}\x03\
	\x02\x02\x02\u{930}\u{937}\x03\x02\x02\x02\u{931}\u{932}\x07\u{d7}\x02\x02\
	\u{932}\u{935}\x05\u{a2}\x52\x02\u{933}\u{934}\x07\x63\x02\x02\u{934}\u{936}\
	\x05\u{80}\x41\x02\u{935}\u{933}\x03\x02\x02\x02\u{935}\u{936}\x03\x02\x02\
	\x02\u{936}\u{938}\x03\x02\x02\x02\u{937}\u{931}\x03\x02\x02\x02\u{937}\
	\u{938}\x03\x02\x02\x02\u{938}\u{939}\x03\x02\x02\x02\u{939}\u{93b}\x07\
	\x05\x02\x02\u{93a}\u{778}\x03\x02\x02\x02\u{93a}\u{77a}\x03\x02\x02\x02\
	\u{93a}\u{77b}\x03\x02\x02\x02\u{93a}\u{77e}\x03\x02\x02\x02\u{93a}\u{781}\
	\x03\x02\x02\x02\u{93a}\u{782}\x03\x02\x02\x02\u{93a}\u{783}\x03\x02\x02\
	\x02\u{93a}\u{784}\x03\x02\x02\x02\u{93a}\u{785}\x03\x02\x02\x02\u{93a}\
	\u{786}\x03\x02\x02\x02\u{93a}\u{78d}\x03\x02\x02\x02\u{93a}\u{797}\x03\
	\x02\x02\x02\u{93a}\u{7a3}\x03\x02\x02\x02\u{93a}\u{7c3}\x03\x02\x02\x02\
	\u{93a}\u{7d5}\x03\x02\x02\x02\u{93a}\u{7fc}\x03\x02\x02\x02\u{93a}\u{7ff}\
	\x03\x02\x02\x02\u{93a}\u{803}\x03\x02\x02\x02\u{93a}\u{811}\x03\x02\x02\
	\x02\u{93a}\u{815}\x03\x02\x02\x02\u{93a}\u{81a}\x03\x02\x02\x02\u{93a}\
	\u{827}\x03\x02\x02\x02\u{93a}\u{833}\x03\x02\x02\x02\u{93a}\u{83a}\x03\
	\x02\x02\x02\u{93a}\u{841}\x03\x02\x02\x02\u{93a}\u{84e}\x03\x02\x02\x02\
	\u{93a}\u{84f}\x03\x02\x02\x02\u{93a}\u{850}\x03\x02\x02\x02\u{93a}\u{856}\
	\x03\x02\x02\x02\u{93a}\u{85c}\x03\x02\x02\x02\u{93a}\u{862}\x03\x02\x02\
	\x02\u{93a}\u{868}\x03\x02\x02\x02\u{93a}\u{869}\x03\x02\x02\x02\u{93a}\
	\u{86a}\x03\x02\x02\x02\u{93a}\u{86b}\x03\x02\x02\x02\u{93a}\u{86c}\x03\
	\x02\x02\x02\u{93a}\u{87a}\x03\x02\x02\x02\u{93a}\u{881}\x03\x02\x02\x02\
	\u{93a}\u{88c}\x03\x02\x02\x02\u{93a}\u{895}\x03\x02\x02\x02\u{93a}\u{89c}\
	\x03\x02\x02\x02\u{93a}\u{8a0}\x03\x02\x02\x02\u{93a}\u{8ad}\x03\x02\x02\
	\x02\u{93a}\u{8b8}\x03\x02\x02\x02\u{93a}\u{8cd}\x03\x02\x02\x02\u{93a}\
	\u{8f4}\x03\x02\x02\x02\u{93a}\u{91d}\x03\x02\x02\x02\u{93b}\u{946}\x03\
	\x02\x02\x02\u{93c}\u{93d}\x0c\x1a\x02\x02\u{93d}\u{93e}\x07\x09\x02\x02\
	\u{93e}\u{93f}\x05\x78\x3d\x02\u{93f}\u{940}\x07\x0a\x02\x02\u{940}\u{945}\
	\x03\x02\x02\x02\u{941}\u{942}\x0c\x18\x02\x02\u{942}\u{943}\x07\x03\x02\
	\x02\u{943}\u{945}\x05\u{d8}\x6d\x02\u{944}\u{93c}\x03\x02\x02\x02\u{944}\
	\u{941}\x03\x02\x02\x02\u{945}\u{948}\x03\x02\x02\x02\u{946}\u{944}\x03\
	\x02\x02\x02\u{946}\u{947}\x03\x02\x02\x02\u{947}\x7b\x03\x02\x02\x02\u{948}\
	\u{946}\x03\x02\x02\x02\u{949}\u{94a}\x05\x7e\x40\x02\u{94a}\u{94b}\x07\
	\x2c\x02\x02\u{94b}\u{955}\x05\u{92}\x4a\x02\u{94c}\u{94d}\x07\u{be}\x02\
	\x02\u{94d}\u{952}\x05\u{82}\x42\x02\u{94e}\u{94f}\x07\x2c\x02\x02\u{94f}\
	\u{951}\x05\u{82}\x42\x02\u{950}\u{94e}\x03\x02\x02\x02\u{951}\u{954}\x03\
	\x02\x02\x02\u{952}\u{950}\x03\x02\x02\x02\u{952}\u{953}\x03\x02\x02\x02\
	\u{953}\u{956}\x03\x02\x02\x02\u{954}\u{952}\x03\x02\x02\x02\u{955}\u{94c}\
	\x03\x02\x02\x02\u{955}\u{956}\x03\x02\x02\x02\u{956}\x7d\x03\x02\x02\x02\
	\u{957}\u{95a}\x05\x72\x3a\x02\u{958}\u{959}\x07\x63\x02\x02\u{959}\u{95b}\
	\x05\u{80}\x41\x02\u{95a}\u{958}\x03\x02\x02\x02\u{95a}\u{95b}\x03\x02\x02\
	\x02\u{95b}\x7f\x03\x02\x02\x02\u{95c}\u{95f}\x07\u{81}\x02\x02\u{95d}\u{95e}\
	\x07\x52\x02\x02\u{95e}\u{960}\x09\x14\x02\x02\u{95f}\u{95d}\x03\x02\x02\
	\x02\u{95f}\u{960}\x03\x02\x02\x02\u{960}\u{81}\x03\x02\x02\x02\u{961}\u{962}\
	\x05\x7e\x40\x02\u{962}\u{963}\x07\x1d\x02\x02\u{963}\u{964}\x05\u{d8}\x6d\
	\x02\u{964}\u{83}\x03\x02\x02\x02\u{965}\u{966}\x09\x15\x02\x02\u{966}\u{85}\
	\x03\x02\x02\x02\u{967}\u{96c}\x07\x54\x02\x02\u{968}\u{96c}\x07\u{aa}\x02\
	\x02\u{969}\u{96a}\x07\x44\x02\x02\u{96a}\u{96c}\x05\x72\x3a\x02\u{96b}\
	\u{967}\x03\x02\x02\x02\u{96b}\u{968}\x03\x02\x02\x02\u{96b}\u{969}\x03\
	\x02\x02\x02\u{96c}\u{87}\x03\x02\x02\x02\u{96d}\u{96f}\x07\u{11f}\x02\x02\
	\u{96e}\u{970}\x07\x1c\x02\x02\u{96f}\u{96e}\x03\x02\x02\x02\u{96f}\u{970}\
	\x03\x02\x02\x02\u{970}\u{979}\x03\x02\x02\x02\u{971}\u{973}\x07\u{11d}\
	\x02\x02\u{972}\u{974}\x09\x16\x02\x02\u{973}\u{972}\x03\x02\x02\x02\u{973}\
	\u{974}\x03\x02\x02\x02\u{974}\u{976}\x03\x02\x02\x02\u{975}\u{977}\x07\
	\x1c\x02\x02\u{976}\u{975}\x03\x02\x02\x02\u{976}\u{977}\x03\x02\x02\x02\
	\u{977}\u{979}\x03\x02\x02\x02\u{978}\u{96d}\x03\x02\x02\x02\u{978}\u{971}\
	\x03\x02\x02\x02\u{979}\u{89}\x03\x02\x02\x02\u{97a}\u{981}\x07\x54\x02\
	\x02\u{97b}\u{981}\x07\u{aa}\x02\x02\u{97c}\u{97d}\x07\x51\x02\x02\u{97d}\
	\u{981}\x07\x1c\x02\x02\u{97e}\u{97f}\x07\x51\x02\x02\u{97f}\u{981}\x07\
	\u{ad}\x02\x02\u{980}\u{97a}\x03\x02\x02\x02\u{980}\u{97b}\x03\x02\x02\x02\
	\u{980}\u{97c}\x03\x02\x02\x02\u{980}\u{97e}\x03\x02\x02\x02\u{981}\u{8b}\
	\x03\x02\x02\x02\u{982}\u{984}\x07\u{88}\x02\x02\u{983}\u{982}\x03\x02\x02\
	\x02\u{983}\u{984}\x03\x02\x02\x02\u{984}\u{985}\x03\x02\x02\x02\u{985}\
	\u{986}\x05\x72\x3a\x02\u{986}\u{987}\x07\u{115}\x02\x02\u{987}\u{988}\x05\
	\x7e\x40\x02\u{988}\u{98e}\x03\x02\x02\x02\u{989}\u{98a}\x05\x72\x3a\x02\
	\u{98a}\u{98b}\x07\x0b\x02\x02\u{98b}\u{98c}\x05\x7e\x40\x02\u{98c}\u{98e}\
	\x03\x02\x02\x02\u{98d}\u{983}\x03\x02\x02\x02\u{98d}\u{989}\x03\x02\x02\
	\x02\u{98e}\u{8d}\x03\x02\x02\x02\u{98f}\u{990}\x09\x17\x02\x02\u{990}\u{8f}\
	\x03\x02\x02\x02\u{991}\u{992}\x07\x72\x02\x02\u{992}\u{996}\x07\u{ac}\x02\
	\x02\u{993}\u{994}\x07\u{d5}\x02\x02\u{994}\u{996}\x07\u{ac}\x02\x02\u{995}\
	\u{991}\x03\x02\x02\x02\u{995}\u{993}\x03\x02\x02\x02\u{996}\u{91}\x03\x02\
	\x02\x02\u{997}\u{99e}\x07\u{132}\x02\x02\u{998}\u{99b}\x07\u{133}\x02\x02\
	\u{999}\u{99a}\x07\u{104}\x02\x02\u{99a}\u{99c}\x07\u{132}\x02\x02\u{99b}\
	\u{999}\x03\x02\x02\x02\u{99b}\u{99c}\x03\x02\x02\x02\u{99c}\u{99e}\x03\
	\x02\x02\x02\u{99d}\u{997}\x03\x02\x02\x02\u{99d}\u{998}\x03\x02\x02\x02\
	\u{99e}\u{93}\x03\x02\x02\x02\u{99f}\u{9a0}\x07\u{fa}\x02\x02\u{9a0}\u{9a1}\
	\x07\u{124}\x02\x02\u{9a1}\u{9a6}\x05\u{9c}\x4f\x02\u{9a2}\u{9a3}\x07\u{fa}\
	\x02\x02\u{9a3}\u{9a4}\x07\u{124}\x02\x02\u{9a4}\u{9a6}\x05\u{92}\x4a\x02\
	\u{9a5}\u{99f}\x03\x02\x02\x02\u{9a5}\u{9a2}\x03\x02\x02\x02\u{9a6}\u{95}\
	\x03\x02\x02\x02\u{9a7}\u{9a8}\x09\x18\x02\x02\u{9a8}\u{97}\x03\x02\x02\
	\x02\u{9a9}\u{9aa}\x09\x19\x02\x02\u{9aa}\u{99}\x03\x02\x02\x02\u{9ab}\u{9ac}\
	\x09\x1a\x02\x02\u{9ac}\u{9b}\x03\x02\x02\x02\u{9ad}\u{9af}\x07\x7a\x02\
	\x02\u{9ae}\u{9b0}\x09\x11\x02\x02\u{9af}\u{9ae}\x03\x02\x02\x02\u{9af}\
	\u{9b0}\x03\x02\x02\x02\u{9b0}\u{9b1}\x03\x02\x02\x02\u{9b1}\u{9b2}\x05\
	\u{92}\x4a\x02\u{9b2}\u{9b5}\x05\u{9e}\x50\x02\u{9b3}\u{9b4}\x07\u{fc}\x02\
	\x02\u{9b4}\u{9b6}\x05\u{9e}\x50\x02\u{9b5}\u{9b3}\x03\x02\x02\x02\u{9b5}\
	\u{9b6}\x03\x02\x02\x02\u{9b6}\u{9d}\x03\x02\x02\x02\u{9b7}\u{9b8}\x09\x1b\
	\x02\x02\u{9b8}\u{9f}\x03\x02\x02\x02\u{9b9}\u{9ba}\x09\x1c\x02\x02\u{9ba}\
	\u{a1}\x03\x02\x02\x02\u{9bb}\u{9bc}\x08\x52\x01\x02\u{9bc}\u{9bd}\x07\u{de}\
	\x02\x02\u{9bd}\u{9be}\x07\x04\x02\x02\u{9be}\u{9c3}\x05\u{a4}\x53\x02\u{9bf}\
	\u{9c0}\x07\x2c\x02\x02\u{9c0}\u{9c2}\x05\u{a4}\x53\x02\u{9c1}\u{9bf}\x03\
	\x02\x02\x02\u{9c2}\u{9c5}\x03\x02\x02\x02\u{9c3}\u{9c1}\x03\x02\x02\x02\
	\u{9c3}\u{9c4}\x03\x02\x02\x02\u{9c4}\u{9c6}\x03\x02\x02\x02\u{9c5}\u{9c3}\
	\x03\x02\x02\x02\u{9c6}\u{9c7}\x07\x05\x02\x02\u{9c7}\u{a17}\x03\x02\x02\
	\x02\u{9c8}\u{9c9}\x07\x7a\x02\x02\u{9c9}\u{9cc}\x05\u{9e}\x50\x02\u{9ca}\
	\u{9cb}\x07\u{fc}\x02\x02\u{9cb}\u{9cd}\x05\u{9e}\x50\x02\u{9cc}\u{9ca}\
	\x03\x02\x02\x02\u{9cc}\u{9cd}\x03\x02\x02\x02\u{9cd}\u{a17}\x03\x02\x02\
	\x02\u{9ce}\u{9d3}\x07\u{fb}\x02\x02\u{9cf}\u{9d0}\x07\x04\x02\x02\u{9d0}\
	\u{9d1}\x05\u{a6}\x54\x02\u{9d1}\u{9d2}\x07\x05\x02\x02\u{9d2}\u{9d4}\x03\
	\x02\x02\x02\u{9d3}\u{9cf}\x03\x02\x02\x02\u{9d3}\u{9d4}\x03\x02\x02\x02\
	\u{9d4}\u{9d8}\x03\x02\x02\x02\u{9d5}\u{9d6}\x07\u{11f}\x02\x02\u{9d6}\u{9d7}\
	\x07\u{fa}\x02\x02\u{9d7}\u{9d9}\x07\u{124}\x02\x02\u{9d8}\u{9d5}\x03\x02\
	\x02\x02\u{9d8}\u{9d9}\x03\x02\x02\x02\u{9d9}\u{a17}\x03\x02\x02\x02\u{9da}\
	\u{9df}\x07\u{fb}\x02\x02\u{9db}\u{9dc}\x07\x04\x02\x02\u{9dc}\u{9dd}\x05\
	\u{a6}\x54\x02\u{9dd}\u{9de}\x07\x05\x02\x02\u{9de}\u{9e0}\x03\x02\x02\x02\
	\u{9df}\u{9db}\x03\x02\x02\x02\u{9df}\u{9e0}\x03\x02\x02\x02\u{9e0}\u{9e1}\
	\x03\x02\x02\x02\u{9e1}\u{9e2}\x07\u{11d}\x02\x02\u{9e2}\u{9e3}\x07\u{fa}\
	\x02\x02\u{9e3}\u{a17}\x07\u{124}\x02\x02\u{9e4}\u{9e9}\x07\u{fa}\x02\x02\
	\u{9e5}\u{9e6}\x07\x04\x02\x02\u{9e6}\u{9e7}\x05\u{a6}\x54\x02\u{9e7}\u{9e8}\
	\x07\x05\x02\x02\u{9e8}\u{9ea}\x03\x02\x02\x02\u{9e9}\u{9e5}\x03\x02\x02\
	\x02\u{9e9}\u{9ea}\x03\x02\x02\x02\u{9ea}\u{9ee}\x03\x02\x02\x02\u{9eb}\
	\u{9ec}\x07\u{11f}\x02\x02\u{9ec}\u{9ed}\x07\u{fa}\x02\x02\u{9ed}\u{9ef}\
	\x07\u{124}\x02\x02\u{9ee}\u{9eb}\x03\x02\x02\x02\u{9ee}\u{9ef}\x03\x02\
	\x02\x02\u{9ef}\u{a17}\x03\x02\x02\x02\u{9f0}\u{9f5}\x07\u{fa}\x02\x02\u{9f1}\
	\u{9f2}\x07\x04\x02\x02\u{9f2}\u{9f3}\x05\u{a6}\x54\x02\u{9f3}\u{9f4}\x07\
	\x05\x02\x02\u{9f4}\u{9f6}\x03\x02\x02\x02\u{9f5}\u{9f1}\x03\x02\x02\x02\
	\u{9f5}\u{9f6}\x03\x02\x02\x02\u{9f6}\u{9f7}\x03\x02\x02\x02\u{9f7}\u{9f8}\
	\x07\u{11d}\x02\x02\u{9f8}\u{9f9}\x07\u{fa}\x02\x02\u{9f9}\u{a17}\x07\u{124}\
	\x02\x02\u{9fa}\u{9fb}\x07\x4e\x02\x02\u{9fb}\u{a17}\x07\u{c7}\x02\x02\u{9fc}\
	\u{9fd}\x07\x1c\x02\x02\u{9fd}\u{9fe}\x07\u{127}\x02\x02\u{9fe}\u{9ff}\x05\
	\u{a2}\x52\x02\u{9ff}\u{a00}\x07\u{129}\x02\x02\u{a00}\u{a17}\x03\x02\x02\
	\x02\u{a01}\u{a02}\x07\u{96}\x02\x02\u{a02}\u{a03}\x07\u{127}\x02\x02\u{a03}\
	\u{a04}\x05\u{a2}\x52\x02\u{a04}\u{a05}\x07\x2c\x02\x02\u{a05}\u{a06}\x05\
	\u{a2}\x52\x02\u{a06}\u{a07}\x07\u{129}\x02\x02\u{a07}\u{a17}\x03\x02\x02\
	\x02\u{a08}\u{a14}\x05\u{d8}\x6d\x02\u{a09}\u{a0a}\x07\x04\x02\x02\u{a0a}\
	\u{a0f}\x05\u{a6}\x54\x02\u{a0b}\u{a0c}\x07\x2c\x02\x02\u{a0c}\u{a0e}\x05\
	\u{a6}\x54\x02\u{a0d}\u{a0b}\x03\x02\x02\x02\u{a0e}\u{a11}\x03\x02\x02\x02\
	\u{a0f}\u{a0d}\x03\x02\x02\x02\u{a0f}\u{a10}\x03\x02\x02\x02\u{a10}\u{a12}\
	\x03\x02\x02\x02\u{a11}\u{a0f}\x03\x02\x02\x02\u{a12}\u{a13}\x07\x05\x02\
	\x02\u{a13}\u{a15}\x03\x02\x02\x02\u{a14}\u{a09}\x03\x02\x02\x02\u{a14}\
	\u{a15}\x03\x02\x02\x02\u{a15}\u{a17}\x03\x02\x02\x02\u{a16}\u{9bb}\x03\
	\x02\x02\x02\u{a16}\u{9c8}\x03\x02\x02\x02\u{a16}\u{9ce}\x03\x02\x02\x02\
	\u{a16}\u{9da}\x03\x02\x02\x02\u{a16}\u{9e4}\x03\x02\x02\x02\u{a16}\u{9f0}\
	\x03\x02\x02\x02\u{a16}\u{9fa}\x03\x02\x02\x02\u{a16}\u{9fc}\x03\x02\x02\
	\x02\u{a16}\u{a01}\x03\x02\x02\x02\u{a16}\u{a08}\x03\x02\x02\x02\u{a17}\
	\u{a21}\x03\x02\x02\x02\u{a18}\u{a19}\x0c\x04\x02\x02\u{a19}\u{a1d}\x07\
	\x1c\x02\x02\u{a1a}\u{a1b}\x07\x09\x02\x02\u{a1b}\u{a1c}\x07\u{135}\x02\
	\x02\u{a1c}\u{a1e}\x07\x0a\x02\x02\u{a1d}\u{a1a}\x03\x02\x02\x02\u{a1d}\
	\u{a1e}\x03\x02\x02\x02\u{a1e}\u{a20}\x03\x02\x02\x02\u{a1f}\u{a18}\x03\
	\x02\x02\x02\u{a20}\u{a23}\x03\x02\x02\x02\u{a21}\u{a1f}\x03\x02\x02\x02\
	\u{a21}\u{a22}\x03\x02\x02\x02\u{a22}\u{a3}\x03\x02\x02\x02\u{a23}\u{a21}\
	\x03\x02\x02\x02\u{a24}\u{a29}\x05\u{a2}\x52\x02\u{a25}\u{a26}\x05\u{d8}\
	\x6d\x02\u{a26}\u{a27}\x05\u{a2}\x52\x02\u{a27}\u{a29}\x03\x02\x02\x02\u{a28}\
	\u{a24}\x03\x02\x02\x02\u{a28}\u{a25}\x03\x02\x02\x02\u{a29}\u{a5}\x03\x02\
	\x02\x02\u{a2a}\u{a2d}\x07\u{135}\x02\x02\u{a2b}\u{a2d}\x05\u{a2}\x52\x02\
	\u{a2c}\u{a2a}\x03\x02\x02\x02\u{a2c}\u{a2b}\x03\x02\x02\x02\u{a2d}\u{a7}\
	\x03\x02\x02\x02\u{a2e}\u{a2f}\x07\u{11a}\x02\x02\u{a2f}\u{a30}\x05\x72\
	\x3a\x02\u{a30}\u{a31}\x07\u{f8}\x02\x02\u{a31}\u{a32}\x05\x72\x3a\x02\u{a32}\
	\u{a9}\x03\x02\x02\x02\u{a33}\u{a34}\x07\x5e\x02\x02\u{a34}\u{a35}\x07\x04\
	\x02\x02\u{a35}\u{a36}\x07\u{11b}\x02\x02\u{a36}\u{a37}\x05\x74\x3b\x02\
	\u{a37}\u{a38}\x07\x05\x02\x02\u{a38}\u{ab}\x03\x02\x02\x02\u{a39}\u{a3a}\
	\x07\u{11a}\x02\x02\u{a3a}\u{a3d}\x07\u{98}\x02\x02\u{a3b}\u{a3c}\x07\x1a\
	\x02\x02\u{a3c}\u{a3e}\x05\x72\x3a\x02\u{a3d}\u{a3b}\x03\x02\x02\x02\u{a3d}\
	\u{a3e}\x03\x02\x02\x02\u{a3e}\u{a3f}\x03\x02\x02\x02\u{a3f}\u{a40}\x07\
	\u{f8}\x02\x02\u{a40}\u{a41}\x07\u{10d}\x02\x02\u{a41}\u{a42}\x07\u{ea}\
	\x02\x02\u{a42}\u{a43}\x05\u{d8}\x6d\x02\u{a43}\u{a44}\x07\u{125}\x02\x02\
	\u{a44}\u{a4c}\x05\x72\x3a\x02\u{a45}\u{a46}\x07\x2c\x02\x02\u{a46}\u{a47}\
	\x05\u{d8}\x6d\x02\u{a47}\u{a48}\x07\u{125}\x02\x02\u{a48}\u{a49}\x05\x72\
	\x3a\x02\u{a49}\u{a4b}\x03\x02\x02\x02\u{a4a}\u{a45}\x03\x02\x02\x02\u{a4b}\
	\u{a4e}\x03\x02\x02\x02\u{a4c}\u{a4a}\x03\x02\x02\x02\u{a4c}\u{a4d}\x03\
	\x02\x02\x02\u{a4d}\u{a7a}\x03\x02\x02\x02\u{a4e}\u{a4c}\x03\x02\x02\x02\
	\u{a4f}\u{a50}\x07\u{11a}\x02\x02\u{a50}\u{a53}\x07\u{98}\x02\x02\u{a51}\
	\u{a52}\x07\x1a\x02\x02\u{a52}\u{a54}\x05\x72\x3a\x02\u{a53}\u{a51}\x03\
	\x02\x02\x02\u{a53}\u{a54}\x03\x02\x02\x02\u{a54}\u{a55}\x03\x02\x02\x02\
	\u{a55}\u{a56}\x07\u{f8}\x02\x02\u{a56}\u{a7a}\x07\x47\x02\x02\u{a57}\u{a58}\
	\x07\u{11a}\x02\x02\u{a58}\u{a59}\x07\u{a9}\x02\x02\u{a59}\u{a5c}\x07\u{98}\
	\x02\x02\u{a5a}\u{a5b}\x07\x1a\x02\x02\u{a5b}\u{a5d}\x05\x72\x3a\x02\u{a5c}\
	\u{a5a}\x03\x02\x02\x02\u{a5c}\u{a5d}\x03\x02\x02\x02\u{a5d}\u{a5e}\x03\
	\x02\x02\x02\u{a5e}\u{a5f}\x07\u{f8}\x02\x02\u{a5f}\u{a6b}\x07\x78\x02\x02\
	\u{a60}\u{a61}\x07\x04\x02\x02\u{a61}\u{a66}\x05\u{d8}\x6d\x02\u{a62}\u{a63}\
	\x07\x2c\x02\x02\u{a63}\u{a65}\x05\u{d8}\x6d\x02\u{a64}\u{a62}\x03\x02\x02\
	\x02\u{a65}\u{a68}\x03\x02\x02\x02\u{a66}\u{a64}\x03\x02\x02\x02\u{a66}\
	\u{a67}\x03\x02\x02\x02\u{a67}\u{a69}\x03\x02\x02\x02\u{a68}\u{a66}\x03\
	\x02\x02\x02\u{a69}\u{a6a}\x07\x05\x02\x02\u{a6a}\u{a6c}\x03\x02\x02\x02\
	\u{a6b}\u{a60}\x03\x02\x02\x02\u{a6b}\u{a6c}\x03\x02\x02\x02\u{a6c}\u{a6d}\
	\x03\x02\x02\x02\u{a6d}\u{a6e}\x07\u{116}\x02\x02\u{a6e}\u{a6f}\x07\x04\
	\x02\x02\u{a6f}\u{a74}\x05\x72\x3a\x02\u{a70}\u{a71}\x07\x2c\x02\x02\u{a71}\
	\u{a73}\x05\x72\x3a\x02\u{a72}\u{a70}\x03\x02\x02\x02\u{a73}\u{a76}\x03\
	\x02\x02\x02\u{a74}\u{a72}\x03\x02\x02\x02\u{a74}\u{a75}\x03\x02\x02\x02\
	\u{a75}\u{a77}\x03\x02\x02\x02\u{a76}\u{a74}\x03\x02\x02\x02\u{a77}\u{a78}\
	\x07\x05\x02\x02\u{a78}\u{a7a}\x03\x02\x02\x02\u{a79}\u{a39}\x03\x02\x02\
	\x02\u{a79}\u{a4f}\x03\x02\x02\x02\u{a79}\u{a57}\x03\x02\x02\x02\u{a7a}\
	\u{ad}\x03\x02\x02\x02\u{a7b}\u{a81}\x07\u{ba}\x02\x02\u{a7c}\u{a82}\x05\
	\u{d8}\x6d\x02\u{a7d}\u{a7e}\x07\x04\x02\x02\u{a7e}\u{a7f}\x05\x38\x1d\x02\
	\u{a7f}\u{a80}\x07\x05\x02\x02\u{a80}\u{a82}\x03\x02\x02\x02\u{a81}\u{a7c}\
	\x03\x02\x02\x02\u{a81}\u{a7d}\x03\x02\x02\x02\u{a82}\u{af}\x03\x02\x02\
	\x02\u{a83}\u{a84}\x07\u{9c}\x02\x02\u{a84}\u{a89}\x05\x52\x2a\x02\u{a85}\
	\u{a86}\x07\x2c\x02\x02\u{a86}\u{a88}\x05\x52\x2a\x02\u{a87}\u{a85}\x03\
	\x02\x02\x02\u{a88}\u{a8b}\x03\x02\x02\x02\u{a89}\u{a87}\x03\x02\x02\x02\
	\u{a89}\u{a8a}\x03\x02\x02\x02\u{a8a}\u{a8d}\x03\x02\x02\x02\u{a8b}\u{a89}\
	\x03\x02\x02\x02\u{a8c}\u{a83}\x03\x02\x02\x02\u{a8c}\u{a8d}\x03\x02\x02\
	\x02\u{a8d}\u{a8e}\x03\x02\x02\x02\u{a8e}\u{a92}\x05\u{b2}\x5a\x02\u{a8f}\
	\u{a90}\x07\x16\x02\x02\u{a90}\u{a91}\x07\u{97}\x02\x02\u{a91}\u{a93}\x05\
	\x58\x2d\x02\u{a92}\u{a8f}\x03\x02\x02\x02\u{a92}\u{a93}\x03\x02\x02\x02\
	\u{a93}\u{a95}\x03\x02\x02\x02\u{a94}\u{a96}\x09\x10\x02\x02\u{a95}\u{a94}\
	\x03\x02\x02\x02\u{a95}\u{a96}\x03\x02\x02\x02\u{a96}\u{a9c}\x03\x02\x02\
	\x02\u{a97}\u{a98}\x07\u{c1}\x02\x02\u{a98}\u{a99}\x07\x04\x02\x02\u{a99}\
	\u{a9a}\x05\u{b6}\x5c\x02\u{a9a}\u{a9b}\x07\x05\x02\x02\u{a9b}\u{a9d}\x03\
	\x02\x02\x02\u{a9c}\u{a97}\x03\x02\x02\x02\u{a9c}\u{a9d}\x03\x02\x02\x02\
	\u{a9d}\u{aa7}\x03\x02\x02\x02\u{a9e}\u{a9f}\x07\u{f0}\x02\x02\u{a9f}\u{aa4}\
	\x05\x5a\x2e\x02\u{aa0}\u{aa1}\x07\x2c\x02\x02\u{aa1}\u{aa3}\x05\x5a\x2e\
	\x02\u{aa2}\u{aa0}\x03\x02\x02\x02\u{aa3}\u{aa6}\x03\x02\x02\x02\u{aa4}\
	\u{aa2}\x03\x02\x02\x02\u{aa4}\u{aa5}\x03\x02\x02\x02\u{aa5}\u{aa8}\x03\
	\x02\x02\x02\u{aa6}\u{aa4}\x03\x02\x02\x02\u{aa7}\u{a9e}\x03\x02\x02\x02\
	\u{aa7}\u{aa8}\x03\x02\x02\x02\u{aa8}\u{ab2}\x03\x02\x02\x02\u{aa9}\u{aaa}\
	\x07\x45\x02\x02\u{aaa}\u{aaf}\x05\x5c\x2f\x02\u{aab}\u{aac}\x07\x2c\x02\
	\x02\u{aac}\u{aae}\x05\x5c\x2f\x02\u{aad}\u{aab}\x03\x02\x02\x02\u{aae}\
	\u{ab1}\x03\x02\x02\x02\u{aaf}\u{aad}\x03\x02\x02\x02\u{aaf}\u{ab0}\x03\
	\x02\x02\x02\u{ab0}\u{ab3}\x03\x02\x02\x02\u{ab1}\u{aaf}\x03\x02\x02\x02\
	\u{ab2}\u{aa9}\x03\x02\x02\x02\u{ab2}\u{ab3}\x03\x02\x02\x02\u{ab3}\u{b1}\
	\x03\x02\x02\x02\u{ab4}\u{ab5}\x07\u{cd}\x02\x02\u{ab5}\u{acd}\x05\u{b4}\
	\x5b\x02\u{ab6}\u{ab7}\x07\u{df}\x02\x02\u{ab7}\u{acd}\x05\u{b4}\x5b\x02\
	\u{ab8}\u{ab9}\x07\x6e\x02\x02\u{ab9}\u{acd}\x05\u{b4}\x5b\x02\u{aba}\u{abb}\
	\x07\u{cd}\x02\x02\u{abb}\u{abc}\x07\x22\x02\x02\u{abc}\u{abd}\x05\u{b4}\
	\x5b\x02\u{abd}\u{abe}\x07\x1a\x02\x02\u{abe}\u{abf}\x05\u{b4}\x5b\x02\u{abf}\
	\u{acd}\x03\x02\x02\x02\u{ac0}\u{ac1}\x07\u{df}\x02\x02\u{ac1}\u{ac2}\x07\
	\x22\x02\x02\u{ac2}\u{ac3}\x05\u{b4}\x5b\x02\u{ac3}\u{ac4}\x07\x1a\x02\x02\
	\u{ac4}\u{ac5}\x05\u{b4}\x5b\x02\u{ac5}\u{acd}\x03\x02\x02\x02\u{ac6}\u{ac7}\
	\x07\x6e\x02\x02\u{ac7}\u{ac8}\x07\x22\x02\x02\u{ac8}\u{ac9}\x05\u{b4}\x5b\
	\x02\u{ac9}\u{aca}\x07\x1a\x02\x02\u{aca}\u{acb}\x05\u{b4}\x5b\x02\u{acb}\
	\u{acd}\x03\x02\x02\x02\u{acc}\u{ab4}\x03\x02\x02\x02\u{acc}\u{ab6}\x03\
	\x02\x02\x02\u{acc}\u{ab8}\x03\x02\x02\x02\u{acc}\u{aba}\x03\x02\x02\x02\
	\u{acc}\u{ac0}\x03\x02\x02\x02\u{acc}\u{ac6}\x03\x02\x02\x02\u{acd}\u{b3}\
	\x03\x02\x02\x02\u{ace}\u{acf}\x07\u{105}\x02\x02\u{acf}\u{ad8}\x07\u{c6}\
	\x02\x02\u{ad0}\u{ad1}\x07\u{105}\x02\x02\u{ad1}\u{ad8}\x07\x61\x02\x02\
	\u{ad2}\u{ad3}\x07\x37\x02\x02\u{ad3}\u{ad8}\x07\u{de}\x02\x02\u{ad4}\u{ad5}\
	\x05\x72\x3a\x02\u{ad5}\u{ad6}\x09\x1d\x02\x02\u{ad6}\u{ad8}\x03\x02\x02\
	\x02\u{ad7}\u{ace}\x03\x02\x02\x02\u{ad7}\u{ad0}\x03\x02\x02\x02\u{ad7}\
	\u{ad2}\x03\x02\x02\x02\u{ad7}\u{ad4}\x03\x02\x02\x02\u{ad8}\u{b5}\x03\x02\
	\x02\x02\u{ad9}\u{ada}\x08\x5c\x01\x02\u{ada}\u{adc}\x05\u{b8}\x5d\x02\u{adb}\
	\u{add}\x05\u{ba}\x5e\x02\u{adc}\u{adb}\x03\x02\x02\x02\u{adc}\u{add}\x03\
	\x02\x02\x02\u{add}\u{ae5}\x03\x02\x02\x02\u{ade}\u{adf}\x0c\x04\x02\x02\
	\u{adf}\u{ae4}\x05\u{b6}\x5c\x05\u{ae0}\u{ae1}\x0c\x03\x02\x02\u{ae1}\u{ae2}\
	\x07\x0c\x02\x02\u{ae2}\u{ae4}\x05\u{b6}\x5c\x04\u{ae3}\u{ade}\x03\x02\x02\
	\x02\u{ae3}\u{ae0}\x03\x02\x02\x02\u{ae4}\u{ae7}\x03\x02\x02\x02\u{ae5}\
	\u{ae3}\x03\x02\x02\x02\u{ae5}\u{ae6}\x03\x02\x02\x02\u{ae6}\u{b7}\x03\x02\
	\x02\x02\u{ae7}\u{ae5}\x03\x02\x02\x02\u{ae8}\u{b02}\x05\u{d8}\x6d\x02\u{ae9}\
	\u{aea}\x07\x04\x02\x02\u{aea}\u{b02}\x07\x05\x02\x02\u{aeb}\u{aec}\x07\
	\u{c4}\x02\x02\u{aec}\u{aed}\x07\x04\x02\x02\u{aed}\u{af2}\x05\u{b6}\x5c\
	\x02\u{aee}\u{aef}\x07\x2c\x02\x02\u{aef}\u{af1}\x05\u{b6}\x5c\x02\u{af0}\
	\u{aee}\x03\x02\x02\x02\u{af1}\u{af4}\x03\x02\x02\x02\u{af2}\u{af0}\x03\
	\x02\x02\x02\u{af2}\u{af3}\x03\x02\x02\x02\u{af3}\u{af5}\x03\x02\x02\x02\
	\u{af4}\u{af2}\x03\x02\x02\x02\u{af5}\u{af6}\x07\x05\x02\x02\u{af6}\u{b02}\
	\x03\x02\x02\x02\u{af7}\u{af8}\x07\x04\x02\x02\u{af8}\u{af9}\x05\u{b6}\x5c\
	\x02\u{af9}\u{afa}\x07\x05\x02\x02\u{afa}\u{b02}\x03\x02\x02\x02\u{afb}\
	\u{b02}\x07\x0d\x02\x02\u{afc}\u{b02}\x07\x0e\x02\x02\u{afd}\u{afe}\x07\
	\x0f\x02\x02\u{afe}\u{aff}\x05\u{b6}\x5c\x02\u{aff}\u{b00}\x07\x10\x02\x02\
	\u{b00}\u{b02}\x03\x02\x02\x02\u{b01}\u{ae8}\x03\x02\x02\x02\u{b01}\u{ae9}\
	\x03\x02\x02\x02\u{b01}\u{aeb}\x03\x02\x02\x02\u{b01}\u{af7}\x03\x02\x02\
	\x02\u{b01}\u{afb}\x03\x02\x02\x02\u{b01}\u{afc}\x03\x02\x02\x02\u{b01}\
	\u{afd}\x03\x02\x02\x02\u{b02}\u{b9}\x03\x02\x02\x02\u{b03}\u{b05}\x07\u{12d}\
	\x02\x02\u{b04}\u{b06}\x07\u{131}\x02\x02\u{b05}\u{b04}\x03\x02\x02\x02\
	\u{b05}\u{b06}\x03\x02\x02\x02\u{b06}\u{b22}\x03\x02\x02\x02\u{b07}\u{b09}\
	\x07\u{12b}\x02\x02\u{b08}\u{b0a}\x07\u{131}\x02\x02\u{b09}\u{b08}\x03\x02\
	\x02\x02\u{b09}\u{b0a}\x03\x02\x02\x02\u{b0a}\u{b22}\x03\x02\x02\x02\u{b0b}\
	\u{b0d}\x07\u{131}\x02\x02\u{b0c}\u{b0e}\x07\u{131}\x02\x02\u{b0d}\u{b0c}\
	\x03\x02\x02\x02\u{b0d}\u{b0e}\x03\x02\x02\x02\u{b0e}\u{b22}\x03\x02\x02\
	\x02\u{b0f}\u{b10}\x07\x11\x02\x02\u{b10}\u{b11}\x07\u{135}\x02\x02\u{b11}\
	\u{b13}\x07\x12\x02\x02\u{b12}\u{b14}\x07\u{131}\x02\x02\u{b13}\u{b12}\x03\
	\x02\x02\x02\u{b13}\u{b14}\x03\x02\x02\x02\u{b14}\u{b22}\x03\x02\x02\x02\
	\u{b15}\u{b17}\x07\x11\x02\x02\u{b16}\u{b18}\x07\u{135}\x02\x02\u{b17}\u{b16}\
	\x03\x02\x02\x02\u{b17}\u{b18}\x03\x02\x02\x02\u{b18}\u{b19}\x03\x02\x02\
	\x02\u{b19}\u{b1b}\x07\x2c\x02\x02\u{b1a}\u{b1c}\x07\u{135}\x02\x02\u{b1b}\
	\u{b1a}\x03\x02\x02\x02\u{b1b}\u{b1c}\x03\x02\x02\x02\u{b1c}\u{b1d}\x03\
	\x02\x02\x02\u{b1d}\u{b1f}\x07\x12\x02\x02\u{b1e}\u{b20}\x07\u{131}\x02\
	\x02\u{b1f}\u{b1e}\x03\x02\x02\x02\u{b1f}\u{b20}\x03\x02\x02\x02\u{b20}\
	\u{b22}\x03\x02\x02\x02\u{b21}\u{b03}\x03\x02\x02\x02\u{b21}\u{b07}\x03\
	\x02\x02\x02\u{b21}\u{b0b}\x03\x02\x02\x02\u{b21}\u{b0f}\x03\x02\x02\x02\
	\u{b21}\u{b15}\x03\x02\x02\x02\u{b22}\u{bb}\x03\x02\x02\x02\u{b23}\u{b24}\
	\x05\u{d8}\x6d\x02\u{b24}\u{b25}\x07\u{125}\x02\x02\u{b25}\u{b26}\x05\x72\
	\x3a\x02\u{b26}\u{bd}\x03\x02\x02\x02\u{b27}\u{b28}\x07\x63\x02\x02\u{b28}\
	\u{b2c}\x09\x1e\x02\x02\u{b29}\u{b2a}\x07\u{103}\x02\x02\u{b2a}\u{b2c}\x09\
	\x1f\x02\x02\u{b2b}\u{b27}\x03\x02\x02\x02\u{b2b}\u{b29}\x03\x02\x02\x02\
	\u{b2c}\u{bf}\x03\x02\x02\x02\u{b2d}\u{b2e}\x07\x7f\x02\x02\u{b2e}\u{b2f}\
	\x07\u{8e}\x02\x02\u{b2f}\u{b33}\x05\u{c2}\x62\x02\u{b30}\u{b31}\x07\u{ce}\
	\x02\x02\u{b31}\u{b33}\x09\x20\x02\x02\u{b32}\u{b2d}\x03\x02\x02\x02\u{b32}\
	\u{b30}\x03\x02\x02\x02\u{b33}\u{c1}\x03\x02\x02\x02\u{b34}\u{b35}\x07\u{ce}\
	\x02\x02\u{b35}\u{b3c}\x07\u{106}\x02\x02\u{b36}\u{b37}\x07\u{ce}\x02\x02\
	\u{b37}\u{b3c}\x07\x2f\x02\x02\u{b38}\u{b39}\x07\u{d2}\x02\x02\u{b39}\u{b3c}\
	\x07\u{ce}\x02\x02\u{b3a}\u{b3c}\x07\u{e8}\x02\x02\u{b3b}\u{b34}\x03\x02\
	\x02\x02\u{b3b}\u{b36}\x03\x02\x02\x02\u{b3b}\u{b38}\x03\x02\x02\x02\u{b3b}\
	\u{b3a}\x03\x02\x02\x02\u{b3c}\u{c3}\x03\x02\x02\x02\u{b3d}\u{b43}\x05\x72\
	\x3a\x02\u{b3e}\u{b3f}\x05\u{d8}\x6d\x02\u{b3f}\u{b40}\x07\x07\x02\x02\u{b40}\
	\u{b41}\x05\x72\x3a\x02\u{b41}\u{b43}\x03\x02\x02\x02\u{b42}\u{b3d}\x03\
	\x02\x02\x02\u{b42}\u{b3e}\x03\x02\x02\x02\u{b43}\u{c5}\x03\x02\x02\x02\
	\u{b44}\u{b45}\x05\u{d8}\x6d\x02\u{b45}\u{b46}\x07\x03\x02\x02\u{b46}\u{b47}\
	\x05\u{d8}\x6d\x02\u{b47}\u{b4a}\x03\x02\x02\x02\u{b48}\u{b4a}\x05\u{d8}\
	\x6d\x02\u{b49}\u{b44}\x03\x02\x02\x02\u{b49}\u{b48}\x03\x02\x02\x02\u{b4a}\
	\u{c7}\x03\x02\x02\x02\u{b4b}\u{b50}\x05\u{c6}\x64\x02\u{b4c}\u{b4d}\x07\
	\x2c\x02\x02\u{b4d}\u{b4f}\x05\u{c6}\x64\x02\u{b4e}\u{b4c}\x03\x02\x02\x02\
	\u{b4f}\u{b52}\x03\x02\x02\x02\u{b50}\u{b4e}\x03\x02\x02\x02\u{b50}\u{b51}\
	\x03\x02\x02\x02\u{b51}\u{c9}\x03\x02\x02\x02\u{b52}\u{b50}\x03\x02\x02\
	\x02\u{b53}\u{b54}\x09\x21\x02\x02\u{b54}\u{cb}\x03\x02\x02\x02\u{b55}\u{b5a}\
	\x05\u{d8}\x6d\x02\u{b56}\u{b57}\x07\x03\x02\x02\u{b57}\u{b59}\x05\u{d8}\
	\x6d\x02\u{b58}\u{b56}\x03\x02\x02\x02\u{b59}\u{b5c}\x03\x02\x02\x02\u{b5a}\
	\u{b58}\x03\x02\x02\x02\u{b5a}\u{b5b}\x03\x02\x02\x02\u{b5b}\u{cd}\x03\x02\
	\x02\x02\u{b5c}\u{b5a}\x03\x02\x02\x02\u{b5d}\u{b5e}\x07\x62\x02\x02\u{b5e}\
	\u{b5f}\x05\u{d0}\x69\x02\u{b5f}\u{b60}\x07\x1d\x02\x02\u{b60}\u{b61}\x07\
	\u{ae}\x02\x02\u{b61}\u{b62}\x05\x78\x3d\x02\u{b62}\u{cf}\x03\x02\x02\x02\
	\u{b63}\u{b64}\x09\x22\x02\x02\u{b64}\u{d1}\x03\x02\x02\x02\u{b65}\u{b69}\
	\x05\u{d4}\x6b\x02\u{b66}\u{b69}\x07\x3f\x02\x02\u{b67}\u{b69}\x07\x3b\x02\
	\x02\u{b68}\u{b65}\x03\x02\x02\x02\u{b68}\u{b66}\x03\x02\x02\x02\u{b68}\
	\u{b67}\x03\x02\x02\x02\u{b69}\u{d3}\x03\x02\x02\x02\u{b6a}\u{b70}\x05\u{d8}\
	\x6d\x02\u{b6b}\u{b6c}\x07\u{10f}\x02\x02\u{b6c}\u{b70}\x05\u{d8}\x6d\x02\
	\u{b6d}\u{b6e}\x07\u{da}\x02\x02\u{b6e}\u{b70}\x05\u{d8}\x6d\x02\u{b6f}\
	\u{b6a}\x03\x02\x02\x02\u{b6f}\u{b6b}\x03\x02\x02\x02\u{b6f}\u{b6d}\x03\
	\x02\x02\x02\u{b70}\u{d5}\x03\x02\x02\x02\u{b71}\u{b76}\x05\u{d8}\x6d\x02\
	\u{b72}\u{b73}\x07\x2c\x02\x02\u{b73}\u{b75}\x05\u{d8}\x6d\x02\u{b74}\u{b72}\
	\x03\x02\x02\x02\u{b75}\u{b78}\x03\x02\x02\x02\u{b76}\u{b74}\x03\x02\x02\
	\x02\u{b76}\u{b77}\x03\x02\x02\x02\u{b77}\u{d7}\x03\x02\x02\x02\u{b78}\u{b76}\
	\x03\x02\x02\x02\u{b79}\u{b7f}\x07\u{138}\x02\x02\u{b7a}\u{b7f}\x07\u{13a}\
	\x02\x02\u{b7b}\u{b7f}\x05\u{dc}\x6f\x02\u{b7c}\u{b7f}\x07\u{13b}\x02\x02\
	\u{b7d}\u{b7f}\x07\u{139}\x02\x02\u{b7e}\u{b79}\x03\x02\x02\x02\u{b7e}\u{b7a}\
	\x03\x02\x02\x02\u{b7e}\u{b7b}\x03\x02\x02\x02\u{b7e}\u{b7c}\x03\x02\x02\
	\x02\u{b7e}\u{b7d}\x03\x02\x02\x02\u{b7f}\u{d9}\x03\x02\x02\x02\u{b80}\u{b82}\
	\x07\u{12c}\x02\x02\u{b81}\u{b80}\x03\x02\x02\x02\u{b81}\u{b82}\x03\x02\
	\x02\x02\u{b82}\u{b83}\x03\x02\x02\x02\u{b83}\u{b8d}\x07\u{136}\x02\x02\
	\u{b84}\u{b86}\x07\u{12c}\x02\x02\u{b85}\u{b84}\x03\x02\x02\x02\u{b85}\u{b86}\
	\x03\x02\x02\x02\u{b86}\u{b87}\x03\x02\x02\x02\u{b87}\u{b8d}\x07\u{137}\
	\x02\x02\u{b88}\u{b8a}\x07\u{12c}\x02\x02\u{b89}\u{b88}\x03\x02\x02\x02\
	\u{b89}\u{b8a}\x03\x02\x02\x02\u{b8a}\u{b8b}\x03\x02\x02\x02\u{b8b}\u{b8d}\
	\x07\u{135}\x02\x02\u{b8c}\u{b81}\x03\x02\x02\x02\u{b8c}\u{b85}\x03\x02\
	\x02\x02\u{b8c}\u{b89}\x03\x02\x02\x02\u{b8d}\u{db}\x03\x02\x02\x02\u{b8e}\
	\u{b8f}\x09\x23\x02\x02\u{b8f}\u{dd}\x03\x02\x02\x02\u{18d}\u{fa}\u{ff}\
	\u{103}\u{109}\u{10d}\u{122}\u{126}\u{12a}\u{12e}\u{136}\u{13a}\u{13d}\u{144}\
	\u{14d}\u{152}\u{156}\u{15a}\u{160}\u{167}\u{170}\u{17c}\u{185}\u{18e}\u{194}\
	\u{19f}\u{1a7}\u{1af}\u{1b6}\u{1c0}\u{1c7}\u{1cf}\u{1f3}\u{1f6}\u{1f9}\u{1fd}\
	\u{203}\u{208}\u{20f}\u{215}\u{219}\u{21d}\u{225}\u{22b}\u{22f}\u{23d}\u{245}\
	\u{258}\u{271}\u{274}\u{27e}\u{282}\u{289}\u{293}\u{299}\u{29e}\u{2a2}\u{2a8}\
	\u{2b1}\u{2b7}\u{2bb}\u{2c2}\u{2c6}\u{2ce}\u{2d3}\u{2d7}\u{2df}\u{2e7}\u{2ec}\
	\u{2f0}\u{2fa}\u{301}\u{306}\u{30a}\u{314}\u{317}\u{320}\u{325}\u{32b}\u{343}\
	\u{349}\u{34b}\u{351}\u{357}\u{359}\u{361}\u{363}\u{369}\u{36f}\u{371}\u{380}\
	\u{385}\u{38c}\u{398}\u{39a}\u{3a2}\u{3a4}\u{3b6}\u{3b9}\u{3bd}\u{3c1}\u{3d3}\
	\u{3d6}\u{3e6}\u{3f0}\u{3f5}\u{3fb}\u{3fe}\u{407}\u{409}\u{40c}\u{412}\u{419}\
	\u{41e}\u{424}\u{428}\u{42c}\u{432}\u{43d}\u{446}\u{450}\u{453}\u{458}\u{45a}\
	\u{461}\u{467}\u{469}\u{46d}\u{477}\u{47d}\u{480}\u{482}\u{48e}\u{495}\u{499}\
	\u{49d}\u{4a1}\u{4aa}\u{4ad}\u{4b1}\u{4b6}\u{4ba}\u{4c2}\u{4c5}\u{4cc}\u{4d0}\
	\u{4d7}\u{4e2}\u{4e5}\u{4ef}\u{4f2}\u{4fd}\u{502}\u{50a}\u{50d}\u{511}\u{51a}\
	\u{523}\u{526}\u{52f}\u{532}\u{535}\u{539}\u{544}\u{547}\u{54e}\u{551}\u{564}\
	\u{568}\u{56c}\u{570}\u{574}\u{578}\u{57a}\u{585}\u{58a}\u{593}\u{59c}\u{59f}\
	\u{5a5}\u{5b1}\u{5b4}\u{5bd}\u{5c0}\u{5c8}\u{5cb}\u{5ce}\u{5d3}\u{5d6}\u{5e2}\
	\u{5e5}\u{5ed}\u{5f2}\u{5f6}\u{5f8}\u{5fa}\u{609}\u{60b}\u{616}\u{62b}\u{635}\
	\u{640}\u{644}\u{646}\u{64e}\u{655}\u{662}\u{668}\u{678}\u{681}\u{684}\u{68c}\
	\u{68f}\u{696}\u{69b}\u{6a6}\u{6a9}\u{6ad}\u{6af}\u{6b7}\u{6c1}\u{6c7}\u{6c9}\
	\u{6d0}\u{6d4}\u{6d6}\u{6dd}\u{6e1}\u{6e3}\u{6e5}\u{6ee}\u{6f9}\u{6fd}\u{707}\
	\u{711}\u{715}\u{71d}\u{71f}\u{72c}\u{734}\u{73d}\u{743}\u{74b}\u{751}\u{755}\
	\u{75a}\u{75f}\u{765}\u{773}\u{775}\u{793}\u{79e}\u{7a6}\u{7ab}\u{7b0}\u{7bd}\
	\u{7c3}\u{7ca}\u{7cf}\u{7d2}\u{7d5}\u{7da}\u{7e1}\u{7e4}\u{7ed}\u{7f0}\u{7f4}\
	\u{7f7}\u{7fa}\u{809}\u{80c}\u{81f}\u{823}\u{82b}\u{82f}\u{848}\u{84b}\u{854}\
	\u{85a}\u{860}\u{866}\u{86f}\u{872}\u{875}\u{888}\u{891}\u{8a7}\u{8aa}\u{8b4}\
	\u{8bd}\u{8c3}\u{8c9}\u{8d4}\u{8d6}\u{8db}\u{8e2}\u{8e4}\u{8ea}\u{8f0}\u{8fb}\
	\u{904}\u{909}\u{90e}\u{910}\u{912}\u{918}\u{91a}\u{924}\u{92d}\u{92f}\u{935}\
	\u{937}\u{93a}\u{944}\u{946}\u{952}\u{955}\u{95a}\u{95f}\u{96b}\u{96f}\u{973}\
	\u{976}\u{978}\u{980}\u{983}\u{98d}\u{995}\u{99b}\u{99d}\u{9a5}\u{9af}\u{9b5}\
	\u{9c3}\u{9cc}\u{9d3}\u{9d8}\u{9df}\u{9e9}\u{9ee}\u{9f5}\u{a0f}\u{a14}\u{a16}\
	\u{a1d}\u{a21}\u{a28}\u{a2c}\u{a3d}\u{a4c}\u{a53}\u{a5c}\u{a66}\u{a6b}\u{a74}\
	\u{a79}\u{a81}\u{a89}\u{a8c}\u{a92}\u{a95}\u{a9c}\u{aa4}\u{aa7}\u{aaf}\u{ab2}\
	\u{acc}\u{ad7}\u{adc}\u{ae3}\u{ae5}\u{af2}\u{b01}\u{b05}\u{b09}\u{b0d}\u{b13}\
	\u{b17}\u{b1b}\u{b1f}\u{b21}\u{b2b}\u{b32}\u{b3b}\u{b42}\u{b49}\u{b50}\u{b5a}\
	\u{b68}\u{b6f}\u{b76}\u{b7e}\u{b81}\u{b85}\u{b89}\u{b8c}";
