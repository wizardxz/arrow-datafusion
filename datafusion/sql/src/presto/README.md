# ANTLR parser + planner development guide

We use presto grammar to generate a parser and make a planer `presto/planner.rs` to bind the parsing tree to datafusion logical plan.

## How to generate parser

The parser is in `src/antlr/generated/presto`
You do **NOT** have to generate parser unless any rules in grammar file `src/antlr/Presto.g4` is updated. 
To generated parser
```
cd src/antlr
java -jar antlr4-4.8-2-SNAPSHOT-complete.jar -Dlanguage=Rust Presto.g4 -o generated/presto
```

### How to get ANTLR binary (antlr4-4.8-2-SNAPSHOT-complete.jar)

We will check-in this binary in somewhere in the future. Currently we have to build it because there are bugs in ANTLR Rust https://github.com/rrevenantt/antlr4

Here are the step to install JAVA8 in your mac
```
brew tap adoptopenjdk/openjdk
brew install --cask adoptopenjdk8
echo 'export JAVA_HOME=/Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home' >> ~/.zshrc

brew install mvn
```

Here 
git clone -b rust-target https://github.com/rrevenantt/antlr4
cd antlr4
git submodule update --init --recursive --remote

cd runtime/Rust
git remote add fork git@github.com:wizardxz/antlr4rust.git

git fetch fork fix_presto_code_gen
git checkout fork/fix_presto_code_gen

cd ../../
mvn -DskipTests package

ls tool/target/antlr4-4.8-2-SNAPSHOT-complete.jar

## How to generate planner

### Context
You can generate some components in `presto/planner.rs` in 
```
// Begin generated boiler plate
...
// End generated boiler plate
```

The boiler plate we generated are `Binder<S>` implementation for parsing tree node. 
The mapping between parsing tree node and `S` is from `src/antlr/Presto.g4`. Example
```
singleStatement options {logical='LogicalPlan';} // means mapping singleStatement to LogicalPlan
```
So in `presto/planner.rs`, there should be
```
impl Binder<LogicalPlan> for SingleStatementContextAll<'_> {}
```
In vscode, use cmd+. to implement default members

The mapping could be one to many, example
```
qualifiedName options {logical='OwnedTableReference,Vec<String>,Expr';}
```
In this case, generated code are
```
impl Binder<OwnedTableReference> for QualifiedNameContextAll<'_> {}
impl Binder<Vec<String>> for QualifiedNameContextAll<'_> {}
impl Binder<Expr> for QualifiedNameContextAll<'_> {}
```

There are 3 types of parsing tree node. Here are examples in `Presto.g4`
```
statement options {logical='LogicalPlan';}
    : query                                                            #statementDefault
    | ...

query options {logical='LogicalPlan';}
    :  with? queryNoWith
    ;
```
1. The route
It is the special ANTLR rule with alternative label, like `statement`. The generated code for the route does not need to be implemented. Example
```
#[route(
    statementDefault,
    ...
)]
impl Binder<LogicalPlan> for StatementContextAll<'_> {}
```
2. The alternative label
It is the label for alternative in a route, like `statementDefault`. The generated code for the alternative label need to be implemented.Example
```
impl Binder<LogicalPlan> for StatementDefaultContext<'_> {            // Generated by gen_binder.py
    fn bind(&self, bc: &BindingContextStack) -> Result<LogicalPlan> { // You use cmd+. to generate
        self.query().unwrap().bind(bc)                                // Your implementation
    }
}
```
3. The rule
It is the common ANTLR rule without alternative label, like `query`. The generated code for the rule need to be implemented. Example
```
impl Binder<LogicalPlan> for QueryContextAll<'_> {                              // Generated by gen_binder.py
    fn bind(&self, bc: &BindingContextStack) -> Result<LogicalPlan> {           // You use cmd+. to generate
        if let Some(with_ctx) = self.with() {                                   // Your implementation
            if with_ctx.RECURSIVE().is_some() {                                 // Your implementation
                return Err(DataFusionError::NotImplemented(String::from(        // Your implementation
                    "Recursive CTEs are not supported",                         // Your implementation
                )));                                                            // Your implementation
            }                                                                   // Your implementation
        }                                                                       // Your implementation
        let named_query_ctxes = if let Some(with_ctx) = self.with() {           // Your implementation
            with_ctx.namedQuery_all()                                           // Your implementation
        } else {                                                                // Your implementation
            vec![]                                                              // Your implementation
        };

        bind_with_query(bc, &named_query_ctxes, &self.queryNoWith().unwrap())   // Your implementation
    }
}
```

### The development flow

If you want to add mapping, simply add them in `Presto.g4`. Then 
```
cd sql/src/antlr/
python3 gen_binder.py
cargo fmt --all
```


If antlr python runtime is not installed, try
```
cd sql/src/antlr/
pip install -r requirements.txt
```

If you want to delete mapping, please manually do it in `Presto.g4` and `presto/planner.rs`

### How `gen_binder.py` works?

It parse the `Presto.g4` and retrive mappings and generate code in `presto/planner.rs`.
The `gen_binder.py` requires the ANTLR parser, which is originally generated from

```
cd sql/src/antlr/
java -jar antlr4-4.8-2-SNAPSHOT-complete.jar -Dlanguage=Python3 LexBasic.g4 ANTLRv4Lexer.g4 ANTLRv4Parser.g4 -o generated/antlr -visitor
```
Please note you won't need to run this again. We have already checked-in the parser to the repo.
